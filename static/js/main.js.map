{"version":3,"sources":["../webpack/bootstrap","imgs/collection.svg","imgs/view.svg","imgs/half.svg","codeTemplates/backtrack.js","imgs/uf.svg","imgs/bfs.svg","imgs/tree.svg","imgs/window.svg","imgs/segment.svg","codeTemplates/heap.js","utils.js","codeTemplates/preSum.js","codeTemplates/hand-writing.js","constant/index.js","imgs/backtrack.svg","imgs/heap.svg","imgs/preSum.svg","imgs/hand-writing.svg","complexityRating/index.less","imgs/sqrt.svg","imgs/formula/sum.svg","imgs/formula/times.svg","imgs/formula/div.svg","imgs/formula/frac.svg","imgs/formula/approx.svg","imgs/formula/sqrt.svg","imgs/formula/choice.svg","db/root.db.js","db/db.js","components/CodeBlock.jsx","components/codes.jsx","components/TagOrLink.jsx","Detail.jsx","roadmap/roadmap.jsx","codeTemplates/binarySearch.js","codeTemplates/uf.js","codeTemplates/bfs.js","codeTemplates/trie.js","codeTemplates/sliding-window.js","codeTemplates/segmentTree.js","codeTemplates/index.js","checkUpdates.js","codeTemplates/codeTemplate.jsx","complexityRating/index.jsx","components/MarkdownRender.jsx","solutionTemplate/index.jsx","App.js","serviceWorker.js","index.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","installedCssChunks","2","exports","module","l","e","promises","Promise","resolve","reject","href","fullhref","p","existingLinkTags","document","getElementsByTagName","dataHref","tag","getAttribute","rel","existingStyleTags","linkTag","createElement","type","onload","onerror","event","request","target","src","err","Error","code","parentNode","removeChild","appendChild","then","installedChunkData","promise","onScriptComplete","script","charset","timeout","nc","setAttribute","jsonpScriptSrc","error","clearTimeout","chunk","errorType","realSrc","message","name","undefined","setTimeout","head","all","m","c","d","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","console","jsonpArray","this","oldJsonpFunction","slice","logo","require","title","list","text","problems","id","codes","language","link","content","window","alert","copyToClipboard","str","el","body","select","execCommand","isInExtension","process","REACT_APP_BUILD_TARGET","bjwd","ISSUES_URL","getUrlParameter","URLSearchParams","location","search","uuidv4","replace","Math","random","toString","copy","cb","copyFrom","textContent","blur","Function","getStorage","k","chrome","storage","localStorage","JSON","parse","getItem","setStorage","v","sync","set","setItem","stringify","log","setCloundStorage","token","fetch","method","headers","customer","address","res","json","getCloundStorage","response","order","debounce","fn","wait","callback","timerId","context","args","arguments","LEETCODE_CN_URL","CONTRIBUTE_COMPANY_URL","CONTRIBUTE_PROGRAMMING_LANGUAGE_URL","db_collection","company","values","forEach","problem","companies","selected","url","CodeBlock","props","toLowerCase","style","coy","PureComponent","defaultProps","Panel","Collapse","Codes","renderHeader","map","header","className","size","onClick","stopPropagation","success","TagOrLink","color","display","TabPane","Tabs","db","Detail","problemId","defaultActiveKey","tab","pre","keyPoints","solution","giteeSolution","disabled","marginRight","roadmaps","desc","items","pic","keys","dp","RoadMap","useState","topic","setTopic","Group","onChange","buttonStyle","Button","item","width","height","halfLogo","ufLogo","bfsLogo","treeLogo","windowLogo","segmentLogo","preSum","binarySearch","bfs","heap","slidingWindow","backtrack","trie","uf","segmemntTree","handWriting","checkUpdate","runtime","requestUpdateCheck","status","onUpdateAvailable","addListener","details","version","reload","CodeTemplate","tempaltes","tempalte","alt","margin","marginLeft","columns","dataIndex","align","render","complexity","ComplexityRating","dataSource","debounceRender","newProps","escapeHtml","plugins","RemarkMathPlugin","renderers","inlineMath","math","block","_props","TextArea","Input","Option","Select","slogan","displayLanguage","python","python3","java","cpp","javascript","go","ruby","swift","scala","kotlin","rust","php","typescript","getTemplate","keyword","time","space","isLucifer","toLocaleLowerCase","Template","template","ref","textAreaRef","autoSize","Complexities","formulas","formula","String","raw","saveDraft","initialLanguage","React","createRef","SolutionTemplate","state","isloading","setLanguage","setState","setTime","setSpace","setIsLucifer","setTemplate","catch","RegExp","checked","includes","spinning","delay","span","marginTop","source","DataStrutureVis","lazy","row","tags","initialTab","App","tabs","query","active","lastFocusedWindow","match","setProblemId","setHasSolution","setInSelected","hasSolution","inSelected","page","setPage","setTab","position","zIndex","top","bottom","left","right","backgroundColor","viewLogo","collectionLogo","description","pagination","hideOnSinglePage","rowKey","activeKey","fallback","Boolean","hostname","ReactDOM","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded CSS chunks\n \tvar installedCssChunks = {\n \t\t2: 0\n \t}\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t2: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"static/js/\" + ({}[chunkId]||chunkId) + \"-\" + \"174c114521cfb13f6531\" + \".chunk.js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// mini-css-extract-plugin CSS loading\n \t\tvar cssChunks = {\"5\":1};\n \t\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n \t\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n \t\t\tpromises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {\n \t\t\t\tvar href = \"static/css/\" + ({}[chunkId]||chunkId) + \"-\" + \"174c114521cfb13f6531\" + \".chunk.css\";\n \t\t\t\tvar fullhref = __webpack_require__.p + href;\n \t\t\t\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n \t\t\t\tfor(var i = 0; i < existingLinkTags.length; i++) {\n \t\t\t\t\tvar tag = existingLinkTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n \t\t\t\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();\n \t\t\t\t}\n \t\t\t\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n \t\t\t\tfor(var i = 0; i < existingStyleTags.length; i++) {\n \t\t\t\t\tvar tag = existingStyleTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\");\n \t\t\t\t\tif(dataHref === href || dataHref === fullhref) return resolve();\n \t\t\t\t}\n \t\t\t\tvar linkTag = document.createElement(\"link\");\n \t\t\t\tlinkTag.rel = \"stylesheet\";\n \t\t\t\tlinkTag.type = \"text/css\";\n \t\t\t\tlinkTag.onload = resolve;\n \t\t\t\tlinkTag.onerror = function(event) {\n \t\t\t\t\tvar request = event && event.target && event.target.src || fullhref;\n \t\t\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + request + \")\");\n \t\t\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n \t\t\t\t\terr.request = request;\n \t\t\t\t\tdelete installedCssChunks[chunkId]\n \t\t\t\t\tlinkTag.parentNode.removeChild(linkTag)\n \t\t\t\t\treject(err);\n \t\t\t\t};\n \t\t\t\tlinkTag.href = fullhref;\n\n \t\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\n \t\t\t\thead.appendChild(linkTag);\n \t\t\t}).then(function() {\n \t\t\t\tinstalledCssChunks[chunkId] = 0;\n \t\t\t}));\n \t\t}\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/leetcode-cheat/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = this[\"webpackJsonpleetcode-cheat\"] = this[\"webpackJsonpleetcode-cheat\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([630,3]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","module.exports = __webpack_public_path__ + \"static/media/collection.309574ec.svg\";","module.exports = __webpack_public_path__ + \"static/media/view.d44e31d9.svg\";","module.exports = __webpack_public_path__ + \"static/media/half.8a1d5a9c.svg\";","module.exports = {\n  logo: require(\"../imgs/backtrack.svg\"),\n  title: \"回溯\",\n  list: [\n    {\n      text: \"标准回溯（伪代码）\",\n      problems: [\n        {\n          id: \"combination-sum\",\n          title: \"39. 组合总和\",\n        },\n        {\n          title: \"40. 组合总和 II\",\n          id: \"combination-sum-ii\",\n        },\n        {\n          title: \"46. 全排列\",\n          id: \"permutations\",\n        },\n        {\n          title: \"47. 全排列 II\",\n          id: \"permutations-ii\",\n        },\n        {\n          id: \"N-Queens-II\",\n          title: \"52. N 皇后 II\",\n        },\n        {\n          id: \"subsets\",\n          title: \"78. 子集\",\n        },\n        {\n          id: \"subsets-ii\",\n          title: \"90. 子集 II\",\n        },\n        {\n          id: \"path-sum-ii\",\n          title: \"113. 路径总和 II\",\n        },\n        {\n          id: \"palindrome-partitioning\",\n          title: \"131. 分割回文串\",\n        },\n        {\n          id: \"maximum-score-words-formed-by-letters\",\n          title: \"1255. 得分最高的单词集合\",\n        },\n      ],\n      codes: [\n        {\n          language: \"js\",\n          text: `\n          const visited = {}\n          function backtrack(i) {\n              if (满足特定条件）{\n                  // 返回结果 or 退出搜索空间\n              }\n          \n              visited[i] = true // 将当前状态标为已搜索\n              dosomething(i) // 对i做一些操作\n              for (根据i能到达的下个状态j) {\n                  if (!visited[j]) { // 如果状态j没有被搜索过\n                      dfs(j)\n                  }\n              }\n              undo(i) // 恢复i\n          }\n          backtrack(0)\n          `,\n        },\n      ],\n    },\n    {\n      text: \"笛卡尔积优化\",\n      problems: [\n        {\n          id: \"word-break-ii\",\n          title: \"140. 单词拆分 II\",\n        },\n        {\n          id: \"ambiguous-coordinates\",\n          title: \"816. 模糊坐标\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        n = len(s)\n        @lru_cache(None)\n        def backtrack(start):\n            ans = []\n            if start == n:\n                ans.append('')\n            for i in range(start, n):\n                if s[start:i + 1] in wordDict:\n                    if start == 0: temp = s[start:i + 1]\n                    else: temp = \" \" + s[start:i + 1]\n                    ps = backtrack(i + 1)\n                    for p in ps:\n                        ans.append(temp + p)\n            return ans\n        return backtrack(0)`,\n        },\n      ],\n    },\n  ],\n  link:\n    \"https://github.com/azl397985856/leetcode/blob/master/thinkings/backtrack.md\",\n};\n","module.exports = __webpack_public_path__ + \"static/media/uf.b7241116.svg\";","module.exports = __webpack_public_path__ + \"static/media/bfs.afdef661.svg\";","module.exports = __webpack_public_path__ + \"static/media/tree.1b289fc6.svg\";","module.exports = __webpack_public_path__ + \"static/media/window.849c4a15.svg\";","module.exports = __webpack_public_path__ + \"static/media/segment.898267a9.svg\";","const minHeapJSCode = `\nclass MinHeap {\n\n    constructor () {\n        /* Initialing the array heap and adding a dummy element at index 0 */\n        this.heap = [null]\n    }\n\n    peek() {\n        /* Accessing the min element at index 1 in the heap array */\n        return this.heap[1]\n    }\n    \n    push (node) {\n\n        /* Inserting the new node at the end of the heap array */\n        this.heap.push(node)\n\n        /* Finding the correct position for the new node */\n\n        if (this.heap.length > 1) {\n            let current = this.heap.length - 1\n\n            /* Traversing up the parent node until the current node (current) is greater than the parent (current/2)*/\n            while (current > 1 && this.heap[Math.floor(current/2)] > this.heap[current]) {\n\n                /* Swapping the two nodes by using the ES6 destructuring syntax*/\n                [this.heap[Math.floor(current/2)], this.heap[current]] = [this.heap[current], this.heap[Math.floor(current/2)]]\n                current = Math.floor(current/2)\n            }\n        }\n    }\n    \n    pop() {\n        /* Smallest element is at the index 1 in the heap array */\n        let smallest = this.heap[1]\n\n        /* When there are more than two elements in the array, we put the right most element at the first position\n            and start comparing nodes with the child nodes\n        */\n        if (this.heap.length > 2) {\n            this.heap[1] = this.heap[this.heap.length-1]\n            this.heap.splice(this.heap.length - 1)\n\n            if (this.heap.length === 3) {\n                if (this.heap[1] > this.heap[2]) {\n                    [this.heap[1], this.heap[2]] = [this.heap[2], this.heap[1]]\n                }\n                return smallest\n            }\n\n            let current = 1\n            let leftChildIndex = current * 2\n            let rightChildIndex = current * 2 + 1\n\n            while (this.heap[leftChildIndex] &&\n                    this.heap[rightChildIndex] &&\n                    (this.heap[current] > this.heap[leftChildIndex] ||\n                        this.heap[current] > this.heap[rightChildIndex])) {\n                if (this.heap[leftChildIndex] < this.heap[rightChildIndex]) {\n                    [this.heap[current], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[current]]\n                    current = leftChildIndex\n                } else {\n                    [this.heap[current], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[current]]\n                    current = rightChildIndex\n                }\n\n                leftChildIndex = current * 2\n                rightChildIndex = current * 2 + 1\n            }\n        }\n\n        /* If there are only two elements in the array, we directly splice out the first element */\n\n        else if (this.heap.length === 2) {\n            this.heap.splice(1, 1)\n        } else {\n            return null\n        }\n\n        return smallest\n    }\n    /**\n     * Your MinHeap object will be instantiated and called as such:\n     * var obj = new MinHeap()\n     * obj.push(1)\n     * obj.push(2)\n     * obj.peek() // will return 1\n     * obj.pop() // remove 1\n     * obj.peek() // will return 2\n     */ \n}\n`;\n\nconst minHeapPythonCode = `\nclass min_heap:\n    def __init__(self):\n        self.h = [0]\n\n    def shift_up(self, i):\n        while i // 2 > 0:\n            if self.h[i] < self.h[i // 2]:\n                self.h[i], self.h[i//2] = self.h[i//2], self.h[i]\n            i = i // 2\n\n    def shift_down(self, i):\n        while (i * 2) <= len(self.h)-1:\n            mc = self.minChild(i)\n            if self.h[i] > self.h[mc]:\n                self.h[i], self.h[mc] = self.h[mc], self.h[i]\n            i = mc\n\n    def minChild(self, i):\n        if i * 2 + 1 > len(self.h)-1:\n            return i * 2\n        if self.h[i*2] < self.h[i*2+1]:\n            return i * 2\n        else:\n            return i * 2 + 1\n\n    def heappop(self):\n        if len(self.h) == 1:\n            return None\n        ans = self.h[1]\n        self.h[1] = self.h[len(self.h)-1]\n        self.h.pop()\n        self.shift_down(1)\n        return ans\n\n    def heappush(self, a):\n        self.h.append(a)\n        self.shift_up(len(self.h)-1)\n\n    def build_heap(self, A):\n        self.h = [0] + A\n        i = 1\n        while (i < len(self.h)):\n            self.shift_down(i)\n            i = i + 1\n\n# 使用：\n\nh = min_heap()\nh.build_heap([5, 6, 2, 3])\n\nh.heappush(1)\nh.heappop() # 1\nh.heappop() # 2\nh.heappush(1)\nh.heappop() # 1\nh.heappop() # 3\n`;\n\nconst minHeapJavaCode = `\n// by @CaptainZ\nimport java.util.Arrays;\nimport java.util.Comparator;\n\n/**\n * 用完全二叉树来构建 堆\n * 前置条件 起点为 1\n * 那么 子节点为  i <<1 和 i<<1 + 1\n * 核心方法为\n * shiftdown 交换下沉\n * shiftup 交换上浮\n * <p>\n * build 构建堆\n */\n\npublic class MinHeap {\n\n    int size = 0;\n    int queue[];\n\n    public Heap(int initialCapacity) {\n        if (initialCapacity < 1)\n            throw new IllegalArgumentException();\n        this.queue = new int[initialCapacity];\n    }\n\n    public Heap(int[] arr) {\n        size = arr.length;\n        queue = new int[arr.length + 1];\n        int i = 1;\n        for (int val : arr) {\n            queue[i++] = val;\n        }\n    }\n\n    public void shiftDown(int i) {\n\n        int temp = queue[i];\n\n        while ((i << 1) <= size) {\n            int child = i << 1;\n            // child!=size 判断当前元素是否包含右节点\n            if (child != size && queue[child + 1] < queue[child]) {\n                child++;\n            }\n            if (temp > queue[child]) {\n                queue[i] = queue[child];\n                i = child;\n            } else {\n                break;\n            }\n        }\n        queue[i] = temp;\n    }\n\n\n    public void shiftUp(int i) {\n        int temp = queue[i];\n        while ((i >> 1) > 0) {\n            if (temp < queue[i >> 1]) {\n                queue[i] = queue[i >> 1];\n                i >>= 1;\n            } else {\n                break;\n            }\n        }\n        queue[i] = temp;\n    }\n\n    public int peek() {\n\n        int res = queue[1];\n        return res;\n    }\n\n    public int pop() {\n\n        int res = queue[1];\n\n        queue[1] = queue[size--];\n        shiftDown(1);\n        return res;\n    }\n\n    public void push(int val) {\n        if (size == queue.length - 1) {\n            queue = Arrays.copyOf(queue, size << 1+1);\n        }\n        queue[++size] = val;\n        shiftUp(size);\n    }\n\n    public void buildHeap() {\n        for (int i = size >> 1; i >= 0; i--) {\n            shiftDown(i);\n        }\n    }\n\n    public static void main(String[] args) {\n        int arr[] = new int[]{2,7,4,1,8,1};\n        Heap heap = new Heap(arr);\n        heap.buildHeap();\n        System.out.println(heap.peek());\n        heap.push(5);\n        while (heap.size > 0) {\n            int num = heap.pop();\n            System.out.printf(num + \"\");\n        }\n    }\n}\n\n\n`;\nmodule.exports = {\n  logo: require(\"../imgs/heap.svg\"),\n  title: \"堆\",\n  list: [\n    {\n      text: \"小顶堆\",\n      problems: [\n        {\n          title: \"1046. 最后一块石头的重量(这道题需要用大顶堆，不过都差不多)\",\n          id: \"last-stone-weight\",\n        },\n      ],\n      codes: [\n        {\n          language: \"js\",\n          text: minHeapJSCode,\n        },\n        {\n          language: \"py\",\n          text: minHeapPythonCode,\n        },\n        {\n          language: \"java\",\n          text: minHeapJavaCode,\n        },\n      ],\n    },\n  ],\n  link: \"\",\n};\n","import { ISSUES_URL } from \"./constant/index\";\n\nfunction TreeNode(value) {\n  return {\n    left: null,\n    right: null,\n    value,\n  };\n}\nconst message = {\n  error({ content }) {\n    window.alert(content);\n  },\n};\nconst seen = {};\nexport function getRandomUnique(lower, upper, amount) {\n  console.log(seen);\n  // [10, 20]10\n  const start = getRandom(0, upper - lower - amount);\n  if (`${lower}-${upper}` in seen)\n    return seen[`${lower}-${upper}`].slice(start, start + amount + 1);\n\n  const condidates = Array.from(Array(upper - lower + 1), (_, i) => i + lower);\n\n  const n = condidates.length;\n  for (let i = n - 1; i >= 0; i--) {\n    const temp = condidates[i];\n    const number = (Math.random() * n) >>> 0;\n    condidates[i] = condidates[number];\n    condidates[number] = temp;\n  }\n  seen[`${lower}-${upper}`] = condidates;\n  return condidates.slice(start, start + amount + 1);\n}\n\nexport function getRandom(n, m) {\n  return Math.round(Math.random() * (m - n) + n);\n}\nexport function copyToClipboard(str) {\n  try {\n    const el = document.createElement(\"textarea\");\n    el.value = str;\n    document.body.appendChild(el);\n    el.select();\n    document.execCommand(\"copy\");\n    document.body.removeChild(el);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\nexport function serialise_bfs(root) {\n  let ans = \"[\";\n  const q = [root];\n  let cur = null;\n\n  while (q.length > 0) {\n    cur = q.shift();\n    if (cur) {\n      q.push(cur.left);\n      q.push(cur.right);\n      ans += cur.value + \",\";\n    } else {\n      ans += \"null,\";\n    }\n  }\n\n  return ans.slice(0, -1) + \"]\";\n}\nexport function isInExtension() {\n  return process.env.REACT_APP_BUILD_TARGET === \"extension\";\n}\nexport function buildRandomTree({\n  amount = 10,\n  upper = 10,\n  lower = 0,\n  isUnique,\n}) {\n  let remain = amount;\n  let condidates = [];\n  if (isUnique) {\n    condidates = getRandomUnique(lower, upper, amount);\n  }\n\n  function dfs({ upper, lower }) {\n    if (remain <= 0) return null;\n    remain -= 1;\n\n    const root = TreeNode(\n      !isUnique ? getRandom(lower, upper) : condidates[remain]\n    );\n\n    if (Math.random() > 0.5) {\n      root.left = dfs({ upper, lower });\n    }\n    if (Math.random() > 0.5) {\n      root.right = dfs({ upper, lower });\n    }\n    return root;\n  }\n  return dfs({ upper, lower });\n}\n\nexport function bjwd() {\n  return message.error({\n    content: `\n        力扣不讲武德，不按套路出牌。不过没关系啊，你反馈给我，下次一定全部防出去！反馈到这里：${ISSUES_URL}\n      `,\n  });\n}\nexport function getUrlParameter(key) {\n  const searchParams = new URLSearchParams(window.location.search);\n  return searchParams.get(key);\n}\n\nexport function uuidv4() {\n  return \"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    var r = (Math.random() * 16) | 0,\n      v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport function deserialise_bfs(nodes) {\n  if (nodes.length === 0 || nodes[0] === \"null\") return null;\n  const root = TreeNode(nodes[0]);\n  const q = [root];\n  let i = 0;\n\n  while (q.length > 0 && i < nodes.length - 1) {\n    const cur = q.shift();\n\n    const l = TreeNode(nodes[i + 1]);\n    if (l.value !== \"null\") {\n      q.push(l);\n      cur.left = l;\n    }\n\n    if (i < nodes.length - 2) {\n      const r = TreeNode(nodes[i + 2]);\n\n      if (r.value !== \"null\") {\n        q.push(r);\n        cur.right = r;\n      }\n    }\n\n    i += 2;\n  }\n\n  return {\n    root,\n  };\n}\n\nexport function copy(text, cb) {\n  //Create a textbox field where we can insert text to.\n  var copyFrom = document.createElement(\"textarea\");\n\n  //Set the text content to be the text you wished to copy.\n  copyFrom.textContent = text;\n\n  //Append the textbox field into the body as a child.\n  //\"execCommand()\" only works when there exists selected text, and the text is inside\n  //document.body (meaning the text is part of a valid rendered HTML element).\n  document.body.appendChild(copyFrom);\n\n  //Select all the text!\n  copyFrom.select();\n\n  //Execute command\n  document.execCommand(\"copy\");\n\n  //(Optional) De-select the text using blur().\n  copyFrom.blur();\n\n  //Remove the textbox field from the document.body, so no other JavaScript nor\n  //other elements can get access to this.\n  document.body.removeChild(copyFrom);\n\n  if (cb instanceof Function) cb();\n}\n\nexport function getStorage(k) {\n  return new Promise((resolve, reject) => {\n    try {\n      // eslint-disable-next-line\n      if (chrome.storage) {\n        // eslint-disable-next-line\n        chrome.storage.get([k], resolve);\n      } else if (localStorage) {\n        resolve({\n          result: {\n            value: JSON.parse(localStorage.getItem(k)),\n          },\n        });\n      } else {\n        reject(\"未知错误\");\n      }\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n\nexport function setStorage(k, v) {\n  return new Promise((resolve, reject) => {\n    try {\n      // eslint-disable-next-line\n      if (chrome.storage) {\n        // eslint-disable-next-line\n        chrome.storage.sync.set(\n          {\n            [k]: v,\n          },\n          resolve\n        );\n      } else if (localStorage) {\n        localStorage.setItem(k, JSON.stringify(v));\n        resolve();\n      } else {\n        reject(\"您可能禁用了存储功能~\");\n      }\n    } catch (err) {\n      console.log(err, k, v);\n      reject(\"当前没有存储权限，或者存储已达到上限~\");\n    }\n  });\n}\n\nexport function setCloundStorage(content, { token }) {\n  // return fetch(\"https://api.github.com/repos/azl397985856/stash/issues\", {\n  //   method: \"POST\",\n  //   headers: {\n  //     \"Content-Type\": \"application/json\",\n  //     Authorization: `token ${token}`,\n  //   },\n  //   body: JSON.stringify(content),\n  // })\n  //   .then((res) => res.json())\n  //   .then((res) => {\n  //     return {\n  //       ...res,\n  //       id: res.number,\n  //     };\n  //   });\n  return fetch(\"https://my-store2.p.rapidapi.com/order/new\", {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/json\",\n      \"x-rapidapi-key\": \"8be902d767mshf5d232d6b781084p166217jsn382abe83434f\",\n      \"x-rapidapi-host\": \"my-store2.p.rapidapi.com\",\n    },\n    body: JSON.stringify({\n      customer: JSON.stringify({\n        body: content,\n      }),\n      address: \"\",\n    }),\n  }).then((res) => res.json());\n}\n\nexport function getCloundStorage(id, { token }) {\n  // return fetch(\n  //   `https://api.github.com/repos/azl397985856/stash/issues/${id}`,\n  //   {\n  //     headers: {\n  //       accept: \"application/json\",\n  //       \"Content-Type\": \"application/json\",\n  //       Authorization: `token ${token}`,\n  //     },\n  //   }\n  // )\n  //   .then((res) => res.json())\n  //   .then((res) => JSON.parse(res.body));\n  return fetch(`https://my-store2.p.rapidapi.com/order/${id}`, {\n    method: \"GET\",\n    headers: {\n      \"x-rapidapi-key\": \"7ff25b0080msh1ceb86e07b1e8dap16725fjsn940e2fa29e24\",\n      \"x-rapidapi-host\": \"my-store2.p.rapidapi.com\",\n    },\n  })\n    .then((res) => res.json())\n    .then((response) => {\n      return JSON.parse(response.order.customer).body;\n    });\n}\n\nexport function debounceComponent(component, wait) {\n  let timerId = null;\n  return (props) => {\n    clearTimeout(timerId);\n    component(props);\n  };\n}\nexport function debounce(fn, wait) {\n  let callback = fn;\n  let timerId = null;\n\n  function debounced() {\n    // 保存作用域\n    let context = this;\n    // 保存参数，例如 event 对象\n    let args = arguments;\n\n    clearTimeout(timerId);\n    timerId = setTimeout(function () {\n      callback.apply(context, args);\n    }, wait);\n  }\n\n  // 返回一个闭包\n  return debounced;\n}\nconst COLORS = [\n  \"magenta\",\n  \"red\",\n  \"volcano\",\n  \"orange\",\n  \"gold\",\n  \"lime\",\n  \"green\",\n  \"cyan\",\n  \"blue\",\n  \"geekblue\",\n  \"purple\",\n];\n\nexport function getColor(text) {\n  let ans = 0;\n  for (const c of text) ans += c.charCodeAt();\n  return COLORS[ans % COLORS.length];\n}\n","const pre1dJSCode = `\n  // 建立\n  const pre = [0]\n  for(const num of nums) {\n      pre.push(pre[pre.length-1] + num)\n  }\n  // 使用，等价于 nums[i] + nums[i + 1] + ... + nums[j]\n  pre[j+1] - pre[i]\n`;\n\nconst pre1dPythonCode = `\n  # 建立\n  pre = []\n  for num in nums:\n      pre.append(pre[-1] + num)\n  #  使用，等价于 nums[i] + nums[i + 1] + ... + nums[j]\n  pre[j+1] - pre[i] \n`;\n\nconst pre2dPythonCode = `\n  m,n = len(matrix), len(matrix[0])\n  # 建立\n  pre = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n  for i in range(1, m+1):\n      for j in range(1, n +1):\n          pre[i][j] = pre[i-1][j]+ pre[i][j-1] - pre[i-1][j-1] + matrix[i-1][j-1]\n\n  # 使用，等价于以(x1,y1)为矩阵左上角以(x2,y2)为矩阵右下角的所有格子的和\n  pre[x2+1][y2+1] + pre[x1][y1] - pre[x1][y2+1] - pre[x2+1][y1]\n`;\n\nmodule.exports = {\n  title: \"前缀和\",\n  logo: require(\"../imgs/preSum.svg\"),\n  list: [\n    {\n      text: \"一维前缀和\",\n      problems: [\n        {\n          title: \"1480. 一维数组的动态和\",\n          id: \"running-sum-of-1d-array\",\n        },\n      ],\n      codes: [\n        {\n          language: \"js\",\n          text: pre1dJSCode,\n        },\n        {\n          language: \"py\",\n          text: pre1dPythonCode,\n        },\n      ],\n    },\n    {\n      text: \"二维前缀和\",\n      problems: [\n        {\n          title: \"1314. 矩阵区域和\",\n          id: \"matrix-block-sum\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: pre2dPythonCode,\n        },\n      ],\n    },\n  ],\n  link: \"\",\n};\n","module.exports = {\n  logo: require(\"../imgs/hand-writing.svg\"),\n  title: \"手撕算法\",\n  list: [\n    {\n      text: \"数组排序\",\n      problems: [\n        {\n          id: \"sort-an-array\",\n          title: \"912. 排序数组\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\n# 1. 归并排序（推荐！其他排序方法都不推荐在竞赛中使用）\n# 归并排序乞丐版\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        def mergeSort(l, r):\n            if l >= r:\n                return\n            mid = (l + r) // 2\n            mergeSort(l, mid)\n            mergeSort(mid + 1, r)\n            temp = []\n            i, j = l, mid + 1\n            while i <= mid and j <= r:\n                if nums[i] < nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= r:\n                temp.append(nums[j])\n                j += 1\n            nums[l : r + 1] = temp\n\n        mergeSort(0, len(nums) - 1)\n        return nums\n# 归并排序优化版\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        temp = [0] * len(nums)\n\n        def mergeSort(l, r):\n            if l >= r:\n                return\n            mid = (l + r) // 2\n            mergeSort(l, mid)\n            mergeSort(mid + 1, r)\n            i, j = l, mid + 1\n            k = 0\n            while i <= mid and j <= r:\n                if nums[i] < nums[j]:\n                    temp[k] = nums[i]\n                    i += 1\n                else:\n                    temp[k] = nums[j]\n                    j += 1\n                k += 1\n            while i <= mid:\n                temp[k] = nums[i]\n                i += 1\n                k += 1\n            while j <= r:\n                temp[k] = nums[j]\n                j += 1\n                k += 1\n            nums[l : r + 1] = temp[: r - l + 1]\n\n        mergeSort(0, len(nums) - 1)\n        return nums\n\n# 2. 快速排序\n# 快速排序乞丐版\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        temp = [0] * len(nums)\n\n        def quickSort(nums):\n            if not nums: return []\n            pivot = nums[0]\n            nums = nums[1:]\n            l = quickSort([num for num in nums if num <= pivot])\n            r = quickSort([num for num in nums if num > pivot])\n            return l + [pivot] + r\n\n        return quickSort(nums)\n# 快速排序优化版\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        temp = [0] * len(nums)\n\n        def partition(l, r):\n            pivot = nums[l]\n\n            while l < r:\n                while l < r and nums[r] >= pivot:\n                    r -= 1\n                nums[l] = nums[r]\n                while l < r and nums[l] <= pivot:\n                    l += 1\n                nums[r] = nums[l]\n            nums[l] = pivot\n            return l\n\n        def quickSort(l, r):\n            if l >= r:\n                return\n            pivot = partition(l, r)\n            quickSort(l, pivot - 1)\n            quickSort(pivot + 1, r)\n\n        quickSort(0, len(nums) - 1)\n        return nums\n\n# 3. 插入排序\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        for i in range(1, n):\n            t = nums[i]\n            j = i - 1\n            while j > -1 and nums[j] > t:\n                nums[j + 1] = nums[j]\n                j -= 1\n            nums[j + 1] = t\n        return nums\n\n# 4. 选择排序\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        for i in range(n - 1):\n            k = i\n            for j in range(i + 1, n):\n                if nums[j] < nums[k]:\n                    k = j\n            nums[i], nums[k] = nums[k], nums[i]\n        return nums\n\n# 5. 冒泡排序\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[j] < nums[i]:\n                    nums[i], nums[j] = nums[j], nums[i]\n        return nums\n\n            `,\n        },\n      ],\n    },\n    {\n      text: \"链表排序\",\n      problems: [\n        {\n          id: \"sort-list\",\n          title: \"148. 排序链表\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\n# 1. 归并排序（推荐！其他排序方法都不推荐在竞赛中使用）\nclass Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        def mergeSort(head: ListNode) -> ListNode:\n            if not head or not head.next:\n                return head\n            dummyHead = ListNode(-1)\n            dummyHead.next = head\n            slow, fast = dummyHead, head\n            while fast and fast.next:\n                slow = slow.next\n                fast = fast.next.next\n            nxt = slow.next\n            slow.next = None\n            return merge(mergeSort(head), mergeSort(nxt))\n\n        def merge(head1: ListNode, head2: ListNode) -> ListNode:\n            dummyHead = ListNode(-1)\n            temp, l1, l2 = dummyHead, head1, head2\n            while l1 and l2:\n                if l1.val <= l2.val:\n                    temp.next = l1\n                    l1 = l1.next\n                else:\n                    temp.next = l2\n                    l2 = l2.next\n                temp = temp.next\n            if l1:\n                temp.next = l1\n            elif l2:\n                temp.next = l2\n            return dummyHead.next\n\n        return mergeSort(head)\n# 2. 快速排序\nclass Solution:\n    def sortList(self, head):\n        # 最坏情况也是 n ^ 2 ，因此面试或者竞赛不建议使用\n        def quickSort(head, end):\n     \n        if head != end:\n                pivot = partition(head, end)\n                quickSort(head, pivot)\n                quickSort(pivot.next, end)\n\n        def partition(head, end):\n            # p1是写指针，p2是读指针\n            # 最终 p1 是大的链表的头， head 是小的链表的头\n            pivot_val = head.val\n            p1, p2 = head, head.next\n\n            while p2 != end:\n                if p2.val < pivot_val:\n                    # 相当于数组的 append 方法\n                    p1 = p1.next\n                    p1.val, p2.val = p2.val, p1.val\n                p2 = p2.next\n            head.val, p1.val = p1.val, pivot_val\n            return p1\n\n        quickSort(head, None)\n        return head\n# 3. 插入排序\nclass Solution:\n    def sortList(self, head):\n        if head == None or head.next == None:\n            return head\n\n        dummy = ListNode(-1)\n        dummy.next = head\n        pre = dummy\n        cur = head\n        while cur:\n            # 准备将 last 插入到合适位置\n            last = cur.next\n            if last and last.val < cur.val:\n                # 从 dummy 到 cur 线性遍历找第一个满足条件的位置并插入\n                while pre.next and pre.next.val < last.val:\n                    pre = pre.next\n                tmp = pre.next\n                pre.next = last\n                cur.next = last.next  # 别忘了这个，否则成环\n                last.next = tmp\n                pre = dummy\n            else:\n                cur = last\n\n        return dummy.next\n# 4. 选择排序\nclass Solution:\n    def sortList(self, head):\n        temp = head\n\n        while temp:\n            min_node = temp\n            r = temp.next\n            while r:\n                if min_node.val > r.val:\n                    min_node = r\n                r = r.next\n            temp.val, min_node.val = min_node.val, temp.val\n            temp = temp.next\n        return head\n# 5. 冒泡排序\nclass Solution:\n    def sortList(self, head):\n        if not head:\n            return None\n        swaped = True\n        while swaped:\n            swaped = False\n            temp = head\n            while temp.next:\n                if temp.val > temp.next.val:\n                    swaped = True\n                    temp.val, temp.next.val = temp.next.val, temp.val\n                temp = temp.next\n        return head\n\n  `,\n        },\n      ],\n    },\n  ],\n  //   link: \"\",\n};\n","export const LEETCODE_CN_URL = \"https://leetcode-cn.com\";\nexport const LEETCODE_URL = \"https://leetcode.com\";\nexport const ISSUES_URL =\n  \"https://github.com/azl397985856/leetcode-cheat/issues\";\nexport const CONTRIBUTE_COMPANY_URL =\n  \"https://github.com/azl397985856/leetcode-cheat/issues/1\";\n\nexport const CONTRIBUTE_PROGRAMMING_LANGUAGE_URL =\n  \"https://github.com/azl397985856/leetcode-cheat/issues/4\";\n","module.exports = __webpack_public_path__ + \"static/media/backtrack.cf55209a.svg\";","module.exports = __webpack_public_path__ + \"static/media/heap.096d4381.svg\";","module.exports = __webpack_public_path__ + \"static/media/preSum.c46f4bab.svg\";","module.exports = __webpack_public_path__ + \"static/media/hand-writing.aed5b561.svg\";","module.exports = __webpack_public_path__ + \"static/media/index.4ba161fc.less\";","module.exports = __webpack_public_path__ + \"static/media/sqrt.3f15bd86.svg\";","module.exports = __webpack_public_path__ + \"static/media/sum.7d280127.svg\";","module.exports = __webpack_public_path__ + \"static/media/times.fe1a8c5f.svg\";","module.exports = __webpack_public_path__ + \"static/media/div.0b1cd4f2.svg\";","module.exports = __webpack_public_path__ + \"static/media/frac.8d2b75af.svg\";","module.exports = __webpack_public_path__ + \"static/media/approx.3bdc78a0.svg\";","module.exports = __webpack_public_path__ + \"static/media/sqrt.dee505bc.svg\";","module.exports = __webpack_public_path__ + \"static/media/choice.864f23d2.svg\";","\n/* eslint-disable */\n    export const db_collection = {\n       \"two-sum\":{\n    \"id\": \"1\",\n    \"name\": \"two-sum\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"求和转换为求差\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"借助Map结构将数组中每个元素及其索引相互对应\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"以空间换时间，将查找时间从O(N)降低到O(1)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"adobe\"\n        },\n        {\n            \"name\": \"airbnb\"\n        },\n        {\n            \"name\": \"amazon\"\n        },\n        {\n            \"name\": \"apple\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"dropbox\"\n        },\n        {\n            \"name\": \"facebook\"\n        },\n        {\n            \"name\": \"linkedin\"\n        },\n        {\n            \"name\": \"microsoft\"\n        },\n        {\n            \"name\": \"uber\"\n        },\n        {\n            \"name\": \"yahoo\"\n        },\n        {\n            \"name\": \"yelp\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1.two-sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1.two-sum.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number[]}\\n */\\nconst twoSum = function (nums, target) {\\n  const map = new Map();\\n  for (let i = 0; i < nums.length; i++) {\\n    const diff = target - nums[i];\\n    if (map.has(diff)) {\\n      return [map.get(diff), i];\\n    }\\n    map.set(nums[i], i);\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& A, int target) {\\n        unordered_map<int, int> m;\\n        for (int i = 0; i < A.size(); ++i) {\\n            int t = target - A[i];\\n            if (m.count(t)) return { m[t], i };\\n            m[A[i]] = i;\\n        }\\n        return {};\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"add-two-numbers\":{\n    \"id\": \"2\",\n    \"name\": \"add-two-numbers\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.链表这种数据结构的特点和使用2.用一个carried变量来实现进位的功能，每次相加之后计算carried，并用于下一位的计算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/2.add-two-numbers.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/2.add-two-numbers.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode cur = dummyHead;\\n        int carry = 0;\\n\\n        while(l1 != null || l2 != null)\\n        {\\n            int sum = carry;\\n            if(l1 != null)\\n            {\\n                sum += l1.val;\\n                l1 = l1.next;\\n            }\\n            if(l2 != null)\\n            {\\n                sum += l2.val;\\n                l2 = l2.next;\\n            }\\n            // 创建新节点\\n            carry = sum / 10;\\n            cur.next = new ListNode(sum % 10);\\n            cur = cur.next;\\n\\n        }\\n        if (carry > 0) {\\n            cur.next = new ListNode(carry);\\n        }\\n        return dummyHead.next;\\n    }\\n}\\n\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function (l1, l2) {\\n  if (l1 === null || l2 === null) return null;\\n\\n  // 使用dummyHead可以简化对链表的处理，dummyHead.next指向新链表\\n  let dummyHead = new ListNode(0);\\n  let cur1 = l1;\\n  let cur2 = l2;\\n  let cur = dummyHead; // cur用于计算新链表\\n  let carry = 0; // 进位标志\\n\\n  while (cur1 !== null || cur2 !== null) {\\n    let val1 = cur1 !== null ? cur1.val : 0;\\n    let val2 = cur2 !== null ? cur2.val : 0;\\n    let sum = val1 + val2 + carry;\\n    let newNode = new ListNode(sum % 10); // sum%10取模结果范围为0~9，即为当前节点的值\\n    carry = sum >= 10 ? 1 : 0; // sum>=10，carry=1，表示有进位\\n    cur.next = newNode;\\n    cur = cur.next;\\n\\n    if (cur1 !== null) {\\n      cur1 = cur1.next;\\n    }\\n\\n    if (cur2 !== null) {\\n      cur2 = cur2.next;\\n    }\\n  }\\n\\n  if (carry > 0) {\\n    // 如果最后还有进位，新加一个节点\\n    cur.next = new ListNode(carry);\\n  }\\n\\n  return dummyHead.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode* ret = nullptr;\\n        ListNode* cur = nullptr;\\n        int carry = 0;\\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\\n            carry += (l1 == nullptr ? 0 : l1->val) + (l2 == nullptr ? 0 : l2->val);\\n            auto temp = new ListNode(carry % 10);\\n            carry /= 10;\\n            if (ret == nullptr) {\\n                ret = temp;\\n                cur = ret;\\n            }\\n            else {\\n                cur->next = temp;\\n                cur = cur->next;\\n            }\\n            l1 = l1 == nullptr ? nullptr : l1->next;\\n            l2 = l2 == nullptr ? nullptr : l2->next;\\n        }\\n        return ret;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def addTwoNumbers(self, l1, l2):\\n        \\\"\\\"\\\"\\n        :type l1: ListNode\\n        :type l2: ListNode\\n        :rtype: ListNode\\n        \\\"\\\"\\\"\\n        res=ListNode(0)\\n        head=res\\n        carry=0\\n        while l1 or l2 or carry!=0:\\n            sum=carry\\n            if l1:\\n                sum+=l1.val\\n                l1=l1.next\\n            if l2:\\n                sum+=l2.val\\n                l2=l2.next\\n            # set value\\n            if sum<=9:\\n                res.val=sum\\n                carry=0\\n            else:\\n                res.val=sum%10\\n                carry=sum//10\\n            # creat new node\\n            if l1 or l2 or carry!=0:\\n                res.next=ListNode(0)\\n                res=res.next\\n        return head\\n\\n\"\n        }\n    ]\n},\n\"longest-substring-without-repeating-characters\":{\n    \"id\": \"3\",\n    \"name\": \"longest-substring-without-repeating-characters\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"mapper记录出现过并且没有被删除的字符\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"滑动窗口记录当前index开始的最大的不重复的字符序列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/3.longest-substring-without-repeating-characters.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/3.longest-substring-without-repeating-characters.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int lengthOfLongestSubstring(String s) {\\n        int ans = 0, start = 0;\\n        int n = s.length();\\n        //\\n        Map<Character, Integer> map = new HashMap<>();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            char alpha = s.charAt(i);\\n            if(map.containsKey(alpha))\\n            {\\n                start = Math.max(start, map.get(alpha)+1);\\n            }\\n            ans = Math.max(ans, i-start+1);\\n            // 字符位置\\n            map.put(alpha, i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n\\n        int ans = 0, start = 0;\\n        int n = s.length();\\n        //\\n        map<char, int> mp;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            char alpha = s[i];\\n            if(mp.count(alpha))\\n            {\\n                start = max(start, mp[alpha]+1);\\n            }\\n            ans = max(ans, i-start+1);\\n            // 字符位置\\n            mp[alpha] = i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def lengthOfLongestSubstring(self, s: str) -> int:\\n        l = 0\\n        ans = 0\\n        counter = defaultdict(lambda: 0)\\n\\n        for r in range(len(s)):\\n            while counter.get(s[r], 0) != 0:\\n                counter[s[l]] = counter.get(s[l], 0) - 1\\n                l += 1\\n            counter[s[r]] += 1\\n            ans = max(ans, r - l + 1)\\n\\n        return ans\\n\"\n        }\n    ]\n},\n\"median-of-two-sorted-arrays\":{\n    \"id\": \"4\",\n    \"name\": \"median-of-two-sorted-arrays\",\n    \"pre\": [\n        {\n            \"text\": \"中位数\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        },\n        {\n            \"text\": \"分治法\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        },\n        {\n            \"text\": \"二分查找\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"有序数组容易想到二分查找\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"对小的数组进行二分可降低时间复杂度\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"根据leftp1,rightp2,leftp2和rightp1的大小关系确定结束点和收缩方向\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/4.median-of-two-sorted-arrays.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/4.median-of-two-sorted-arrays.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MedianTwoSortedArrayBruteForce {\\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\\n      int[] newArr = mergeTwoSortedArray(nums1, nums2);\\n      int n = newArr.length;\\n      if (n % 2 == 0) {\\n        // even\\n        return (double) (newArr[n / 2] + newArr[n / 2 - 1]) / 2;\\n      } else {\\n        // odd\\n        return (double) newArr[n / 2];\\n      }\\n    }\\n    private int[] mergeTwoSortedArray(int[] nums1, int[] nums2) {\\n      int m = nums1.length;\\n      int n = nums2.length;\\n      int[] res = new int[m + n];\\n      int i = 0;\\n      int j = 0;\\n      int idx = 0;\\n      while (i < m && j < n) {\\n        if (nums1[i] <= nums2[j]) {\\n          res[idx++] = nums1[i++];\\n        } else {\\n          res[idx++] = nums2[j++];\\n        }\\n      }\\n      while (i < m) {\\n        res[idx++] = nums1[i++];\\n      }\\n      while (j < n) {\\n        res[idx++] = nums2[j++];\\n      }\\n      return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MedianSortedTwoArrayBinarySearch {\\n  public static double findMedianSortedArraysBinarySearch(int[] nums1, int[] nums2) {\\n     // do binary search for shorter length array, make sure time complexity log(min(m,n)).\\n     if (nums1.length > nums2.length) {\\n        return findMedianSortedArraysBinarySearch(nums2, nums1);\\n      }\\n      int m = nums1.length;\\n      int n = nums2.length;\\n      int lo = 0;\\n      int hi = m;\\n      while (lo <= hi) {\\n        // partition A position i\\n        int i = lo + (hi - lo) / 2;\\n        // partition B position j\\n        int j = (m + n + 1) / 2 - i;\\n\\n        int maxLeftA = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];\\n        int minRightA = i == m ? Integer.MAX_VALUE : nums1[i];\\n\\n        int maxLeftB = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];\\n        int minRightB = j == n ? Integer.MAX_VALUE : nums2[j];\\n\\n        if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\\n          // total length is even\\n          if ((m + n) % 2 == 0) {\\n            return (double) (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2;\\n          } else {\\n            // total length is odd\\n            return (double) Math.max(maxLeftA, maxLeftB);\\n          }\\n        } else if (maxLeftA > minRightB) {\\n          // binary search left half\\n          hi = i - 1;\\n        } else {\\n          // binary search right half\\n          lo = i + 1;\\n        }\\n      }\\n      return 0.0;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function (nums1, nums2) {\\n  // 归并排序\\n  const merged = [];\\n  let i = 0;\\n  let j = 0;\\n  while (i < nums1.length && j < nums2.length) {\\n    if (nums1[i] < nums2[j]) {\\n      merged.push(nums1[i++]);\\n    } else {\\n      merged.push(nums2[j++]);\\n    }\\n  }\\n  while (i < nums1.length) {\\n    merged.push(nums1[i++]);\\n  }\\n  while (j < nums2.length) {\\n    merged.push(nums2[j++]);\\n  }\\n\\n  const { length } = merged;\\n  return length % 2 === 1\\n    ? merged[Math.floor(length / 2)]\\n    : (merged[length / 2] + merged[length / 2 - 1]) / 2;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * 二分解法\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar findMedianSortedArrays = function (nums1, nums2) {\\n  // make sure to do binary search for shorten array\\n  if (nums1.length > nums2.length) {\\n    [nums1, nums2] = [nums2, nums1];\\n  }\\n  const m = nums1.length;\\n  const n = nums2.length;\\n  let low = 0;\\n  let high = m;\\n  while (low <= high) {\\n    const i = low + Math.floor((high - low) / 2);\\n    const j = Math.floor((m + n + 1) / 2) - i;\\n\\n    const maxLeftA = i === 0 ? -Infinity : nums1[i - 1];\\n    const minRightA = i === m ? Infinity : nums1[i];\\n    const maxLeftB = j === 0 ? -Infinity : nums2[j - 1];\\n    const minRightB = j === n ? Infinity : nums2[j];\\n\\n    if (maxLeftA <= minRightB && minRightA >= maxLeftB) {\\n      return (m + n) % 2 === 1\\n        ? Math.max(maxLeftA, maxLeftB)\\n        : (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB)) / 2;\\n    } else if (maxLeftA > minRightB) {\\n      high = i - 1;\\n    } else {\\n      low = low + 1;\\n    }\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        if (nums1.size() > nums2.size()) swap(nums1, nums2);\\n        int M = nums1.size(), N = nums2.size(), L = 0, R = M, K = (M + N + 1) / 2;\\n        while (true) {\\n            int i = (L + R) / 2, j = K - i;\\n            if (i < M && nums2[j - 1] > nums1[i]) L = i + 1;\\n            else if (i > L && nums1[i - 1] > nums2[j]) R = i - 1;\\n            else {\\n                int maxLeft = max(i ? nums1[i - 1] : INT_MIN, j ? nums2[j - 1] : INT_MIN);\\n                if ((M + N) % 2) return maxLeft;\\n                int minRight = min(i == M ? INT_MAX : nums1[i], j == N ? INT_MAX : nums2[j]);\\n                return (maxLeft + minRight) / 2.0;\\n            }\\n        }\\n    }\\n};\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nif leftp1 > rightp2:\\n    hi = mid1 - 1\\nelse:\\n    lo = mid1 + 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nif leftp2 > rightp1:\\n    hi = mid2 - 1\\nelse:\\n    lo = mid2 + 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        N = len(nums1)\\n        M = len(nums2)\\n        if N > M:\\n            return self.findMedianSortedArrays(nums2, nums1)\\n\\n        lo = 0\\n        hi = N\\n        combined = N + M\\n\\n        while lo <= hi:\\n            mid1 = lo + hi >> 1\\n            mid2 = ((combined + 1) >> 1) - mid1\\n\\n            leftp1 = -float(\\\"inf\\\") if mid1 == 0 else nums1[mid1 - 1]\\n            rightp1 = float(\\\"inf\\\") if mid1 == N else nums1[mid1]\\n\\n            leftp2 = -float(\\\"inf\\\") if mid2 == 0 else nums2[mid2 - 1]\\n            rightp2 = float(\\\"inf\\\") if mid2 == M else nums2[mid2]\\n\\n            # Check if the partition is valid for the case of\\n            if leftp1 <= rightp2 and leftp2 <= rightp1:\\n                if combined % 2 == 0:\\n                    return (max(leftp1, leftp2)+min(rightp1, rightp2)) / 2.0\\n\\n                return max(leftp1, leftp2)\\n            else:\\n                if leftp1 > rightp2:\\n                    hi = mid1 - 1\\n                else:\\n                    lo = mid1 + 1\\n        return -1\\n\"\n        }\n    ]\n},\n\"longest-palindromic-substring\":{\n    \"id\": \"5\",\n    \"name\": \"longest-palindromic-substring\",\n    \"pre\": [\n        {\n            \"text\": \"回文\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"”延伸“（extend）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/5.longest-palindromic-substring.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/5.longest-palindromic-substring.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nif (s[i] === s[j] && dp[i + 1][j - 1]) {\\n  dp[i][j] = true;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=5 lang=javascript\\n *\\n * [5] Longest Palindromic Substring\\n */\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function (s) {\\n  // babad\\n  // tag : dp\\n  if (!s || s.length === 0) return \\\"\\\";\\n  let res = s[0];\\n\\n  const dp = [];\\n\\n  // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]\\n  for (let i = s.length - 1; i >= 0; i--) {\\n    dp[i] = [];\\n    for (let j = i; j < s.length; j++) {\\n      if (j - i === 0) dp[i][j] = true;\\n      // specail case 1\\n      else if (j - i === 1 && s[i] === s[j]) dp[i][j] = true;\\n      // specail case 2\\n      else if (s[i] === s[j] && dp[i + 1][j - 1]) {\\n        // state transition\\n        dp[i][j] = true;\\n      }\\n\\n      if (dp[i][j] && j - i + 1 > res.length) {\\n        // update res\\n        res = s.slice(i, j + 1);\\n      }\\n    }\\n  }\\n\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n    int expand(string &s, int L, int R) {\\n        while (L >= 0 && R < s.size() && s[L] == s[R]) {\\n            --L;\\n            ++R;\\n        }\\n        return R - L - 1;\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        if (s.empty()) return s;\\n        int start = 0, maxLen = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            int len1 = expand(s, i, i);\\n            int len2 = expand(s, i, i + 1);\\n            int len = max(len1, len2);\\n            if (len > maxLen) {\\n                start = i - (len - 1) / 2;\\n                maxLen = len;\\n            }\\n        }\\n        return s.substr(start, maxLen);\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        if n == 0:\\n            return \\\"\\\"\\n        res = s[0]\\n        def extend(i, j, s):\\n            while(i >= 0 and j < len(s) and s[i] == s[j]):\\n                i -= 1\\n                j += 1\\n            return s[i + 1:j]\\n\\n        for i in range(n - 1):\\n            e1 = extend(i, i, s)\\n            e2 = extend(i, i + 1, s)\\n            if max(len(e1), len(e2)) > len(res):\\n                res = e1 if len(e1) > len(e2) else e2\\n        return res\\n\"\n        }\n    ]\n},\n\"container-with-most-water\":{\n    \"id\": \"11\",\n    \"name\": \"container-with-most-water\",\n    \"pre\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"双指针优化时间复杂度\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"阿里巴巴\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/11.container-with-most-water.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/11.container-with-most-water.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nlet max = 0;\\nfor (let i = 0; i < height.length; i++) {\\n  for (let j = i + 1; j < height.length; j++) {\\n    const currentArea = Math.abs(i - j) * Math.min(height[i], height[j]);\\n    if (currentArea > max) {\\n      max = currentArea;\\n    }\\n  }\\n}\\nreturn max;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar maxArea = function (height) {\\n  if (!height || height.length <= 1) return 0;\\n\\n  let leftPos = 0;\\n  let rightPos = height.length - 1;\\n  let max = 0;\\n  while (leftPos < rightPos) {\\n    const currentArea =\\n      Math.abs(leftPos - rightPos) *\\n      Math.min(height[leftPos], height[rightPos]);\\n    if (currentArea > max) {\\n      max = currentArea;\\n    }\\n    // 更新小的\\n    if (height[leftPos] < height[rightPos]) {\\n      leftPos++;\\n    } else {\\n      // 如果相等就随便了\\n      rightPos--;\\n    }\\n  }\\n\\n  return max;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxArea(self, heights):\\n        l, r =  0, len(heights) - 1\\n        ans = 0\\n        while l < r:\\n            ans = max(ans, (r - l) * min(heights[l], heights[r]))\\n            if heights[r] > heights[l]:\\n                l += 1\\n            else:\\n                r -= 1\\n        return ans\\n\"\n        }\n    ]\n},\n\"3sum\":{\n    \"id\": \"15\",\n    \"name\": \"3sum\",\n    \"pre\": [\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"排序之后，用双指针\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/15.3sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/15.3sum.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar threeSum = function (nums) {\\n  if (nums.length < 3) return [];\\n  const list = [];\\n  nums.sort((a, b) => a - b);\\n  for (let i = 0; i < nums.length; i++) {\\n    //nums is sorted,so it's impossible to have a sum = 0\\n    if (nums[i] > 0) break;\\n    // skip duplicated result without set\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    // for each index i\\n    // we want to find the triplet [i, left, right] which sum to 0\\n    while (left < right) {\\n      // since left < right, and left > i, no need to compare i === left and i === right.\\n      if (nums[left] + nums[right] + nums[i] === 0) {\\n        list.push([nums[left], nums[right], nums[i]]);\\n        // skip duplicated result without set\\n        while (nums[left] === nums[left + 1]) {\\n          left++;\\n        }\\n        left++;\\n        // skip duplicated result without set\\n        while (nums[right] === nums[right - 1]) {\\n          right--;\\n        }\\n        right--;\\n        continue;\\n      } else if (nums[left] + nums[right] + nums[i] > 0) {\\n        right--;\\n      } else {\\n        left++;\\n      }\\n    }\\n  }\\n  return list;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& A) {\\n        sort(begin(A), end(A));\\n        vector<vector<int>> ans;\\n        int N = A.size();\\n        for (int i = 0; i < N - 2; ++i) {\\n            if (i && A[i] == A[i - 1]) continue;\\n            int L = i + 1, R = N - 1;\\n            while (L < R) {\\n                int sum = A[i] + A[L] + A[R];\\n                if (sum == 0) ans.push_back({ A[i], A[L], A[R] });\\n                if (sum >= 0) {\\n                    --R;\\n                    while (L < R && A[R] == A[R + 1]) --R;\\n                }\\n                if (sum <= 0) {\\n                    ++L;\\n                    while (L < R && A[L] == A[L - 1]) ++L;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\"\n        }\n    ]\n},\n\"Letter-Combinations-of-a-Phone-Number\":{\n    \"id\": \"17\",\n    \"name\": \"Letter-Combinations-of-a-Phone-Number\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"笛卡尔积\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"回溯模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/17.Letter-Combinations-of-a-Phone-Number.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/17.Letter-Combinations-of-a-Phone-Number.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n\\n    private String letterMap[] = {\\n            \\\" \\\",    //0\\n            \\\"\\\",     //1\\n            \\\"abc\\\",  //2\\n            \\\"def\\\",  //3\\n            \\\"ghi\\\",  //4\\n            \\\"jkl\\\",  //5\\n            \\\"mno\\\",  //6\\n            \\\"pqrs\\\", //7\\n            \\\"tuv\\\",  //8\\n            \\\"wxyz\\\"  //9\\n    };\\n    private ArrayList<String> res;\\n    public List<String> letterCombinations(String digits) {\\n        res = new ArrayList<String>();\\n        if(digits.equals(\\\"\\\"))\\n        {\\n            return res;\\n        }\\n        dfs(digits, 0, \\\"\\\");\\n        return res;\\n    }\\n\\n    public void dfs(String digits, int index, String s)\\n    {\\n        if(index == digits.length())\\n        {\\n            res.add(s);\\n            return;\\n        }\\n        // 获取当前数字\\n        Character c = digits.charAt(index);\\n        // 获取数字对应字母\\n        String letters = letterMap[c-'0'];\\n        for(int i = 0 ; i < letters.length() ; i ++)\\n        {\\n            dfs(digits, index+1, s+letters.charAt(i));\\n        }\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {string} digits\\n * @return {string[]}\\n */\\nconst letterCombinations = function (digits) {\\n  if (!digits) {\\n    return [];\\n  }\\n  const len = digits.length;\\n  const map = new Map();\\n  map.set(\\\"2\\\", \\\"abc\\\");\\n  map.set(\\\"3\\\", \\\"def\\\");\\n  map.set(\\\"4\\\", \\\"ghi\\\");\\n  map.set(\\\"5\\\", \\\"jkl\\\");\\n  map.set(\\\"6\\\", \\\"mno\\\");\\n  map.set(\\\"7\\\", \\\"pqrs\\\");\\n  map.set(\\\"8\\\", \\\"tuv\\\");\\n  map.set(\\\"9\\\", \\\"wxyz\\\");\\n  const result = [];\\n\\n  function generate(i, str) {\\n    if (i == len) {\\n      result.push(str);\\n      return;\\n    }\\n    const tmp = map.get(digits[i]);\\n    for (let r = 0; r < tmp.length; r++) {\\n      generate(i + 1, str + tmp[r]);\\n    }\\n  }\\n  generate(0, \\\"\\\");\\n  return result;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    string letterMap[10] = {\\\" \\\",\\\" \\\",\\\"abc\\\",\\\"def\\\",\\\"ghi\\\",\\\"jkl\\\",\\\"mno\\\",\\\"pqrs\\\",\\\"tuv\\\",\\\"wxyz\\\"};\\n    vector<string> res;\\n    vector<string> letterCombinations(string digits) {\\n        if(digits == \\\"\\\")\\n        {\\n            return res;\\n        }\\n        dfs(digits, 0, \\\"\\\");\\n        return res;\\n    }\\n\\n    void dfs(string digits, int index, string s)\\n    {\\n        if(index == digits.length())\\n        {\\n            res.push_back(s);\\n            return;\\n        }\\n        // 获取当前数字\\n        char c = digits[index];\\n        // 获取数字对应字母\\n        string letters = letterMap[c-'0'];\\n        for(int i = 0 ; i < letters.length() ; i ++)\\n        {\\n            dfs(digits, index+1, s+letters[i]);\\n        }\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def letterCombinations(self, digits):\\n        \\\"\\\"\\\"\\n        :type digits: str\\n        :rtype: List[str]\\n        \\\"\\\"\\\"\\n        if not digits:\\n            return []\\n        # 0-9\\n        self.d = [\\\" \\\",\\\" \\\",\\\"abc\\\",\\\"def\\\",\\\"ghi\\\",\\\"jkl\\\",\\\"mno\\\",\\\"pqrs\\\",\\\"tuv\\\",\\\"wxyz\\\"]\\n        self.res = []\\n        self.dfs(digits, 0, \\\"\\\")\\n        return self.res\\n\\n    def dfs(self, digits, index, s):\\n        # 递归的终止条件,用index记录每次遍历到字符串的位置\\n        if index == len(digits):\\n            self.res.append(s)\\n            return\\n        # 获取当前数字\\n        c = digits[index]\\n        # print(c, int(c))\\n        # 获取数字对应字母\\n        letters = self.d[int(c)]\\n        # 遍历字符串\\n        for l in letters:\\n            # 调用下一层\\n            self.dfs(digits, index+1, s+l)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n# 输入：\\\"23\\\"\\n# 输出：[\\\"ad\\\", \\\"ae\\\", \\\"af\\\", \\\"bd\\\", \\\"be\\\", \\\"bf\\\", \\\"cd\\\", \\\"ce\\\", \\\"cf\\\"].\\nclass Solution:\\n    def letterCombinations(self, digits: str) -> List[str]:\\n        mapper = [\\\" \\\", \\\" \\\", \\\"abc\\\", \\\"def\\\", \\\"ghi\\\",\\n                  \\\"jkl\\\", \\\"mno\\\", \\\"pqrs\\\", \\\"tuv\\\", \\\"wxyz\\\"]\\n\\t\\t    @lru_cache(None)\\n        def backtrack(digits, start):\\n            if start >= len(digits):\\n                return ['']\\n            ans = []\\n            for i in range(start, len(digits)):\\n                for c in mapper[int(digits[i])]:\\n                    # 笛卡尔积\\n                    for p in backtrack(digits, i + 1):\\n                        # 需要过滤诸如  \\\"d\\\", \\\"e\\\", \\\"f\\\" 等长度不符合的数据\\n                        if start == 0:\\n                            if len(c + p) == len(digits):\\n                                ans.append(c + p)\\n                        else:\\n                            ans.append(c + p)\\n            return ans\\n        if not digits:\\n            return []\\n        return backtrack(digits, 0)\\n\\n\"\n        }\n    ]\n},\n\"removeNthNodeFromEndofList\":{\n    \"id\": \"19\",\n    \"name\": \"removeNthNodeFromEndofList\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.链表这种数据结构的特点和使用2.使用双指针3.使用一个dummyHead简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/19.removeNthNodeFromEndofList.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/19.removeNthNodeFromEndofList.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n        TreeNode dummy = new TreeNode(0);\\n        dummy.next = head;\\n        TreeNode first = dummy;\\n        TreeNode second = dummy;\\n\\n        if (int i=0; i<=n; i++) {\\n            first = first.next;\\n        }\\n\\n        while (first != null) {\\n            first = first.next;\\n            second = second.next;\\n        }\\n\\n        second.next = second.next.next;\\n\\n        return dummy.next;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {ListNode} head\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar removeNthFromEnd = function (head, n) {\\n  let i = -1;\\n  const noop = {\\n    next: null,\\n  };\\n\\n  const dummyHead = new ListNode(); // 增加一个dummyHead 简化操作\\n  dummyHead.next = head;\\n\\n  let currentP1 = dummyHead;\\n  let currentP2 = dummyHead;\\n\\n  while (currentP1) {\\n    if (i === n) {\\n      currentP2 = currentP2.next;\\n    }\\n\\n    if (i !== n) {\\n      i++;\\n    }\\n\\n    currentP1 = currentP1.next;\\n  }\\n\\n  currentP2.next = ((currentP2 || noop).next || noop).next;\\n\\n  return dummyHead.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode *p = head, *q = head;\\n        while (n--) q = q->next;\\n        if (!q) {\\n            head = head->next;\\n            delete p;\\n            return head;\\n        }\\n        while (q->next) p = p->next, q = q->next;\\n        q = p->next;\\n        p->next = q->next;\\n        delete q;\\n        return head;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"valid-parentheses\":{\n    \"id\": \"20\",\n    \"name\": \"valid-parentheses\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.栈的基本特点和操作2.如果你用的是JS没有现成的栈，可以用数组来模拟。比如入：push出：pop就是栈。入：push出shift就是队列。但是这种算法实现的队列在头部删除元素的时候时间复杂度比较高，具体大家可以参考一下[双端队列deque](https://zh.wikipedia.org/wiki/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97)。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"airbnb\"\n        },\n        {\n            \"name\": \"amazon\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"facebook\"\n        },\n        {\n            \"name\": \"google\"\n        },\n        {\n            \"name\": \"microsoft\"\n        },\n        {\n            \"name\": \"twitter\"\n        },\n        {\n            \"name\": \"zenefits\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/20.valid-parentheses.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/20.valid-parentheses.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isValid = function (s) {\\n  let valid = true;\\n  const stack = [];\\n  const mapper = {\\n    \\\"{\\\": \\\"}\\\",\\n    \\\"[\\\": \\\"]\\\",\\n    \\\"(\\\": \\\")\\\",\\n  };\\n\\n  for (let i in s) {\\n    const v = s[i];\\n    if ([\\\"(\\\", \\\"[\\\", \\\"{\\\"].indexOf(v) > -1) {\\n      stack.push(v);\\n    } else {\\n      const peak = stack.pop();\\n      if (v !== mapper[peak]) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  if (stack.length > 0) return false;\\n\\n  return valid;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar isValid = function (s) {\\n  while (s.includes(\\\"[]\\\") || s.includes(\\\"()\\\") || s.includes(\\\"{}\\\")) {\\n    s = s.replace(\\\"[]\\\", \\\"\\\").replace(\\\"()\\\", \\\"\\\").replace(\\\"{}\\\", \\\"\\\");\\n  }\\n  s = s.replace(\\\"[]\\\", \\\"\\\").replace(\\\"()\\\", \\\"\\\").replace(\\\"{}\\\", \\\"\\\");\\n  return s.length === 0;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int top = -1;\\n        for(int i =0;i<s.length();++i){\\n            if(top<0 || !isMatch(s[top], s[i])){\\n                ++top;\\n                s[top] = s[i];\\n            }else{\\n                --top;\\n            }\\n        }\\n        return top == -1;\\n    }\\n    bool isMatch(char c1, char c2){\\n        if(c1 == '(' && c2 == ')') return true;\\n        if(c1 == '[' && c2 == ']') return true;\\n        if(c1 == '{' && c2 == '}') return true;\\n        return false;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n    class Solution:\\n        def isValid(self,s):\\n          stack = []\\n          map = {\\n            \\\"{\\\":\\\"}\\\",\\n            \\\"[\\\":\\\"]\\\",\\n            \\\"(\\\":\\\")\\\"\\n          }\\n          for x in s:\\n            if x in map:\\n              stack.append(map[x])\\n            else:\\n              if len(stack)!=0:\\n                top_element = stack.pop()\\n                if x != top_element:\\n                  return False\\n                else:\\n                  continue\\n              else:\\n                return False\\n          return len(stack) == 0\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n     def isValid(self, s):\\n\\n        while '[]' in s or '()' in s or '{}' in s:\\n            s = s.replace('[]','').replace('()','').replace('{}','')\\n        return not len(s)\\n\"\n        }\n    ]\n},\n\"merge-two-sorted-lists\":{\n    \"id\": \"21\",\n    \"name\": \"merge-two-sorted-lists\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"链表\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"掌握链表数据结构\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"考虑边界情况\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"amazon\"\n        },\n        {\n            \"name\": \"apple\"\n        },\n        {\n            \"name\": \"linkedin\"\n        },\n        {\n            \"name\": \"microsoft\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/21.merge-two-sorted-lists.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/21.merge-two-sorted-lists.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nconst mergeTwoLists = function (l1, l2) {\\n  if (l1 === null) {\\n    return l2;\\n  }\\n  if (l2 === null) {\\n    return l1;\\n  }\\n  if (l1.val < l2.val) {\\n    l1.next = mergeTwoLists(l1.next, l2);\\n    return l1;\\n  } else {\\n    l2.next = mergeTwoLists(l1, l2.next);\\n    return l2;\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* a, ListNode* b) {\\n        ListNode head, *tail = &head;\\n        while (a && b) {\\n            if (a->val <= b->val) {\\n                tail->next = a;\\n                a = a->next;\\n            } else {\\n                tail->next = b;\\n                b = b->next;\\n            }\\n            tail = tail->next;\\n        }\\n        tail->next = a ? a : b;\\n        return head.next;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"generate-parentheses\":{\n    \"id\": \"22\",\n    \"name\": \"generate-parentheses\",\n    \"pre\": [\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"当l<r时记得剪枝\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/22.generate-parentheses.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/22.generate-parentheses.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number} n\\n * @return {string[]}\\n * @param l 左括号已经用了几个\\n * @param r 右括号已经用了几个\\n * @param str 当前递归得到的拼接字符串结果\\n * @param res 结果集\\n */\\nconst generateParenthesis = function (n) {\\n  const res = [];\\n\\n  function dfs(l, r, str) {\\n    if (l == n && r == n) {\\n      return res.push(str);\\n    }\\n    // l 小于 r 时不满足条件 剪枝\\n    if (l < r) {\\n      return;\\n    }\\n    // l 小于 n 时可以插入左括号，最多可以插入 n 个\\n    if (l < n) {\\n      dfs(l + 1, r, str + \\\"(\\\");\\n    }\\n    // r < l 时 可以插入右括号\\n    if (r < l) {\\n      dfs(l, r + 1, str + \\\")\\\");\\n    }\\n  }\\n  dfs(0, 0, \\\"\\\");\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\ns.push_back(')');\\ndfs(l, r + 1, s);\\ns.pop_back();\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n    vector<string> ans;\\n    void generate(int leftCnt, int rightCnt, string &s) {\\n        if (!leftCnt && !rightCnt) {\\n            ans.push_back(s);\\n            return;\\n        }\\n        if (leftCnt) {\\n            s.push_back('(');\\n            generate(leftCnt - 1, rightCnt, s);\\n            s.pop_back();\\n        }\\n        if (rightCnt > leftCnt) {\\n            s.push_back(')');\\n            generate(leftCnt, rightCnt - 1, s);\\n            s.pop_back();\\n        }\\n    }\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        string s;\\n        generate(n, n, s);\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nres = []\\ndef dfs(l, r, s):\\n   if l > n or r > n: return\\n   if (l == r == n): res.append(s)\\n   # 剪枝，提高算法效率\\n   if l > r: return\\n   # 加一个左括号\\n   dfs(l + 1, r, s + '(')\\n   # 加一个右括号\\n   dfs(l, r + 1, s + ')')\\ndfs(0, 0, '')\\nreturn res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def generateParenthesis(self, n: int) -> List[str]:\\n        res = []\\n        def dfs(l, r, s):\\n            if l > n or r > n: return\\n            if (l == r == n): res.append(s)\\n            if l < r: return\\n            # 加一个左括号\\n            dfs(l + 1, r, s + '(')\\n            # 加一个右括号\\n            dfs(l, r + 1, s + ')')\\n        dfs(0, 0, '')\\n        return res\\n\"\n        }\n    ]\n},\n\"merge-k-sorted-lists\":{\n    \"id\": \"23\",\n    \"name\": \"merge-k-sorted-lists\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"归并排序\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"归并排序(mergesort)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/23.merge-k-sorted-lists.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/23.merge-k-sorted-lists.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=23 lang=javascript\\n *\\n * [23] Merge k Sorted Lists\\n *\\n * https://leetcode.com/problems/merge-k-sorted-lists/description/\\n *\\n */\\nfunction mergeTwoLists(l1, l2) {\\n  const dummyHead = {};\\n  let current = dummyHead;\\n  // l1: 1 -> 3 -> 5\\n  // l2: 2 -> 4 -> 6\\n  while (l1 !== null && l2 !== null) {\\n    if (l1.val < l2.val) {\\n      current.next = l1; // 把小的添加到结果链表\\n      current = current.next; // 移动结果链表的指针\\n      l1 = l1.next; // 移动小的那个链表的指针\\n    } else {\\n      current.next = l2;\\n      current = current.next;\\n      l2 = l2.next;\\n    }\\n  }\\n\\n  if (l1 === null) {\\n    current.next = l2;\\n  } else {\\n    current.next = l1;\\n  }\\n  return dummyHead.next;\\n}\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists = function (lists) {\\n  // 图参考： https://zhuanlan.zhihu.com/p/61796021\\n  if (lists.length === 0) return null;\\n  if (lists.length === 1) return lists[0];\\n  if (lists.length === 2) {\\n    return mergeTwoLists(lists[0], lists[1]);\\n  }\\n\\n  const mid = lists.length >> 1;\\n  const l1 = [];\\n  for (let i = 0; i < mid; i++) {\\n    l1[i] = lists[i];\\n  }\\n\\n  const l2 = [];\\n  for (let i = mid, j = 0; i < lists.length; i++, j++) {\\n    l2[j] = lists[i];\\n  }\\n\\n  return mergeTwoLists(mergeKLists(l1), mergeKLists(l2));\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n    ListNode* mergeTwoLists(ListNode* a, ListNode* b) {\\n        ListNode head(0), *tail = &head;\\n        while (a && b) {\\n            if (a->val < b->val) { tail->next = a; a = a->next; }\\n            else { tail->next = b; b = b->next; }\\n            tail = tail->next;\\n        }\\n        tail->next = a ? a : b;\\n        return head.next;\\n    }\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) return NULL;\\n        for (int N = lists.size(); N > 1; N = (N + 1) / 2) {\\n            for (int i = 0; i < N / 2; ++i) {\\n                lists[i] = mergeTwoLists(lists[i], lists[N - 1 - i]);\\n            }\\n        }\\n        return lists[0];\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        n = len(lists)\\n\\n        # basic cases\\n        if lenth == 0: return None\\n        if lenth == 1: return lists[0]\\n        if lenth == 2: return self.mergeTwoLists(lists[0], lists[1])\\n\\n        # divide and conqure if not basic cases\\n        mid = n // 2\\n        return self.mergeTwoLists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:n]))\\n\\n\\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        res = ListNode(0)\\n        c1, c2, c3 = l1, l2, res\\n        while c1 or c2:\\n            if c1 and c2:\\n                if c1.val < c2.val:\\n                    c3.next = ListNode(c1.val)\\n                    c1 = c1.next\\n                else:\\n                    c3.next = ListNode(c2.val)\\n                    c2 = c2.next\\n                c3 = c3.next\\n            elif c1:\\n                c3.next = c1\\n                break\\n            else:\\n                c3.next = c2\\n                break\\n\\n        return res.next\\n\"\n        }\n    ]\n},\n\"swapNodesInPairs\":{\n    \"id\": \"24\",\n    \"name\": \"swapNodesInPairs\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.链表这种数据结构的特点和使用2.dummyHead简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/24.swapNodesInPairs.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/24.swapNodesInPairs.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n  const dummy = new ListNode(0);\\n  dummy.next = head;\\n  let current = dummy;\\n  while (current.next != null && current.next.next != null) {\\n    // 初始化双指针\\n    const first = current.next;\\n    const second = current.next.next;\\n\\n    // 更新双指针和 current 指针\\n    first.next = second.next;\\n    second.next = first;\\n    current.next = second;\\n\\n    // 更新指针\\n    current = current.next.next;\\n  }\\n  return dummy.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode h, *tail = &h;\\n        while (head && head->next) {\\n            auto p = head, q = head->next;\\n            head = q->next;\\n            q->next = p;\\n            tail->next = q;\\n            tail = p;\\n        }\\n        tail->next = head;\\n        return h.next;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\\"\\\"\\\"\\n        用递归实现链表相邻互换：\\n        第一个节点的 next 是第三、第四个节点交换的结果，第二个节点的 next 是第一个节点；\\n        第三个节点的 next 是第五、第六个节点交换的结果，第四个节点的 next 是第三个节点；\\n        以此类推\\n        :param ListNode head\\n        :return ListNode\\n        \\\"\\\"\\\"\\n        # 如果为 None 或 next 为 None，则直接返回\\n        if not head or not head.next:\\n            return head\\n\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        return _next\\n\"\n        }\n    ]\n},\n\"reverse-nodes-in-k-groups-cn\":{\n    \"id\": \"25\",\n    \"name\": \"reverse-nodes-in-k-groups-cn\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析1.创建一个dummynode2.对链表以k为单位进行分组，记录每一组的起始和最后节点位置3.对每一组进行翻转，更换起始和最后的位置4.返回`dummy.next`.\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/25.reverse-nodes-in-k-groups-cn.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/25.reverse-nodes-in-k-groups-cn.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass ReverseKGroupsLinkedList {\\n  public ListNode reverseKGroup(ListNode head, int k) {\\n      if (head == null || k == 1) {\\n        return head;\\n      }\\n      ListNode dummy = new ListNode(0);\\n      dummy.next = head;\\n\\n      ListNode start = dummy;\\n      ListNode end = head;\\n      int count = 0;\\n      while (end != null) {\\n        count++;\\n        // group\\n        if (count % k == 0) {\\n          // reverse linked list (start, end]\\n          start = reverse(start, end.next);\\n          end = start.next;\\n        } else {\\n          end = end.next;\\n        }\\n      }\\n      return dummy.next;\\n    }\\n\\n    /**\\n     * reverse linked list from range (start, end), return last node.\\n     * for example:\\n     * 0->1->2->3->4->5->6->7->8\\n     * |           |\\n     * start       end\\n     *\\n     * After call start = reverse(start, end)\\n     *\\n     * 0->3->2->1->4->5->6->7->8\\n     *          |  |\\n     *       start end\\n     *       first\\n     *\\n     */\\n    private ListNode reverse(ListNode start, ListNode end) {\\n      ListNode curr = start.next;\\n      ListNode prev = start;\\n      ListNode first = curr;\\n      while (curr != end){\\n        ListNode temp = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = temp;\\n      }\\n      start.next = prev;\\n      first.next = curr;\\n      return first;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar reverseKGroup = function (head, k) {\\n  // 标兵\\n  let dummy = new ListNode();\\n  dummy.next = head;\\n  let [start, end] = [dummy, dummy.next];\\n  let count = 0;\\n  while (end) {\\n    count++;\\n    if (count % k === 0) {\\n      start = reverseList(start, end.next);\\n      end = start.next;\\n    } else {\\n      end = end.next;\\n    }\\n  }\\n  return dummy.next;\\n\\n  // 翻转stat -> end的链表\\n  function reverseList(start, end) {\\n    let [pre, cur] = [start, start.next];\\n    const first = cur;\\n    while (cur !== end) {\\n      let next = cur.next;\\n      cur.next = pre;\\n      pre = cur;\\n      cur = next;\\n    }\\n    start.next = pre;\\n    first.next = cur;\\n    return first;\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        if head is None or k < 2:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        start = dummy\\n        end = head\\n        count = 0\\n        while end:\\n            count += 1\\n            if count % k == 0:\\n                start = self.reverse(start, end.next)\\n                # end 调到下一个\\n                end = start.next\\n            else:\\n                end = end.next\\n        return dummy.next\\n    # (start, end） 左右都开放\\n\\n    def reverse(self, start, end):\\n        prev, curr = start, start.next\\n        first = curr\\n        # 反转\\n        while curr != end:\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n        # 将反转后的链表添加到原链表中\\n        start.next = prev\\n        first.next = end\\n        # 返回反转前的头， 也就是反转后的尾部\\n        return first\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        if head is None or k < 2:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        pre = dummy\\n        cur = head\\n        count = 0\\n        while cur:\\n            count += 1\\n            if count % k == 0:\\n                pre = self.reverse(pre, cur.next)\\n                # end 调到下一个位置\\n                cur = pre.next\\n            else:\\n                cur = cur.next\\n        return dummy.next\\n    # (p1, p4） 左右都开放\\n\\n    def reverse(self, p1, p4):\\n        prev, curr = p1, p1.next\\n        p2 = curr\\n        # 反转\\n        while curr != p4:\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n        # 将反转后的链表添加到原链表中\\n        # prev 相当于 p3\\n        p1.next = prev\\n        p2.next = p4\\n        # 返回反转前的头， 也就是反转后的尾部\\n        return p2\\n\\n# @lc code=end\\n\\n\"\n        }\n    ]\n},\n\"reverse-nodes-in-k-groups\":{\n    \"id\": \"25\",\n    \"name\": \"reverse-nodes-in-k-groups\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析1.创建一个dummynode2.对链表以k为单位进行分组，记录每一组的起始和最后节点位置3.对每一组进行翻转，更换起始和最后的位置4.返回`dummy.next`.\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/25.reverse-nodes-in-k-groups.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/25.reverse-nodes-in-k-groups.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass ReverseKGroupsLinkedList {\\n  public ListNode reverseKGroup(ListNode head, int k) {\\n      if (head == null || k == 1) {\\n        return head;\\n      }\\n      ListNode dummy = new ListNode(0);\\n      dummy.next = head;\\n\\n      ListNode start = dummy;\\n      ListNode end = head;\\n      int count = 0;\\n      while (end != null) {\\n        count++;\\n        // group\\n        if (count % k == 0) {\\n          // reverse linked list (start, end]\\n          start = reverse(start, end.next);\\n          end = start.next;\\n        } else {\\n          end = end.next;\\n        }\\n      }\\n      return dummy.next;\\n    }\\n\\n    /**\\n     * reverse linked list from range (start, end), return last node.\\n     * for example:\\n     * 0->1->2->3->4->5->6->7->8\\n     * |           |\\n     * start       end\\n     *\\n     * After call start = reverse(start, end)\\n     *\\n     * 0->3->2->1->4->5->6->7->8\\n     *          |  |\\n     *       start end\\n     *       first\\n     *\\n     */\\n    private ListNode reverse(ListNode start, ListNode end) {\\n      ListNode curr = start.next;\\n      ListNode prev = start;\\n      ListNode first = curr;\\n      while (curr != end){\\n        ListNode temp = curr.next;\\n        curr.next = prev;\\n        prev = curr;\\n        curr = temp;\\n      }\\n      start.next = prev;\\n      first.next = curr;\\n      return first;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {ListNode} head\\n * @param {number} k\\n * @return {ListNode}\\n */\\nvar reverseKGroup = function (head, k) {\\n  // 标兵\\n  let dummy = new ListNode();\\n  dummy.next = head;\\n  let [start, end] = [dummy, dummy.next];\\n  let count = 0;\\n  while (end) {\\n    count++;\\n    if (count % k === 0) {\\n      start = reverseList(start, end.next);\\n      end = start.next;\\n    } else {\\n      end = end.next;\\n    }\\n  }\\n  return dummy.next;\\n\\n  // 翻转stat -> end的链表\\n  function reverseList(start, end) {\\n    let [pre, cur] = [start, start.next];\\n    const first = cur;\\n    while (cur !== end) {\\n      let next = cur.next;\\n      cur.next = pre;\\n      pre = cur;\\n      cur = next;\\n    }\\n    start.next = pre;\\n    first.next = cur;\\n    return first;\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    # 翻转一个子链表，并且返回新的头与尾\\n    def reverse(self, head: ListNode, tail: ListNode, terminal):\\n        cur = head\\n        pre = None\\n        while cur != terminal:\\n            next = cur.next\\n            cur.next = pre\\n\\n            pre = cur\\n            cur = next\\n        return tail, head\\n\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        ans = ListNode()\\n        ans.next = head\\n        pre = ans\\n\\n        while head:\\n            tail = pre\\n            # 查看剩余部分长度是否大于等于 k\\n            for i in range(k):\\n                tail = tail.next\\n                if not tail:\\n                    return ans.next\\n            next = tail.next\\n            head, tail = self.reverse(head, tail, tail.next)\\n            # 把子链表重新接回原链表\\n            pre.next = head\\n            tail.next = next\\n            pre = tail\\n            head = next\\n\\n        return ans.next\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\\n        if head is None or k < 2:\\n            return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        pre = dummy\\n        cur = head\\n        count = 0\\n        while cur:\\n            count += 1\\n            if count % k == 0:\\n                pre = self.reverse(pre, cur.next)\\n                # end 调到下一个位置\\n                cur = pre.next\\n            else:\\n                cur = cur.next\\n        return dummy.next\\n    # (p1, p4） 左右都开放\\n\\n    def reverse(self, p1, p4):\\n        prev, curr = p1, p1.next\\n        p2 = curr\\n        # 反转\\n        while curr != p4:\\n            next = curr.next\\n            curr.next = prev\\n            prev = curr\\n            curr = next\\n        # 将反转后的链表添加到原链表中\\n        # prev 相当于 p3\\n        p1.next = prev\\n        p2.next = p4\\n        # 返回反转前的头， 也就是反转后的尾部\\n        return p2\\n\\n# @lc code=end\\n\\n\"\n        }\n    ]\n},\n\"remove-duplicates-from-sorted-array\":{\n    \"id\": \"26\",\n    \"name\": \"remove-duplicates-from-sorted-array\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"双指针这道题如果不要求，O(n)的时间复杂度，O(1)的空间复杂度的话，会很简单。但是这道题是要求的，这种题的思路一般都是采用双指针\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果是数据是无序的，就不可以用这种方式了，从这里也可以看出排序在算法中的基础性和重要性。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"注意nums为空时的边界条件。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"facebook\"\n        },\n        {\n            \"name\": \"microsoft\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/26.remove-duplicates-from-sorted-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/26.remove-duplicates-from-sorted-array.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar removeDuplicates = function (nums) {\\n  const size = nums.length;\\n  if (size == 0) return 0;\\n  let slowP = 0;\\n  for (let fastP = 0; fastP < size; fastP++) {\\n    if (nums[fastP] !== nums[slowP]) {\\n      slowP++;\\n      nums[slowP] = nums[fastP];\\n    }\\n  }\\n  return slowP + 1;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& nums) {\\n        if(nums.empty()) return 0;\\n        int fast,slow;\\n        fast=slow=0;\\n        while(fast!=nums.size()){\\n            if(nums[fast]==nums[slow]) fast++;\\n            else {\\n                slow++;\\n                nums[slow]=nums[fast];\\n                fast++;\\n            }\\n        }\\n        return slow+1;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if nums:\\n            slow = 0\\n            for fast in range(1, len(nums)):\\n                if nums[fast] != nums[slow]:\\n                    slow += 1\\n                    nums[slow] = nums[fast]\\n            return slow + 1\\n        else:\\n            return 0\\n\"\n        }\n    ]\n},\n\"divide-two-integers\":{\n    \"id\": \"29\",\n    \"name\": \"divide-two-integers\",\n    \"pre\": [\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"[二分查找](../91/binary\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"search.md)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"正负数的判断中，这样判断更简单。```jsconstisNegative=dividend>0!==divisor>0;```或者利用异或：```jsconstisNegative=dividend^(divisor<0);```\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"Facebook\"\n        },\n        {\n            \"name\": \"Microsoft\"\n        },\n        {\n            \"name\": \"Oracle\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/29.divide-two-integers.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/29.divide-two-integers.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nlet acc = divisor;\\nlet count = 0;\\n\\nwhile (dividend - acc >= 0) {\\n  acc += divisor;\\n  count++;\\n}\\n\\nreturn count;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nconst isNegative = dividend > 0 !== divisor > 0;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nconst isNegative = dividend ^ (divisor < 0);\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=29 lang=javascript\\n *\\n * [29] Divide Two Integers\\n */\\n/**\\n * @param {number} dividend\\n * @param {number} divisor\\n * @return {number}\\n */\\nvar divide = function (dividend, divisor) {\\n  if (divisor === 1) return dividend;\\n\\n  // 这种方法很巧妙，即符号相同则为正，不同则为负\\n  const isNegative = dividend > 0 !== divisor > 0;\\n\\n  const MAX_INTERGER = Math.pow(2, 31);\\n\\n  const res = helper(Math.abs(dividend), Math.abs(divisor));\\n\\n  // overflow\\n  if (res > MAX_INTERGER - 1 || res < -1 * MAX_INTERGER) {\\n    return MAX_INTERGER - 1;\\n  }\\n\\n  return isNegative ? -1 * res : res;\\n};\\n\\nfunction helper(dividend, divisor) {\\n  // 二分法\\n  if (dividend <= 0) return 0;\\n  if (dividend < divisor) return 0;\\n  if (divisor === 1) return dividend;\\n\\n  let acc = 2 * divisor;\\n  let count = 1;\\n\\n  while (dividend - acc > 0) {\\n    acc += acc;\\n    count += count;\\n  }\\n  // 直接使用位移运算，比如acc >> 1会有问题\\n  const last = dividend - Math.floor(acc / 2);\\n\\n  return count + helper(last, divisor);\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int divide(int dividend, int divisor) {\\n        if (!divisor) return 0;  // divide-by-zero error\\n        bool pos1 = dividend > 0, pos2 = divisor > 0, pos = !(pos1^pos2);\\n        if (pos1) dividend = -dividend;\\n        if (pos2) divisor = -divisor;\\n        int q = 0, d = divisor, t = 1;\\n        while (t > 0 && dividend < 0) {\\n            if (dividend - d <= 0) {\\n                dividend -= d;\\n                q -= t;\\n                if ((INT_MIN >> 1) < d) {\\n                    t <<= 1;\\n                    d <<= 1;\\n                }\\n            } else {\\n                d >>= 1;\\n                t >>= 1;\\n            }\\n        }\\n        return pos? -q : q;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def divide(self, dividend: int, divisor: int) -> int:\\n        \\\"\\\"\\\"\\n        二分法\\n        :param int divisor\\n        :param int dividend\\n        :return int\\n        \\\"\\\"\\\"\\n        # 错误处理\\n        if divisor == 0:\\n            raise ZeroDivisionError\\n        if abs(divisor) == 1:\\n            result = dividend if 1 == divisor else -dividend\\n            return min(2**31-1, max(-2**31, result))\\n\\n        # 确定结果的符号\\n        sign = ((dividend >= 0) == (divisor >= 0))\\n\\n        result = 0\\n        # abs也可以直接写在while条件中，不过可能会多计算几次\\n        _divisor = abs(divisor)\\n        _dividend = abs(dividend)\\n\\n        while _divisor <= _dividend:\\n            r, _dividend = self._multi_divide(_divisor, _dividend)\\n            result += r\\n\\n        result = result if sign else -result\\n\\n        # 注意返回值不能超过32位有符号数的表示范围\\n        return min(2**31-1, max(-2**31, result))\\n\\n    def _multi_divide(self, divisor, dividend):\\n        \\\"\\\"\\\"\\n        翻倍除法，如果可以被除，则下一步除数翻倍，直至除数大于被除数，\\n        返回商加总的结果与被除数的剩余值；\\n        这里就不做异常处理了；\\n        :param int divisor\\n        :param int dividend\\n        :return tuple result, left_dividend\\n        \\\"\\\"\\\"\\n        result = 0\\n        times_count = 1\\n        while divisor <= dividend:\\n            dividend -= divisor\\n            result += times_count\\n            times_count += times_count\\n            divisor += divisor\\n        return result, dividend\\n\"\n        }\n    ]\n},\n\"substring-with-concatenation-of-all-words\":{\n    \"id\": \"30\",\n    \"name\": \"substring-with-concatenation-of-all-words\",\n    \"pre\": [\n        {\n            \"text\": \"字符串\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"Counter\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/30.substring-with-concatenation-of-all-words.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/30.substring-with-concatenation-of-all-words.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n\\nclass Solution {\\nprivate:\\n    int len, n;\\n    string s;\\n    bool rec(int i, unordered_map<string, int> &m, int cnt) {\\n        if (cnt == n) return true;\\n        int &v = m[s.substr(i, len)];\\n        if (v) {\\n            v--;\\n            bool ret = rec(i + len, m, cnt + 1);\\n            v++;\\n            return ret;\\n        }\\n        return false;\\n    }\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        if (words.empty()) return {};\\n        this->s = s;\\n        len = words[0].size();\\n        n = words.size();\\n        unordered_map<string, int> m;\\n        for (string word : words) ++m[word];\\n        int end = s.size() - n * len;\\n        vector<int> v;\\n        for (int i = 0; i <= end; ++i) {\\n            if (rec(i, m, 0)) v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfrom collections import Counter\\n\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        res = []\\n        n = len(words)\\n        word_len = len(words[0])\\n        window_len = word_len * n\\n        target = Counter(words)\\n        i = 0\\n        while i < len(s) - window_len + 1:\\n            sliced = []\\n            start = i\\n            for _ in range(n):\\n                sliced.append(s[start:start + word_len])\\n                start += word_len\\n            if Counter(sliced) == target:\\n                res.append(i)\\n            i += 1\\n        return res\\n\"\n        }\n    ]\n},\n\"next-permutation\":{\n    \"id\": \"31\",\n    \"name\": \"next-permutation\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"写几个例子通常会帮助理解问题的规律\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"在有序数组中首尾指针不断交换位置即可实现reverse\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"找到从右边起`第一个大于nums[i]的`，并将其和nums[i]进行交换\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/31.next-permutation.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/31.next-permutation.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=31 lang=javascript\\n *\\n * [31] Next Permutation\\n */\\n\\nfunction reverseRange(A, i, j) {\\n  while (i < j) {\\n    const temp = A[i];\\n    A[i] = A[j];\\n    A[j] = temp;\\n    i++;\\n    j--;\\n  }\\n}\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function (nums) {\\n  // 时间复杂度O(n) 空间复杂度O(1)\\n  if (nums == null || nums.length <= 1) return;\\n\\n  let i = nums.length - 2;\\n  // 从后往前找到第一个降序的,相当于找到了我们的回溯点\\n  while (i > -1 && nums[i + 1] <= nums[i]) i--;\\n\\n  // 如果找了就swap\\n  if (i > -1) {\\n    let j = nums.length - 1;\\n    // 找到从右边起第一个大于nums[i]的，并将其和nums[i]进行交换\\n    // 因为如果交换的数字比nums[i]还要小肯定不符合题意\\n    while (nums[j] <= nums[i]) j--;\\n    const temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n  }\\n\\n  // 最后我们只需要将剩下的元素从左到右，依次填入当前最小的元素就可以保证是大于当前排列的最小值了\\n  // [i + 1, A.length -1]的元素进行反转\\n\\n  reverseRange(nums, i + 1, nums.length - 1);\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n  void nextPermutation(vector<int>& nums) {\\n    int i = nums.size() - 2, j = nums.size() - 1;\\n    while (i >= 0 && nums[i] >= nums[i + 1]) --i;\\n    if (i >= 0) {\\n      while (j > i && nums[j] <= nums[i]) --j;\\n      swap(nums[i], nums[j]);\\n    }\\n    reverse(nums.begin() + i + 1, nums.end());\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        \\\"\\\"\\\"\\n        Do not return anything, modify nums in-place instead.\\n        :param list nums\\n        \\\"\\\"\\\"\\n        # 第一步，从后往前，找到下降点\\n        down_index = None\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] < nums[i+1]:\\n                down_index = i\\n                break\\n        # 如果没有下降点，重新排列\\n        if down_index is None:\\n            nums.reverse()\\n        # 如果有下降点\\n        else:\\n            # 第二步，从后往前，找到比下降点大的数，对换位置\\n            for i in range(len(nums)-1, i, -1):\\n                if nums[down_index] < nums[i]:\\n                    nums[down_index], nums[i] = nums[i], nums[down_index]\\n                    break\\n            # 第三部，重新排列下降点之后的数\\n            i, j = down_index+1, len(nums)-1\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n                j -= 1\\n\"\n        }\n    ]\n},\n\"longest-valid-parentheses\":{\n    \"id\": \"32\",\n    \"name\": \"longest-valid-parentheses\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.第3点特征,需要检查的字符是s[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1]和s[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"2\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1]],根据定义可知:i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1>=dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1],但是i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"2不一定大于dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1],因此,需要检查越界;2.第4点特征最容易遗漏,还有就是不需要检查越界,因为根据定义可知:i>=dp[i],所以dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"dp[i]]的边界情况是dp[0];\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/32.longest-valid-parentheses.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/32.longest-valid-parentheses.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int left = 0, right = 0, maxlength = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == '(') {\\n                left++;\\n            } else {\\n                right++;\\n            }\\n            if (left == right) {\\n                maxlength = Math.max(maxlength, left + right);\\n            }\\n            if (right > left) {\\n                left = right = 0;\\n            }\\n        }\\n        left = right = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == '(') {\\n                left++;\\n            } else {\\n                right++;\\n            }\\n            if (left == right) {\\n                maxlength = Math.max(maxlength, left + right);\\n            }\\n            if (left > right) {\\n                left = right = 0;\\n            }\\n        }\\n        return maxlength;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 用栈来解\\nvar longestValidParentheses = function (s) {\\n  let stack = new Array();\\n  let longest = 0;\\n  stack.push(-1);\\n  for (let i = 0; i < s.length; i++) {\\n    if (s[i] === \\\"(\\\") {\\n      stack.push(i);\\n    } else {\\n      stack.pop();\\n      if (stack.length === 0) {\\n        stack.push(i);\\n      } else {\\n        longest = Math.max(longest, i - stack[stack.length - 1]);\\n      }\\n    }\\n  }\\n  return longest;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == ')' && st.top() != -1 && s[st.top()] == '(') {\\n                st.pop();\\n                ans = max(ans, i - st.top());\\n            } else st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left = 0, right = 0, ans = 0, N = s.size();\\n        for (int i = 0; i < N; ++i) {\\n            left += s[i] == '(';\\n            right += s[i] == ')';\\n            if (left == right) ans = max(ans, left + right);\\n            else if (right > left) left = right = 0;\\n        }\\n        left = 0, right = 0;\\n        for (int i = N - 1; i >= 0; --i) {\\n            left += s[i] == '(';\\n            right += s[i] == ')';\\n            if (left == right) ans = max(ans, left + right);\\n            else if (left > right) left = right = 0;\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size() + 1, 0);\\n        int ans = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (s[i] == '(') continue;\\n            int start = i - dp[i] - 1;\\n            if (start >= 0 && s[start] == '(')\\n                dp[i + 1] = dp[i] + 2 + dp[start];\\n            ans = max(ans, dp[i + 1]);\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        n = len(s)\\n        ans = 0\\n\\n        def validCnt(start):\\n            # cnt 为 ) 的数量减去 ( 的数量\\n            cnt = 0\\n            ans = 0\\n            for i in range(start, n):\\n                if s[i] == '(':\\n                    cnt += 1\\n                if s[i] == ')':\\n                    cnt -= 1\\n                if cnt < 0:\\n                    return i - start\\n                if cnt == 0:\\n                    ans = max(ans, i - start + 1)\\n            return ans\\n        for i in range(n):\\n            ans = max(ans, validCnt(i))\\n\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        if not s:\\n            return 0\\n        res = 0\\n        stack = [-1]\\n        for i in range(len(s)):\\n            if s[i] == \\\"(\\\":\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    res = max(res, i - stack[-1])\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        ans = l = r = 0\\n        for c in s:\\n            if c == '(':\\n                l += 1\\n            else:\\n                r += 1\\n            if l == r:\\n                ans = max(ans, l + r)\\n            if r > l:\\n                l = r = 0\\n        l = r = 0\\n        for c in s[::-1]:\\n            if c == '(':\\n                l += 1\\n            else:\\n                r += 1\\n            if l == r:\\n                ans = max(ans, l + r)\\n            if r < l:\\n                l = r = 0\\n\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ns = '(())())'\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        mlen = 0\\n        slen = len(s)\\n        dp = [0] * (slen + 1)\\n        for i in range(1, len(s) + 1):\\n            # 有效的括号对不可能会以'('结尾的\\n            if s[i - 1] == '(':\\n                continue\\n\\n            left_paren = i - 2 - dp[i - 1]\\n            if left_paren >= 0 and s[left_paren] == '(':\\n                dp[i] = dp[i - 1] + 2\\n\\n                # 拼接有效括号对\\n                if dp[i - dp[i]]:\\n                    dp[i] += dp[i - dp[i]]\\n\\n                # 更新最大有效扩对长度\\n                if dp[i] > mlen:\\n                    mlen = dp[i]\\n\\n        return mlen\\n\"\n        }\n    ]\n},\n\"search-in-rotated-sorted-array\":{\n    \"id\": \"33\",\n    \"name\": \"search-in-rotated-sorted-array\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"[二分法](../91/binary\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"search.md)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"找出有序区间，然后根据target是否在有序区间舍弃一半元素\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/33.search-in-rotated-sorted-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/33.search-in-rotated-sorted-array.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=33 lang=javascript\\n *\\n * [33] Search in Rotated Sorted Array\\n */\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function (nums, target) {\\n  // 时间复杂度：O(logn)\\n  // 空间复杂度：O(1)\\n  // [6,7,8,1,2,3,4,5]\\n  let start = 0;\\n  let end = nums.length - 1;\\n\\n  while (start <= end) {\\n    const mid = start + ((end - start) >> 1);\\n    if (nums[mid] === target) return mid;\\n\\n    // [start, mid]有序\\n\\n    // ️⚠️注意这里的等号\\n    if (nums[mid] >= nums[start]) {\\n      //target 在 [start, mid] 之间\\n\\n      // 其实target不可能等于nums[mid]， 但是为了对称，我还是加上了等号\\n      if (target >= nums[start] && target <= nums[mid]) {\\n        end = mid - 1;\\n      } else {\\n        //target 不在 [start, mid] 之间\\n        start = mid + 1;\\n      }\\n    } else {\\n      // [mid, end]有序\\n\\n      // target 在 [mid, end] 之间\\n      if (target >= nums[mid] && target <= nums[end]) {\\n        start = mid + 1;\\n      } else {\\n        // target 不在 [mid, end] 之间\\n        end = mid - 1;\\n      }\\n    }\\n  }\\n\\n  return -1;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\\"\\\"\\\"用二分法，先判断左右两边哪一边是有序的，再判断是否在有序的列表之内\\\"\\\"\\\"\\n        if len(nums) <= 0:\\n            return -1\\n\\n        left = 0\\n        right = len(nums) - 1\\n        while left < right:\\n            mid = (right - left) // 2 + left\\n            if nums[mid] == target:\\n                return mid\\n\\n            # 如果中间的值大于最左边的值，说明左边有序\\n            if nums[mid] > nums[left]:\\n                if nums[left] <= target <= nums[mid]:\\n                    right = mid\\n                else:\\n                    # 这里 +1，因为上面是 <= 符号\\n                    left = mid + 1\\n            # 否则右边有序\\n            else:\\n                # 注意：这里必须是 mid+1，因为根据我们的比较方式，mid属于左边的序列\\n                if nums[mid+1] <= target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n\\n        return left if nums[left] == target else -1\\n\"\n        }\n    ]\n},\n\"combination-sum\":{\n    \"id\": \"39\",\n    \"name\": \"combination-sum\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"backtrack解题公式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/39.combination-sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/39.combination-sum.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction backtrack(list, tempList, nums, remain, start) {\\n  if (remain < 0) return;\\n  else if (remain === 0) return list.push([...tempList]);\\n  for (let i = start; i < nums.length; i++) {\\n    tempList.push(nums[i]);\\n    backtrack(list, tempList, nums, remain - nums[i], i); // 数字可以重复使用， i + 1代表不可以重复利用\\n    tempList.pop();\\n  }\\n}\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum = function (candidates, target) {\\n  const list = [];\\n  backtrack(\\n    list,\\n    [],\\n    candidates.sort((a, b) => a - b),\\n    target,\\n    0\\n  );\\n  return list;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n    vector<vector<int>> res;\\n    void dfs(vector<int> &c, int t, int start, vector<int> &v) {\\n        if (!t) {\\n            res.push_back(v);\\n            return;\\n        }\\n        for (int i = start; i < c.size() && t >= c[i]; ++i) {\\n            v.push_back(c[i]);\\n            dfs(c, t - c[i], i, v);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> v;\\n        dfs(candidates, target, 0, v);\\n        return res;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\\"\\\"\\\"\\n        回溯法，层层递减，得到符合条件的路径就加入结果集中，超出则剪枝；\\n        主要是要注意一些细节，避免重复等；\\n        \\\"\\\"\\\"\\n        size = len(candidates)\\n        if size <= 0:\\n            return []\\n\\n        # 先排序，便于后面剪枝\\n        candidates.sort()\\n\\n        path = []\\n        res = []\\n        self._find_path(target, path, res, candidates, 0, size)\\n\\n        return res\\n\\n    def _find_path(self, target, path, res, candidates, begin, size):\\n        \\\"\\\"\\\"沿着路径往下走\\\"\\\"\\\"\\n        if target == 0:\\n            res.append(path.copy())\\n        else:\\n            for i in range(begin, size):\\n                left_num = target - candidates[i]\\n                # 如果剩余值为负数，说明超过了，剪枝\\n                if left_num < 0:\\n                    break\\n                # 否则把当前值加入路径\\n                path.append(candidates[i])\\n                # 为避免重复解，我们把比当前值小的参数也从下一次寻找中剔除，\\n                # 因为根据他们得出的解一定在之前就找到过了\\n                self._find_path(left_num, path, res, candidates, i, size)\\n                # 记得把当前值移出路径，才能进入下一个值的路径\\n                path.pop()\\n\"\n        }\n    ]\n},\n\"combination-sum-ii\":{\n    \"id\": \"40\",\n    \"name\": \"combination-sum-ii\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"backtrack解题公式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/40.combination-sum-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/40.combination-sum-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction backtrack(list, tempList, nums, remain, start) {\\n  if (remain < 0) return;\\n  else if (remain === 0) return list.push([...tempList]);\\n  for (let i = start; i < nums.length; i++) {\\n    // 和39.combination-sum 的其中一个区别就是这道题candidates可能有重复\\n    // 代码表示就是下面这一行。注意 i > start 这一条件\\n    if (i > start && nums[i] == nums[i - 1]) continue; // skip duplicates\\n    tempList.push(nums[i]);\\n    backtrack(list, tempList, nums, remain - nums[i], i + 1); // i + 1代表不可以重复利用， i 代表数字可以重复使用\\n    tempList.pop();\\n  }\\n}\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function (candidates, target) {\\n  const list = [];\\n  backtrack(\\n    list,\\n    [],\\n    candidates.sort((a, b) => a - b),\\n    target,\\n    0\\n  );\\n  return list;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\n    vector<vector<int>> ans;\\n    void backtrack(vector<int> &A, int target, int start, vector<int> &path) {\\n        if (!target) {\\n            ans.push_back(path);\\n            return;\\n        }\\n        for (int i = start; i < A.size() && target >= A[i]; ++i) {\\n            if (i != start && A[i] == A[i - 1]) continue;\\n            path.push_back(A[i]);\\n            dfs(A, target - A[i], i + 1, path);\\n            path.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& A, int target) {\\n        sort(A.begin(), A.end());\\n        vector<int> path;\\n        backtrack(A, target, 0, path);\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n if target == 0:\\n    res.append(path.copy())\\nelse:\\n    for i in range(begin, size):\\n        left_num = target - candidates[i]\\n        if left_num < 0:\\n            break\\n        path.append(candidates[i])\\n        self._find_path(candidates, path, res, left_num, i+1, size)\\n        path.pop()\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n if target == 0:\\n    res.append(path.copy())\\nelse:\\n    for i in range(begin, size):\\n        # 增加下面一行代码\\n        if i > begin and candidates[i] == candidate[i - 1]: continue\\n        left_num = target - candidates[i]\\n        if left_num < 0:\\n            break\\n        path.append(candidates[i])\\n        self._find_path(candidates, path, res, left_num, i+1, size)\\n        path.pop()\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\\"\\\"\\\"\\n        与39题的区别是不能重用元素，而元素可能有重复；\\n        不能重用好解决，回溯的index往下一个就行；\\n        元素可能有重复，就让结果的去重麻烦一些；\\n        \\\"\\\"\\\"\\n        size = len(candidates)\\n        if size == 0:\\n            return []\\n\\n        # 还是先排序，主要是方便去重\\n        candidates.sort()\\n\\n        path = []\\n        res = []\\n        self._find_path(candidates, path, res, target, 0, size)\\n\\n        return res\\n\\n    def _find_path(self, candidates, path, res, target, begin, size):\\n        if target == 0:\\n            res.append(path.copy())\\n        else:\\n            for i in range(begin, size):\\n                left_num = target - candidates[i]\\n                if left_num < 0:\\n                    break\\n                # 如果存在重复的元素，前一个元素已经遍历了后一个元素与之后元素组合的所有可能\\n                if i > begin and candidates[i] == candidates[i-1]:\\n                    continue\\n                path.append(candidates[i])\\n                # 开始的 index 往后移了一格\\n                self._find_path(candidates, path, res, left_num, i+1, size)\\n                path.pop()\\n\"\n        }\n    ]\n},\n\"trapping-rain-water\":{\n    \"id\": \"42\",\n    \"name\": \"trapping-rain-water\",\n    \"pre\": [\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"单调栈\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"建模`h[i]=Math.min(左边柱子最大值,右边柱子最大值)`(h为下雨之后的水位)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/42.trapping-rain-water.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/42.trapping-rain-water.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfor (let i = 0; i < height.length; i++) {\\n  area += (h[i] - height[i]) * 1; // h为下雨之后的水位\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=42 lang=javascript\\n *\\n * [42] Trapping Rain Water\\n *\\n */\\n/**\\n * @param {number[]} height\\n * @return {number}\\n */\\nvar trap = function (height) {\\n  let max = 0;\\n  let volume = 0;\\n  const leftMax = [];\\n  const rightMax = [];\\n\\n  for (let i = 0; i < height.length; i++) {\\n    leftMax[i] = max = Math.max(height[i], max);\\n  }\\n\\n  max = 0;\\n\\n  for (let i = height.length - 1; i >= 0; i--) {\\n    rightMax[i] = max = Math.max(height[i], max);\\n  }\\n\\n  for (let i = 0; i < height.length; i++) {\\n    volume = volume + Math.min(leftMax[i], rightMax[i]) - height[i];\\n  }\\n\\n  return volume;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nint trap(vector<int>& heights)\\n{\\n\\tif(heights == null)\\n\\t\\treturn 0;\\n    int ans = 0;\\n    int size = heights.size();\\n    vector<int> left_max(size), right_max(size);\\n    left_max[0] = heights[0];\\n    for (int i = 1; i < size; i++) {\\n        left_max[i] = max(heights[i], left_max[i - 1]);\\n    }\\n    right_max[size - 1] = heights[size - 1];\\n    for (int i = size - 2; i >= 0; i--) {\\n        right_max[i] = max(heights[i], right_max[i + 1]);\\n    }\\n    for (int i = 1; i < size - 1; i++) {\\n        ans += min(left_max[i], right_max[i]) - heights[i];\\n    }\\n    return ans;\\n}\\n\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n\\nclass Solution {\\npublic:\\n    int trap(vector<int>& heights)\\n{\\n    int left = 0, right = heights.size() - 1;\\n    int ans = 0;\\n    int left_max = 0, right_max = 0;\\n    while (left < right) {\\n        if (heights[left] < heights[right]) {\\n            heights[left] >= left_max ? (left_max = heights[left]) : ans += (left_max - heights[left]);\\n            ++left;\\n        }\\n        else {\\n            heights[right] >= right_max ? (right_max = heights[right]) : ans += (right_max - heights[right]);\\n            --right;\\n        }\\n    }\\n    return ans;\\n}\\n\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def trap(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        l, r = [0] * (n + 1), [0] * (n + 1)\\n        ans = 0\\n        for i in range(1, len(heights) + 1):\\n            l[i] = max(l[i - 1], heights[i - 1])\\n        for i in range(len(heights) - 1, 0, -1):\\n            r[i] = max(r[i + 1], heights[i])\\n        for i in range(len(heights)):\\n            ans += max(0, min(l[i + 1], r[i]) - heights[i])\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def trap(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        l_max = r_max = 0\\n        l, r = 0, n - 1\\n        ans = 0\\n        while l < r:\\n            if heights[l] < heights[r]:\\n                if heights[l] < l_max:\\n                    ans += l_max - heights[l]\\n                else:\\n                    l_max = heights[l]\\n                l += 1\\n            else:\\n                if heights[r] < r_max:\\n                    ans += r_max - heights[r]\\n                else:\\n                    r_max = heights[r]\\n                r -= 1\\n        return ans\\n\"\n        }\n    ]\n},\n\"permutations\":{\n    \"id\": \"46\",\n    \"name\": \"permutations\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"backtrack解题公式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/46.permutations.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/46.permutations.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction backtrack(list, tempList, nums) {\\n  if (tempList.length === nums.length) return list.push([...tempList]);\\n  for (let i = 0; i < nums.length; i++) {\\n    if (tempList.includes(nums[i])) continue;\\n    tempList.push(nums[i]);\\n    backtrack(list, tempList, nums);\\n    tempList.pop();\\n  }\\n}\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permute = function (nums) {\\n  const list = [];\\n  backtrack(list, [], nums);\\n  return list;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\n    vector<vector<int>> ans;\\n    void dfs(vector<int> &nums, int start) {\\n        if (start == nums.size() - 1) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n        for (int i = start; i < nums.size(); ++i) {\\n            swap(nums[i], nums[start]);\\n            dfs(nums, start + 1);\\n            swap(nums[i], nums[start]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        dfs(nums, 0);\\n        return ans;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"permutations-ii\":{\n    \"id\": \"47\",\n    \"name\": \"permutations-ii\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"backtrack解题公式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/47.permutations-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/47.permutations-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=47 lang=javascript\\n *\\n * [47] Permutations II\\n */\\nfunction backtrack(list, nums, tempList, visited) {\\n  if (tempList.length === nums.length) return list.push([...tempList]);\\n  for (let i = 0; i < nums.length; i++) {\\n    // 和46.permutations的区别是这道题的nums是可以重复的\\n    // 我们需要过滤这种情况\\n    if (visited[i]) continue; // 同一个数字不能用两次\\n    if (i > 0 && nums[i] === nums[i - 1] && visited[i - 1]) continue; // 同样值的数字不能用两次\\n\\n    visited[i] = true;\\n    tempList.push(nums[i]);\\n    backtrack(list, nums, tempList, visited);\\n    visited[i] = false;\\n    tempList.pop();\\n  }\\n}\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar permuteUnique = function (nums) {\\n  const list = [];\\n  backtrack(\\n    list,\\n    nums.sort((a, b) => a - b),\\n    [],\\n    []\\n  );\\n  return list;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n  vector<vector<int>> ans;\\n  void permute(vector<int> nums, int start) {\\n    if (start == nums.size() - 1) {\\n      ans.push_back(nums);\\n      return;\\n    }\\n    for (int i = start; i < nums.size(); ++i) {\\n      if (i != start && nums[i] == nums[start]) continue;\\n      swap(nums[i], nums[start]);\\n      permute(nums, start + 1);\\n    }\\n  }\\npublic:\\n  vector<vector<int>> permuteUnique(vector<int>& nums) {\\n    sort(nums.begin(), nums.end());\\n    permute(nums, 0);\\n    return ans;\\n  }\\n};\\n\"\n        }\n    ]\n},\n\"rotate-image\":{\n    \"id\": \"48\",\n    \"name\": \"rotate-image\",\n    \"pre\": [\n        {\n            \"text\": \"原地算法\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"矩阵\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"矩阵旋转操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/48.rotate-image.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/48.rotate-image.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar rotate = function (matrix) {\\n  // 时间复杂度O(n^2) 空间复杂度O(n)\\n  const oMatrix = JSON.parse(JSON.stringify(matrix)); // clone\\n  const n = oMatrix.length;\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < n; j++) {\\n      matrix[j][n - i - 1] = oMatrix[i][j];\\n    }\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=48 lang=javascript\\n *\\n * [48] Rotate Image\\n */\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar rotate = function (matrix) {\\n  // 时间复杂度O(n^2) 空间复杂度O(1)\\n\\n  // 做法： 先沿着对角线翻转，然后沿着水平线翻转\\n  const n = matrix.length;\\n  function swap(arr, [i, j], [m, n]) {\\n    const temp = arr[i][j];\\n    arr[i][j] = arr[m][n];\\n    arr[m][n] = temp;\\n  }\\n  for (let i = 0; i < n - 1; i++) {\\n    for (let j = 0; j < n - i; j++) {\\n      swap(matrix, [i, j], [n - j - 1, n - i - 1]);\\n    }\\n  }\\n\\n  for (let i = 0; i < n / 2; i++) {\\n    for (let j = 0; j < n; j++) {\\n      swap(matrix, [i, j], [n - i - 1, j]);\\n    }\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int N = matrix.size();\\n        for (int i = 0; i < N / 2; ++i) {\\n            for (int j = i; j < N - i - 1; ++j) {\\n                int tmp = matrix[i][j];\\n                matrix[i][j] = matrix[N - j - 1][i];\\n                matrix[N - j - 1][i] = matrix[N - i - 1][N - j - 1];\\n                matrix[N - i - 1][N - j - 1] = matrix[j][N - i - 1];\\n                matrix[j][N - i - 1] = tmp;\\n            }\\n        }\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"group-anagrams\":{\n    \"id\": \"49\",\n    \"name\": \"group-anagrams\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"桶排序\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/49.group-anagrams.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/49.group-anagrams.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar groupAnagrams = function (strs) {\\n  const hashTable = {};\\n\\n  function sort(str) {\\n    return str.split(\\\"\\\").sort().join(\\\"\\\");\\n  }\\n\\n  // 这个方法需要排序，因此不是很优，但是很直观，容易想到\\n  for (let i = 0; i < strs.length; i++) {\\n    const str = strs[i];\\n    const key = sort(str);\\n    if (!hashTable[key]) {\\n      hashTable[key] = [str];\\n    } else {\\n      hashTable[key].push(str);\\n    }\\n  }\\n\\n  return Object.values(hashTable);\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=49 lang=javascript\\n *\\n * [49] Group Anagrams\\n */\\n/**\\n * @param {string[]} strs\\n * @return {string[][]}\\n */\\nvar groupAnagrams = function (strs) {\\n  // 类似桶排序\\n\\n  let counts = [];\\n  const hashTable = {};\\n  for (let i = 0; i < strs.length; i++) {\\n    const str = strs[i];\\n    counts = Array(26).fill(0);\\n    for (let j = 0; j < str.length; j++) {\\n      counts[str[j].charCodeAt(0) - \\\"a\\\".charCodeAt(0)]++;\\n    }\\n    const key = counts.join(\\\"-\\\");\\n    if (!hashTable[key]) {\\n      hashTable[key] = [str];\\n    } else {\\n      hashTable[key].push(str);\\n    }\\n  }\\n\\n  return Object.values(hashTable);\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& A) {\\n        unordered_map<string, int> m;\\n        vector<vector<string>> ans;\\n        for (auto &s : A) {\\n            auto p = s;\\n            sort(p.begin(), p.end());\\n            if (!m.count(p)) {\\n                m[p] = ans.size();\\n                ans.push_back({});\\n            }\\n            ans[m[p]].push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"pow-x-n\":{\n    \"id\": \"50\",\n    \"name\": \"pow-x-n\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"超时分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"hashtable\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"数学分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"二进制转十进制\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/50.pow-x-n.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/50.pow-x-n.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\n    double myPow(double x, long n) {\\n        if (n < 0) return 1 / myPow(x, -n);\\n        if (n == 0) return 1;\\n        if (n == 1) return x;\\n        if (n == 2) return x * x;\\n        return myPow(myPow(x, n / 2), 2) * (n % 2 ? x : 1);\\n    }\\npublic:\\n    double myPow(double x, int n) {\\n        return myPow(x, (long)n);\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n < 0:\\n            return 1 / self.myPow(x, -n)\\n        res = 1\\n        for _ in range(n):\\n            res *= x\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return x\\n        if n < 0:\\n            return 1 / self.myPow(x, -n)\\n        return self.myPow(x, n // 2) * self.myPow(x, n - n // 2)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n == 0:\\n            return 1\\n        if n == 1:\\n            return x\\n        if n < 0:\\n            return 1 / self.myPow(x, -n)\\n        return self.myPow(x * x, n // 2) if n % 2 == 0 else x * self.myPow(x, n - 1)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        if n < 0:\\n            return 1 / self.myPow(x, -n)\\n        res = 1\\n        while n:\\n            if n & 1 == 1:\\n                res *= x\\n            x *= x\\n            n >>= 1\\n        return res\\n\"\n        }\n    ]\n},\n\"N-Queens-II\":{\n    \"id\": \"52\",\n    \"name\": \"N-Queens-II\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"深度优先遍历\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"DFS（深度优先搜索）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/52.N-Queens-II.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/52.N-Queens-II.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number} n\\n * @return {number}\\n * @param row 当前层\\n * @param cols 列\\n * @param pie 左斜线\\n * @param na 右斜线\\n */\\nconst totalNQueens = function (n) {\\n    let res = 0;\\n    const dfs = (n, row, cols, pie, na) => {\\n        if (row >= n) {\\n            res++;\\n            return;\\n        }\\n        // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\\n        // 也就是得到当前所有的空位\\n        let bits = (~(cols | pie | na)) & ((1 << n) - 1);\\n        while (bits) {\\n            // 取最低位的1\\n            let p = bits & -bits;\\n            // 把P位置上放入皇后\\n            bits = bits & (bits - 1);\\n            // row + 1 搜索下一行可能的位置\\n            // cols ｜ p 目前所有放置皇后的列\\n            // (pie | p) << 1 和 (na | p) >> 1) 与已放置过皇后的位置 位于一条斜线上的位置\\n            dfs(n, row + 1, cols | p, (pie | p) << 1, (na | p) >> 1);\\n        }\\n    }\\n    dfs(n, 0, 0, 0, 0);\\n    return res;\\n};\\n\"\n        }\n    ]\n},\n\"maximum-sum-subarray-cn\":{\n    \"id\": \"53\",\n    \"name\": \"maximum-sum-subarray-cn\",\n    \"pre\": [\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md\",\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析1.暴力解，列举所有组合子序列首尾位置的组合，求解最大的子序列和,优化可以预先处理，得到前缀和2.分治法，每次从中间位置把数组分为左右中三部分，分别求出左右中（这里中是包括中间元素的子序列）最大和。对左右分别深度递归，三者中最大值即为当前最大子序列和。3.动态规划，找到状态转移方程，求到当前位置最大和。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"linkedin\"\n        },\n        {\n            \"name\": \"microsoft\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/53.maximum-sum-subarray-cn.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MaximumSubarrayPrefixSum {\\n  public int maxSubArray(int[] nums) {\\n      int len = nums.length;\\n      int maxSum = Integer.MIN_VALUE;\\n      int sum = 0;\\n      for (int i = 0; i < len; i++) {\\n        sum = 0;\\n        for (int j = i; j < len; j++) {\\n          sum += nums[j];\\n          maxSum = Math.max(maxSum, sum);\\n        }\\n      }\\n      return maxSum;\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MaxSumSubarray {\\n  public int maxSubArray3(int[] nums) {\\n      int maxSum = nums[0];\\n      int sum = 0;\\n      int minSum = 0;\\n      for (int num : nums) {\\n        // prefix Sum\\n        sum += num;\\n        // update maxSum\\n        maxSum = Math.max(maxSum, sum - minSum);\\n        // update minSum\\n        minSum = Math.min(minSum, sum);\\n      }\\n      return maxSum;\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MaximumSubarrayDivideConquer {\\n  public int maxSubArrayDividConquer(int[] nums) {\\n      if (nums == null || nums.length == 0) return 0;\\n      return helper(nums, 0, nums.length - 1);\\n    }\\n    private int helper(int[] nums, int l, int r) {\\n      if (l > r) return Integer.MIN_VALUE;\\n      int mid = (l + r) >>> 1;\\n      int left = helper(nums, l, mid - 1);\\n      int right = helper(nums, mid + 1, r);\\n      int leftMaxSum = 0;\\n      int sum = 0;\\n      // left surfix maxSum start from index mid - 1 to l\\n      for (int i = mid - 1; i >= l; i--) {\\n        sum += nums[i];\\n        leftMaxSum = Math.max(leftMaxSum, sum);\\n      }\\n      int rightMaxSum = 0;\\n      sum = 0;\\n      // right prefix maxSum start from index mid + 1 to r\\n      for (int i = mid + 1; i <= r; i++) {\\n        sum += nums[i];\\n        rightMaxSum = Math.max(sum, rightMaxSum);\\n      }\\n      // max(left, right, crossSum)\\n      return Math.max(leftMaxSum + rightMaxSum + nums[mid], Math.max(left, right));\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MaximumSubarrayDP {\\n  public int maxSubArray(int[] nums) {\\n     int currMaxSum = nums[0];\\n     int maxSum = nums[0];\\n     for (int i = 1; i < nums.length; i++) {\\n       currMaxSum = Math.max(currMaxSum + nums[i], nums[i]);\\n       maxSum = Math.max(maxSum, currMaxSum);\\n     }\\n     return maxSum;\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction LSS(list) {\\n  const len = list.length;\\n  let max = -Number.MAX_VALUE;\\n  let sum = 0;\\n  for (let i = 0; i < len; i++) {\\n    sum = 0;\\n    for (let j = i; j < len; j++) {\\n      sum += list[j];\\n      if (sum > max) {\\n        max = sum;\\n      }\\n    }\\n  }\\n\\n  return max;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction LSS(list) {\\n  const len = list.length;\\n  let max = list[0];\\n  let min = 0;\\n  let sum = 0;\\n  for (let i = 0; i < len; i++) {\\n    sum += list[i];\\n    if (sum - min > max) max = sum - min;\\n    if (sum < min) {\\n      min = sum;\\n    }\\n  }\\n\\n  return max;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction helper(list, m, n) {\\n  if (m === n) return list[m];\\n  let sum = 0;\\n  let lmax = -Number.MAX_VALUE;\\n  let rmax = -Number.MAX_VALUE;\\n  const mid = ((n - m) >> 1) + m;\\n  const l = helper(list, m, mid);\\n  const r = helper(list, mid + 1, n);\\n  for (let i = mid; i >= m; i--) {\\n    sum += list[i];\\n    if (sum > lmax) lmax = sum;\\n  }\\n\\n  sum = 0;\\n\\n  for (let i = mid + 1; i <= n; i++) {\\n    sum += list[i];\\n    if (sum > rmax) rmax = sum;\\n  }\\n\\n  return Math.max(l, r, lmax + rmax);\\n}\\n\\nfunction LSS(list) {\\n  return helper(list, 0, list.length - 1);\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction LSS(list) {\\n  const len = list.length;\\n  let max = list[0];\\n  for (let i = 1; i < len; i++) {\\n    list[i] = Math.max(0, list[i - 1]) + list[i];\\n    if (list[i] > max) max = list[i];\\n  }\\n\\n  return max;\\n}\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nimport sys\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maxSum = -sys.maxsize\\n        sum = 0\\n        for i in range(n):\\n            sum = 0\\n            for j in range(i, n):\\n                sum += nums[j]\\n                maxSum = max(maxSum, sum)\\n\\n        return maxSum\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maxSum = nums[0]\\n        minSum = sum = 0\\n        for i in range(n):\\n            sum += nums[i]\\n            maxSum = max(maxSum, sum - minSum)\\n            minSum = min(minSum, sum)\\n\\n        return maxSum\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nimport sys\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        return self.helper(nums, 0, len(nums) - 1)\\n    def helper(self, nums, l, r):\\n        if l > r:\\n            return -sys.maxsize\\n        mid = (l + r) // 2\\n        left = self.helper(nums, l, mid - 1)\\n        right = self.helper(nums, mid + 1, r)\\n        left_suffix_max_sum = right_prefix_max_sum = 0\\n        sum = 0\\n        for i in reversed(range(l, mid)):\\n            sum += nums[i]\\n            left_suffix_max_sum = max(left_suffix_max_sum, sum)\\n        sum = 0\\n        for i in range(mid + 1, r + 1):\\n            sum += nums[i]\\n            right_prefix_max_sum = max(right_prefix_max_sum, sum)\\n        cross_max_sum = left_suffix_max_sum + right_prefix_max_sum + nums[mid]\\n        return max(cross_max_sum, left, right)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        max_sum_ending_curr_index = max_sum = nums[0]\\n        for i in range(1, n):\\n            max_sum_ending_curr_index = max(max_sum_ending_curr_index + nums[i], nums[i])\\n            max_sum = max(max_sum_ending_curr_index, max_sum)\\n\\n        return max_sum\\n\"\n        }\n    ]\n},\n\"jump-game\":{\n    \"id\": \"55\",\n    \"name\": \"jump-game\",\n    \"pre\": [\n        {\n            \"text\": \"贪心\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/greedy.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"记录和更新当前位置能够到达的最大的索引\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/55.jump-game.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/55.jump-game.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public boolean canJump(int[] nums) {\\n        int n=nums.length;\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>k){\\n                return false;\\n            }\\n            // 能跳到最后一个位置\\n            if(k>=n-1){\\n                return true;\\n            }\\n            // 从当前位置能跳的最远的位置\\n            k = Math.max(k, i+nums[i]);\\n        }\\n        return k >= n-1;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canJump = function (nums) {\\n  let max = 0; // 能够走到的数组下标\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (max < i) return false; // 当前这一步都走不到，后面更走不到了\\n    max = Math.max(nums[i] + i, max);\\n  }\\n\\n  return max >= nums.length - 1;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    bool canJump(vector<int>& nums) {\\n        int n=nums.size();\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>k){\\n                return false;\\n            }\\n            // 能跳到最后一个位置\\n            if(k>=n-1){\\n                return true;\\n            }\\n            // 从当前位置能跳的最远的位置\\n            k = max(k, i+nums[i]);\\n        }\\n        return k >= n-1;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"merge-intervals\":{\n    \"id\": \"56\",\n    \"name\": \"merge-intervals\",\n    \"pre\": [\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"对数组进行排序简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果不排序，需要借助一些hack,这里不介绍了\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/56.merge-intervals.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/56.merge-intervals.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=56 lang=javascript\\n *\\n * [56] Merge Intervals\\n */\\n/**\\n * @param {number[][]} intervals\\n * @return {number[][]}\\n */\\n\\nfunction intersected(a, b) {\\n  if (a[0] > b[1] || a[1] < b[0]) return false;\\n  return true;\\n}\\n\\nfunction mergeTwo(a, b) {\\n  return [Math.min(a[0], b[0]), Math.max(a[1], b[1])];\\n}\\nvar merge = function (intervals) {\\n  // 这种算法需要先排序\\n  intervals.sort((a, b) => a[0] - b[0]);\\n  for (let i = 0; i < intervals.length - 1; i++) {\\n    const cur = intervals[i];\\n    const next = intervals[i + 1];\\n\\n    if (intersected(cur, next)) {\\n      intervals[i] = undefined;\\n      intervals[i + 1] = mergeTwo(cur, next);\\n    }\\n  }\\n  return intervals.filter((q) => q);\\n};\\n\"\n        }\n    ]\n},\n\"insert-interval\":{\n    \"id\": \"57\",\n    \"name\": \"insert-interval\",\n    \"pre\": [\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/57.insert-interval.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/57.insert-interval.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        intervals.append(newInterval)\\n        intervals.sort(key=lambda a: a[0])\\n\\n        def intersected(a, b):\\n            if a[0] > b[1] or a[1] < b[0]:\\n                return False\\n            return True\\n\\n        def mergeTwo(a, b):\\n            return [min(a[0], b[0]), max(a[1], b[1])]\\n\\n        i = 0\\n        while i < len(intervals) - 1:\\n            cur = intervals[i]\\n            next = intervals[i + 1]\\n            if intersected(cur, next):\\n                intervals[i] = None\\n                intervals[i + 1] = mergeTwo(cur, next)\\n            i += 1\\n\\n        return list(filter(lambda x: x, intervals))\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\\n        i, n = 0, len(intervals)\\n        ans = []\\n\\n        def intersected(a, b):\\n            if a[0] > b[1] or a[1] < b[0]:\\n                return False\\n            return True\\n        # 前\\n        while i < n and intervals[i][1] < newInterval[0]:\\n            ans.append(intervals[i])\\n            i += 1\\n        # 中\\n        while i < n and intersected(intervals[i], newInterval):\\n            newInterval = [min(intervals[i][0], newInterval[0]),\\n                           max(intervals[i][1], newInterval[1])]\\n            i += 1\\n        ans.append(newInterval)\\n        # 后\\n        while i < n:\\n            ans.append(intervals[i])\\n            i += 1\\n        return ans\\n\"\n        }\n    ]\n},\n\"permutation-sequence\":{\n    \"id\": \"60\",\n    \"name\": \"permutation-sequence\",\n    \"pre\": [\n        {\n            \"text\": \"数学\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"factorial\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"找规律\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"排列组合\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"Twitter\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/60.permutation-sequence.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/60.permutation-sequence.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nimport math\\n\\nclass Solution:\\n    def getPermutation(self, n: int, k: int) -> str:\\n        res = \\\"\\\"\\n        candidates = [str(i) for i in range(1, n + 1)]\\n\\n        while n != 0:\\n            facto = math.factorial(n - 1)\\n            # i 表示前面被我们排除的组数，也就是k所在的组的下标\\n            # k // facto 是不行的， 比如在 k % facto == 0的情况下就会有问题\\n            i = math.ceil(k / facto) - 1\\n            # 我们把candidates[i]加入到结果集，然后将其弹出candidates（不能重复使用元素）\\n            res += candidates[i]\\n            candidates.pop(i)\\n            # k 缩小了 facto *  i\\n            k -= facto * i\\n            # 每次迭代我们实际上就处理了一个元素，n 减去 1，当n == 0 说明全部处理完成，我们退出循环\\n            n -= 1\\n        return res\\n\"\n        }\n    ]\n},\n\"Rotate-List\":{\n    \"id\": \"61\",\n    \"name\": \"Rotate-List\",\n    \"pre\": [\n        {\n            \"text\": \"求单链表的倒数第 N 个节点\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/61.Rotate-List.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/61.Rotate-List.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public ListNode rotateRight(ListNode head, int k) {\\n        if(head == null || head.next == null) return head;\\n        int count = 0;\\n        ListNode now = head;\\n        while(now != null){\\n            now = now.next;\\n            count++;\\n        }\\n        k = k % count;\\n        ListNode slow = head, fast = head;\\n        while(fast.next != null){\\n            if(k-- <= 0){\\n                slow = slow.next;\\n            }\\n            fast = fast.next;\\n        }\\n        fast.next = head;\\n        ListNode res = slow.next;\\n        slow.next = null;\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n快指针 = head;\\n慢指针 = head;\\nwhile (快指针.next) {\\n  if (N-- <= 0) {\\n    慢指针 = 慢指针.next;\\n  }\\n  快指针 = 快指针.next;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nlet slow = (fast = head);\\nwhile (fast.next) {\\n  if (k-- <= 0) {\\n    slow = slow.next;\\n  }\\n  fast = fast.next;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n  获取链表的长度\\n  k = k % 链表的长度\\n  获取倒数第k + 1,倒数第K个节点与链表尾节点\\n  倒数第k + 1个节点.next = null\\n  链表尾节点.next = head\\n  return 倒数第k个节点\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar rotateRight = function (head, k) {\\n  if (!head || !head.next) return head;\\n  let count = 0,\\n    now = head;\\n  while (now) {\\n    now = now.next;\\n    count++;\\n  }\\n  k = k % count;\\n  let slow = (fast = head);\\n  while (fast.next) {\\n    if (k-- <= 0) {\\n      slow = slow.next;\\n    }\\n    fast = fast.next;\\n  }\\n  fast.next = head;\\n  let res = slow.next;\\n  slow.next = null;\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\n    int getLength(ListNode *head) {\\n        int len = 0;\\n        for (; head; head = head->next, ++len);\\n        return len;\\n    }\\npublic:\\n    ListNode* rotateRight(ListNode* head, int k) {\\n        if (!head) return NULL;\\n        int len = getLength(head);\\n        k %= len;\\n        if (k == 0) return head;\\n        auto p = head, q = head;\\n        while (k--) q = q->next;\\n        while (q->next) {\\n            p = p->next;\\n            q = q->next;\\n        }\\n        auto h = p->next;\\n        q->next = head;\\n        p->next = NULL;\\n        return h;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\\n        # 双指针\\n        if head:\\n            p1 = head\\n            p2 = head\\n            count = 1\\n            i = 0\\n            while i < k:\\n                if p2.next:\\n                    count += 1\\n                    p2 = p2.next\\n                else:\\n                    k = k % count\\n                    i = -1\\n                    p2 = head\\n                i += 1\\n\\n            while p2.next:\\n                p1 = p1.next\\n                p2 = p2.next\\n\\n            if p1.next:\\n                tmp = p1.next\\n            else:\\n                return head\\n            p1.next = None\\n            p2.next = head\\n            return tmp\\n\"\n        }\n    ]\n},\n\"unique-paths\":{\n    \"id\": \"62\",\n    \"name\": \"unique-paths\",\n    \"pre\": [\n        {\n            \"text\": \"排列组合\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"排列组合原理\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"记忆化递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"基本动态规划问题\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"空间复杂度可以进一步优化到O(n),这会是一个考点\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/62.unique-paths.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/62.unique-paths.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=62 lang=javascript\\n *\\n * [62] Unique Paths\\n *\\n * https://leetcode.com/problems/unique-paths/description/\\n */\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar uniquePaths = function (m, n) {\\n  const dp = Array(n).fill(1);\\n\\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      dp[j] = dp[j] + dp[j - 1];\\n    }\\n  }\\n\\n  return dp[n - 1];\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int uniquePaths(int m, int n) {\\n        vector<int> dp(n + 1, 0);\\n        dp[n - 1] = 1;\\n        for (int i = m - 1; i >= 0; --i) {\\n            for (int j = n - 1; j >= 0; --j) dp[j] += dp[j + 1];\\n        }\\n        return dp[0];\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        d = [[1] * n for _ in range(m)]\\n\\n        for col in range(1, m):\\n            for row in range(1, n):\\n                d[col][row] = d[col - 1][row] + d[col][row - 1]\\n\\n        return d[m - 1][n - 1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n\\n    @lru_cache\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        if m == 1 or n == 1:\\n            return 1\\n        return self.uniquePaths(m - 1, n) + self.uniquePaths(m, n - 1)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n\\n    def uniquePaths(self, m: int, n: int) -> int:\\n        dp = [1] * n\\n        for _ in range(1, m):\\n            for j in range(1, n):\\n                dp[j] += dp[j - 1]\\n        return dp[n - 1]\\n\"\n        }\n    ]\n},\n\"unique-paths-ii\":{\n    \"id\": \"63\",\n    \"name\": \"unique-paths-ii\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"记忆化递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"基本动态规划问题\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"空间复杂度可以进一步优化到O(n),这会是一个考点\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/63.unique-paths-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/63.unique-paths-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\\n        int M = obstacleGrid.size(), N = obstacleGrid[0].size();\\n        vector<int> memo(N, 0);\\n        memo[N - 1] = 1;\\n        for (int i = M - 1; i >= 0; --i) {\\n            for (int j = N - 1; j >= 0; --j) {\\n                if (obstacleGrid[i][j] == 1) memo[j] = 0;\\n                else memo[j] += j == N - 1 ? 0 : memo[j + 1];\\n            }\\n        }\\n        return memo[0];\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m = len(obstacleGrid)\\n        if m == 0: return 0\\n        n = len(obstacleGrid[0])\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\\n            if obstacleGrid[i][j] == 1: return 0\\n            if i == 0 and j == 0: return 1\\n            return dfs(i - 1, j) + dfs(i, j - 1)\\n        return dfs(m - 1, n - 1)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m = len(obstacleGrid)\\n        n = len(obstacleGrid[0])\\n        if obstacleGrid[0][0]:\\n            return 0\\n\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        dp[1][1] = 1\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if i == 1 and j == 1:\\n                    continue\\n                if obstacleGrid[i - 1][j - 1] == 0:\\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\\n                else:\\n                    dp[i][j] = 0\\n        return dp[m][n]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\\n        m = len(obstacleGrid)\\n        n = len(obstacleGrid[0])\\n        if obstacleGrid[0][0]:\\n            return 0\\n\\n        dp = [0] * (n + 1)\\n        dp[1] = 1\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if obstacleGrid[i - 1][j - 1] == 0:\\n                    dp[j] += dp[j - 1]\\n                else:\\n                    dp[j] = 0\\n        return dp[-1]\\n\"\n        }\n    ]\n},\n\"plus-one\":{\n    \"id\": \"66\",\n    \"name\": \"plus-one\",\n    \"pre\": [\n        {\n            \"text\": \"数组的遍历(正向遍历和反向遍历)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/66.plus-one.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/66.plus-one.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nfor(int i = n - 1; i > - 1; i --) {\\n  内部逻辑\\n}\\n\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 首先我们要从数组的最后一位开始我们的计算得出我们新的sum\\nsum = arr[arr.length - 1] + 1\\n\\n// 接下来我们需要判断这个新的sum是否超过9\\nsum > 9 ?\\n\\n// 假如大于 9, 那么我们会更新这一位为 0 并且将carry值更改为1\\ncarry = 1\\narr[i] = 0\\n\\n// 假如不大于 9，更新最后一位为sum并直接返回数组\\narr[arr.length - 1] = sum\\nreturn arr\\n\\n// 接着我们要继续向数组的倒数第二位重复进行我们上一步的操作\\n...\\n\\n// 当我们完成以后，如果数组第一位时的sum大于0，那么我们就要给数组的首位增添一个1\\nresult = new array with size of arr.length + 1\\nresult[0] = 1\\nresult[1] ...... result[result.length - 1]  = 0\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar plusOne = function (digits) {\\n  var carry = 1; // 我们将初始的 +1 也当做是一个在个位的 carry\\n  for (var i = digits.length - 1; i > -1; i--) {\\n    if (carry) {\\n      var sum = carry + digits[i];\\n      digits[i] = sum % 10;\\n      carry = sum > 9 ? 1 : 0; // 每次计算都会更新下一步需要用到的 carry\\n    }\\n  }\\n  if (carry === 1) {\\n    digits.unshift(1); // 如果carry最后停留在1，说明有需要额外的一个长度 所以我们就在首位增添一个 1\\n  }\\n  return digits;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& A) {\\n        int i = A.size() - 1, carry = 1;\\n        for (; i >= 0 && carry; --i) {\\n            carry += A[i];\\n            A[i] = carry % 10;\\n            carry /= 10;\\n        }\\n        if (carry) A.insert(begin(A), carry);\\n        return A;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        carry = 1\\n        for i in range(len(digits) - 1, -1, -1):\\n            digits[i], carry = (carry + digits[i]) % 10, (carry + digits[i]) // 10\\n        return [carry] + digits if carry else digits\\n\"\n        }\n    ]\n},\n\"set-matrix-zeroes\":{\n    \"id\": \"73\",\n    \"name\": \"set-matrix-zeroes\",\n    \"pre\": [\n        {\n            \"text\": \"状态压缩\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"使用第一行和第一列来替代我们m+n数组\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"先记录下”第一行和第一列是否全是0“这样的一个数据，否则会因为后续对第一行第一列的更新造成数据丢失\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"最后更新第一行第一列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/73.set-matrix-zeroes.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/73.set-matrix-zeroes.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar setZeroes = function (matrix) {\\n  if (matrix.length === 0) return matrix;\\n  const m = matrix.length;\\n  const n = matrix[0].length;\\n  const zeroes = Array(m + n).fill(false);\\n\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      const item = matrix[i][j];\\n\\n      if (item === 0) {\\n        zeroes[i] = true;\\n        zeroes[m + j] = true;\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < m; i++) {\\n    if (zeroes[i]) {\\n      matrix[i] = Array(n).fill(0);\\n    }\\n  }\\n\\n  for (let i = 0; i < n; i++) {\\n    if (zeroes[m + i]) {\\n      for (let j = 0; j < m; j++) {\\n        matrix[j][i] = 0;\\n      }\\n    }\\n  }\\n\\n  return matrix;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=73 lang=javascript\\n *\\n * [73] Set Matrix Zeroes\\n */\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nvar setZeroes = function (matrix) {\\n  if (matrix.length === 0) return matrix;\\n  const m = matrix.length;\\n  const n = matrix[0].length;\\n\\n  // 时间复杂度 O(m * n), 空间复杂度 O(1)\\n  let firstRow = false; // 第一行是否应该全部为0\\n  let firstCol = false; // 第一列是否应该全部为0\\n\\n  for (let i = 0; i < m; i++) {\\n    for (let j = 0; j < n; j++) {\\n      const item = matrix[i][j];\\n      if (item === 0) {\\n        if (i === 0) {\\n          firstRow = true;\\n        }\\n        if (j === 0) {\\n          firstCol = true;\\n        }\\n        matrix[0][j] = 0;\\n        matrix[i][0] = 0;\\n      }\\n    }\\n  }\\n\\n  for (let i = 1; i < m; i++) {\\n    for (let j = 1; j < n; j++) {\\n      const item = matrix[i][j];\\n      if (matrix[0][j] == 0 || matrix[i][0] == 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // 最后处理第一行和第一列\\n\\n  if (firstRow) {\\n    for (let i = 0; i < n; i++) {\\n      matrix[0][i] = 0;\\n    }\\n  }\\n\\n  if (firstCol) {\\n    for (let i = 0; i < m; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n\\n  return matrix;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify matrix in-place instead.\\n        \\\"\\\"\\\"\\n        def setRowZeros(matrix: List[List[int]], i:int) -> None:\\n            C = len(matrix[0])\\n            matrix[i] = [0] * C\\n\\n        def setColZeros(matrix: List[List[int]], j:int) -> None:\\n            R = len(matrix)\\n            for i in range(R):\\n                matrix[i][j] = 0\\n\\n        isCol = False\\n        R = len(matrix)\\n        C = len(matrix[0])\\n\\n        for i in range(R):\\n            if matrix[i][0] == 0:\\n                isCol = True\\n            for j in range(1, C):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = 0\\n                    matrix[0][j] = 0\\n        for j in range(1, C):\\n            if matrix[0][j] == 0:\\n                setColZeros(matrix, j)\\n\\n        for i in range(R):\\n            if matrix[i][0] == 0:\\n                setRowZeros(matrix, i)\\n\\n        if isCol:\\n            setColZeros(matrix, 0)\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \\\"\\\"\\\"\\n        这题要解决的问题是，必须有个地方记录判断结果，但又不能影响下一步的判断条件；\\n        直接改为0的话，会影响下一步的判断条件；\\n        因此，有一种思路是先改为None，最后再将None改为0；\\n        从条件上看，如果可以将第一行、第二行作为记录空间，那么，用None应该也不算违背题目条件；\\n        \\\"\\\"\\\"\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        # 遍历矩阵，用None记录要改的地方，注意如果是0则要保留，否则会影响下一步判断\\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] is not None and matrix[r][c] == 0:\\n                    # 改值\\n                    for i in range(rows):\\n                        matrix[i][c] = None if matrix[i][c] != 0 else 0\\n                    for j in range(cols):\\n                        matrix[r][j] = None if matrix[r][j] != 0 else 0\\n        # 再次遍历，将None改为0\\n        for r in range(rows):\\n            for c in range(cols):\\n                if matrix[r][c] is None:\\n                    matrix[r][c] = 0\\n\"\n        }\n    ]\n},\n\"sort-colors\":{\n    \"id\": \"75\",\n    \"name\": \"sort-colors\",\n    \"pre\": [\n        {\n            \"text\": \"荷兰国旗问题\",\n            \"link\": \"https://en.wikipedia.org/wiki/Dutch_national_flag_problem\",\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"荷兰国旗问题\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"countingsort\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/75.sort-colors.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/75.sort-colors.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        int r = 0, g = 0, b = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                nums[b++] = 2;\\n                nums[g++] = 1;\\n                nums[r++] = 0;\\n            } else if (n == 1) {\\n                nums[b++] = 2;\\n                nums[g++] = 1;\\n            } else nums[b++] = 2;\\n        }\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        p0 = cur = 0\\n        p2 = len(nums) - 1\\n\\n        while cur <= p2:\\n            if nums[cur] == 0:\\n                nums[cur], nums[p0] = nums[p0], nums[cur]\\n                p0 += 1\\n                cur += 1\\n            elif nums[cur] == 2:\\n                nums[cur], nums[p2] = nums[p2], nums[cur]\\n                p2 -= 1\\n            else:\\n                cur += 1\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        l1 = cur = head\\n        while cur:\\n            if cur.val < x:\\n                cur.val, l1.val = l1.val, cur.val\\n                l1 = l1.next\\n            cur = cur.next\\n        return head\\n\"\n        }\n    ]\n},\n\"subsets\":{\n    \"id\": \"78\",\n    \"name\": \"subsets\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/backtrack.md\",\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"backtrack解题公式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/78.subsets.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/78.subsets.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    // 结果\\n    List<List<Integer>> res = new ArrayList();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        backtrack(nums, 0, new ArrayList<Integer>());\\n        return res;\\n    }\\n\\n    public void backtrack(int[] nums, int start, ArrayList<Integer> track)\\n    {\\n        // 注意：深拷贝\\n        res.add(new ArrayList(track));\\n        for(int i=start; i<nums.length;i++)\\n        {\\n            // 做选择\\n            track.add(nums[i]);\\n            // 回溯\\n            backtrack(nums, i+1, track);\\n            // 撤销选择\\n            track.remove(track.size()-1);\\n        }\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction backtrack(list, tempList, nums, start) {\\n  list.push([...tempList]);\\n  for (let i = start; i < nums.length; i++) {\\n    tempList.push(nums[i]);\\n    backtrack(list, tempList, nums, i + 1);\\n    tempList.pop();\\n  }\\n}\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function (nums) {\\n  const list = [];\\n  backtrack(list, [], nums, 0);\\n  return list;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def subsets(self, nums):\\n        self.res = []\\n        self.track = []\\n        self.backtrack(nums, 0, self.track)\\n\\n        return self.res\\n\\n    def backtrack(self, nums, start, track):\\n        # 注意深拷贝\\n        self.res.append(list(self.track))\\n        for i in range(start, len(nums)):\\n            # 做选择\\n            self.track.append(nums[i])\\n            # 回溯\\n            self.backtrack(nums, i+1, self.track)\\n            # 撤销选择\\n            self.track.pop()\\n\"\n        }\n    ]\n},\n\"word-search\":{\n    \"id\": \"79\",\n    \"name\": \"word-search\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"遍历二维数组的每一个点，找到起始点相同的字符，做DFS\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"DFS过程中，要记录已经访问过的节点，防止重复遍历，这里（JavaCode中）用`*`表示当前已经访问过，也可以用Set或者是boolean[][]数组记录访问过的节点位置。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"是否匹配当前单词中的字符，不符合回溯，这里记得把当前`*`重新设为当前字符。如果用Set或者是boolean[][]数组，记得把当前位置重设为没有访问过。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/79.word-search.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/79.word-search.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic class LC79WordSearch {\\n  public boolean exist(char[][] board, String word) {\\n    if (board == null || word == null) return false;\\n    if (word.length() == 0) return true;\\n    if (board.length == 0) return false;\\n    int rows = board.length;\\n    int cols = board[0].length;\\n    for (int r = 0; r < rows; r++) {\\n      for (int c = 0; c < cols; c++) {\\n        // scan board, start with word first character\\n        if (board[r][c] == word.charAt(0)) {\\n          if (helper(board, word, r, c, 0)) {\\n            return true;\\n          }\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  private boolean helper(char[][] board, String word, int r, int c, int start) {\\n    // already match word all characters, return true\\n    if (start == word.length()) return true;\\n    if (!isValid(board, r, c) ||\\n        board[r][c] != word.charAt(start)) return false;\\n    // mark visited\\n    board[r][c] = '*';\\n    boolean res = helper(board, word, r - 1, c, start + 1) // 上\\n        ||  helper(board, word, r + 1, c, start + 1)       // 下\\n        ||  helper(board, word, r, c - 1, start + 1)       // 左\\n        ||  helper(board, word, r, c + 1, start + 1);      // 右\\n    // backtracking to start position\\n    board[r][c] = word.charAt(start);\\n    return res;\\n  }\\n\\n  private boolean isValid(char[][] board, int r, int c) {\\n    return r >= 0 && r < board.length && c >= 0 && c < board[0].length;\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=79 lang=javascript\\n *\\n * [79] Word Search\\n */\\nfunction DFS(board, row, col, rows, cols, word, cur) {\\n  // 边界检查\\n  if (row >= rows || row < 0) return false;\\n  if (col >= cols || col < 0) return false;\\n\\n  const item = board[row][col];\\n\\n  if (item !== word[cur]) return false;\\n\\n  if (cur + 1 === word.length) return true;\\n\\n  // 如果你用hashmap记录访问的字母， 那么你需要每次backtrack的时候手动清除hashmap，并且需要额外的空间\\n  // 这里我们使用一个little trick\\n\\n  board[row][col] = null;\\n\\n  // 上下左右\\n  const res =\\n    DFS(board, row + 1, col, rows, cols, word, cur + 1) ||\\n    DFS(board, row - 1, col, rows, cols, word, cur + 1) ||\\n    DFS(board, row, col - 1, rows, cols, word, cur + 1) ||\\n    DFS(board, row, col + 1, rows, cols, word, cur + 1);\\n\\n  board[row][col] = item;\\n\\n  return res;\\n}\\n/**\\n * @param {character[][]} board\\n * @param {string} word\\n * @return {boolean}\\n */\\nvar exist = function (board, word) {\\n  if (word.length === 0) return true;\\n  if (board.length === 0) return false;\\n\\n  const rows = board.length;\\n  const cols = board[0].length;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      const hit = DFS(board, i, j, rows, cols, word, 0);\\n      if (hit) return true;\\n    }\\n  }\\n  return false;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def exist(self, board: List[List[str]], word: str) -> bool:\\n        m = len(board)\\n        n = len(board[0])\\n\\n        def dfs(board, r, c, word, index):\\n            if index == len(word):\\n                return True\\n            if r < 0 or r >= m or c < 0 or c >= n or board[r][c] != word[index]:\\n                return False\\n            board[r][c] = '*'\\n            res = dfs(board, r - 1, c, word, index + 1) or dfs(board, r + 1, c, word, index + 1) or dfs(board, r, c - 1, word, index + 1) or dfs(board, r, c + 1, word, index + 1)\\n            board[r][c] = word[index]\\n            return res\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == word[0]:\\n                    if dfs(board, r, c, word, 0):\\n                        return True\\n\"\n        }\n    ]\n},\n\"remove-duplicates-from-sorted-array-ii\":{\n    \"id\": \"80\",\n    \"name\": \"remove-duplicates-from-sorted-array-ii\",\n    \"pre\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"快慢指针\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"读写指针\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"删除排序问题\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/80.remove-duplicates-from-sorted-array-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/80.remove-duplicates-from-sorted-array-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int removeDuplicates(vector<int>& A) {\\n        int j = 0;\\n        for (int i = 0; i < A.size(); ++i) {\\n            if (j - 2 < 0 || A[j - 2] != A[i]) A[j++] = A[i];\\n        }\\n        return j;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        # 写指针\\n        i = 0\\n        K = 2\\n        for num in nums:\\n            if i < K or num != nums[i-K]:\\n                nums[i] = num\\n                i += 1\\n        return i\\n\"\n        }\n    ]\n},\n\"largest-rectangle-in-histogram\":{\n    \"id\": \"84\",\n    \"name\": \"largest-rectangle-in-histogram\",\n    \"pre\": [\n        {\n            \"text\": \"单调栈\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/84.largest-rectangle-in-histogram.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/84.largest-rectangle-in-histogram.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& A) {\\n        A.push_back(0);\\n        int N = A.size(), ans = 0;\\n        stack<int> s;\\n        for (int i = 0; i < N; ++i) {\\n            while (s.size() && A[s.top()] >= A[i]) {\\n                int h = A[s.top()];\\n                s.pop();\\n                int j = s.size() ? s.top() : -1;\\n                ans = max(ans, h * (i - j - 1));\\n            }\\n            s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n, ans = len(heights), 0\\n        if n != 0:\\n            ans = heights[0]\\n        for i in range(n):\\n            height = heights[i]\\n            for j in range(i, n):\\n                height = min(height, heights[j])\\n                ans = max(ans, (j - i + 1) * height)\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        l, r, ans = [-1] * n, [n] * n, 0\\n        for i in range(1, n):\\n            j = i - 1\\n            while j >= 0 and heights[j] >= heights[i]:\\n                j -= 1\\n            l[i] = j\\n        for i in range(n - 2, -1, -1):\\n            j = i + 1\\n            while j < n and heights[j] >= heights[i]:\\n                j += 1\\n            r[i] = j\\n        for i in range(n):\\n            ans = max(ans, heights[i] * (r[i] - l[i] - 1))\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n = len(heights)\\n        l, r, ans = [-1] * n, [n] * n, 0\\n\\n        for i in range(1, n):\\n            j = i - 1\\n            while j >= 0 and heights[j] >= heights[i]:\\n                j = l[j]\\n            l[i] = j\\n        for i in range(n - 2, -1, -1):\\n            j = i + 1\\n            while j < n and heights[j] >= heights[i]:\\n                j = r[j]\\n            r[i] = j\\n        for i in range(n):\\n            ans = max(ans, heights[i] * (r[i] - l[i] - 1))\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n, heights, st, ans = len(heights), [0] + heights + [0], [], 0\\n        for i in range(n + 2):\\n            while st and heights[st[-1]] > heights[i]:\\n                ans = max(ans, heights[st.pop(-1)] * (i - st[-1] - 1))\\n            st.append(i)\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n, heights, st, ans = len(heights),[0] + heights + [0], [], 0\\n        for i in range(n + 2):\\n            while st and heights[st[-1]] > heights[i]:\\n                a = heights[st[-1]]\\n                st.pop()\\n                # 如果没有前面的哨兵，这里的 st[-1] 可能会越界。\\n                ans = max(ans, a * (i - 1 - st[-1]))\\n            st.append(i)\\n        return ans\\n\"\n        }\n    ]\n},\n\"maximal-rectangle\":{\n    \"id\": \"85\",\n    \"name\": \"maximal-rectangle\",\n    \"pre\": [\n        {\n            \"text\": \"单调栈\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/85.maximal-rectangle.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/85.maximal-rectangle.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int maximalRectangle(vector<vector<char>>& A) {\\n        if (A.empty() || A[0].empty()) return 0;\\n        int ans = 0, M = A.size(), N = A[0].size();\\n        vector<int> left(N, 0), right(N, N), height(N, 0);\\n        for (int i = 0; i < M; ++i) {\\n            int curLeft = 0, curRight = N;\\n            for (int j = 0; j < N; ++j) height[j] = A[i][j] == '1' ? height[j] + 1 : 0;\\n            for (int j = 0; j < N; ++j) {\\n                if (A[i][j] == '1') left[j] = max(left[j], curLeft);\\n                else {\\n                    left[j] = 0;\\n                    curLeft = j + 1;\\n                }\\n            }\\n            for (int j = N - 1; j >= 0; --j) {\\n                if (A[i][j] == '1') right[j] = min(right[j], curRight);\\n                else {\\n                    right[j] = N;\\n                    curRight = j;\\n                }\\n            }\\n            for (int j = 0; j < N; ++j) ans = max(ans, (right[j] - left[j]) * height[j]);\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def largestRectangleArea(self, heights: List[int]) -> int:\\n        n, heights, st, ans = len(heights), [0] + heights + [0], [], 0\\n        for i in range(n + 2):\\n            while st and heights[st[-1]] > heights[i]:\\n                ans = max(ans, heights[st.pop(-1)] * (i - st[-1] - 1))\\n            st.append(i)\\n\\n        return ans\\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\\n        m = len(matrix)\\n        if m == 0: return 0\\n        n = len(matrix[0])\\n        heights = [0] * n\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == \\\"0\\\":\\n                    heights[j] = 0\\n                else:\\n                    heights[j] += 1\\n            ans = max(ans, self.largestRectangleArea(heights))\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"partition-list\":{\n    \"id\": \"86\",\n    \"name\": \"partition-list\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"链表的基本操作（遍历）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"虚拟节点dummy简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"遍历完成之后记得`currentL1.next=null;`否则会内存溢出>如果单纯的遍历是不需要上面操作的，但是我们的遍历会导致currentL1.next和currentL2.next>中有且仅有一个不是null，如果不这么操作的话会导致两个链表成环，造成溢出。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/86.partition-list.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/86.partition-list.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {ListNode} head\\n * @param {number} x\\n * @return {ListNode}\\n */\\nvar partition = function (head, x) {\\n  const dummyHead1 = {\\n    next: null,\\n  };\\n  const dummyHead2 = {\\n    next: null,\\n  };\\n\\n  let current = {\\n    next: head,\\n  };\\n  let currentL1 = dummyHead1;\\n  let currentL2 = dummyHead2;\\n  while (current.next) {\\n    current = current.next;\\n    if (current.val < x) {\\n      currentL1.next = current;\\n      currentL1 = current;\\n    } else {\\n      currentL2.next = current;\\n      currentL2 = current;\\n    }\\n  }\\n\\n  currentL2.next = null;\\n\\n  currentL1.next = dummyHead2.next;\\n\\n  return dummyHead1.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    ListNode* partition(ListNode* head, int x) {\\n        ListNode dummy, geHead, *ltTail = &dummy, *geTail = &geHead;\\n        while (head) {\\n            auto p = head;\\n            head = head->next;\\n            if (p->val < x) {\\n                ltTail->next = p;\\n                ltTail = p;\\n            } else {\\n                geTail->next = p;\\n                geTail = p;\\n            }\\n        }\\n        ltTail->next = geHead.next;\\n        geTail->next = NULL;\\n        return dummy.next;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def partition(self, head: ListNode, x: int) -> ListNode:\\n        \\\"\\\"\\\"在原链表操作，思路基本一致，只是通过指针进行区分而已\\\"\\\"\\\"\\n        # 在链表最前面设定一个初始node作为锚点，方便返回最后的结果\\n        first_node = ListNode(0)\\n        first_node.next = head\\n        # 设计三个指针，一个指向小于x的最后一个节点，即前后分离点\\n        # 一个指向当前遍历节点的前一个节点\\n        # 一个指向当前遍历的节点\\n        sep_node = first_node\\n        pre_node = first_node\\n        current_node = head\\n\\n        while current_node is not None:\\n            if current_node.val < x:\\n                # 注意有可能出现前一个节点就是分离节点的情况\\n                if pre_node is sep_node:\\n                    pre_node = current_node\\n                    sep_node = current_node\\n                    current_node = current_node.next\\n                else:\\n                    # 这段次序比较烧脑\\n                    pre_node.next = current_node.next\\n                    current_node.next = sep_node.next\\n                    sep_node.next = current_node\\n                    sep_node = current_node\\n                    current_node = pre_node.next\\n            else:\\n                pre_node = current_node\\n                current_node = pre_node.next\\n\\n        return first_node.next\\n\"\n        }\n    ]\n},\n\"merge-sorted-array\":{\n    \"id\": \"88\",\n    \"name\": \"merge-sorted-array\",\n    \"pre\": [\n        {\n            \"text\": \"归并排序\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"从后往前比较，并从后往前插入，这样可避免写指针影响，同时将空间复杂度降低到$O(1)$\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"loomberg\"\n        },\n        {\n            \"name\": \"facebook\"\n        },\n        {\n            \"name\": \"microsoft\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/88.merge-sorted-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/88.merge-sorted-array.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\\n        int i=m-1, j=n-1, k=m+n-1;\\n        // 合并\\n        while(i>=0 && j>=0)\\n        {\\n            if(nums1[i] > nums2[j])\\n            {\\n                nums1[k--] = nums1[i--];\\n            }\\n            else\\n            {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n        // 合并剩余的nums2\\n        while(j>=0)\\n        {\\n            nums1[k--] = nums2[j--];\\n        }\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 这种解法连m都用不到\\n// 这显然不是出题人的意思\\nif (n === 0) return;\\nlet current2 = 0;\\nfor (let i = nums1.length - 1; i >= nums1.length - n; i--) {\\n  nums1[i] = nums2[current2++];\\n}\\nnums1.sort((a, b) => a - b); // 当然你可以自己写排序，这里懒得写了，因为已经偏离了题目本身\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 将nums1 和 nums2 合并\\nfunction merge(nums1, nums2) {\\n  let ret = [];\\n  while (nums1.length || nums2.length) {\\n    // 为了方便大家理解，这里代码有点赘余\\n    if (nums1.length === 0) {\\n      ret.push(nums2.shift());\\n      continue;\\n    }\\n\\n    if (nums2.length === 0) {\\n      ret.push(nums1.shift());\\n      continue;\\n    }\\n    const a = nums1[0];\\n    const b = nums2[0];\\n    if (a > b) {\\n      ret.push(nums2.shift());\\n    } else {\\n      ret.push(nums1.shift());\\n    }\\n  }\\n  return ret;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar merge = function (nums1, m, nums2, n) {\\n  // 设置一个指针，指针初始化指向nums1的末尾（根据#62，应该是index为 m+n-1 的位置，因为nums1的长度有可能更长）\\n  // 然后不断左移指针更新元素\\n  let current = m + n - 1;\\n\\n  while (current >= 0) {\\n    // 没必要继续了\\n    if (n === 0) return;\\n\\n    // 为了方便大家理解，这里代码有点赘余\\n    if (m < 1) {\\n      nums1[current--] = nums2[--n];\\n      continue;\\n    }\\n\\n    if (n < 1) {\\n      nums1[current--] = nums1[--m];\\n      continue;\\n    }\\n    // 取大的填充 nums1的末尾\\n    // 然后更新 m 或者 n\\n    if (nums1[m - 1] > nums2[n - 1]) {\\n      nums1[current--] = nums1[--m];\\n    } else {\\n      nums1[current--] = nums2[--n];\\n    }\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify nums1 in-place instead.\\n        \\\"\\\"\\\"\\n        pos = m + n - 1\\n        while m > 0 and n > 0:\\n            if nums1[m - 1] < nums2[n - 1]:\\n                nums1[pos] = nums2[n - 1]\\n                n -= 1\\n            else:\\n                nums1[pos] = nums1[m - 1]\\n                m -= 1\\n            pos -= 1\\n        while n > 0:\\n            nums1[pos] = nums2[n - 1]\\n            n -= 1\\n            pos -= 1\\n\\n\"\n        }\n    ]\n},\n\"subsets-ii\":{\n    \"id\": \"90\",\n    \"name\": \"subsets-ii\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"backtrack解题公式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/90.subsets-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/90.subsets-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction backtrack(list, tempList, nums, start) {\\n  list.push([...tempList]);\\n  for (let i = start; i < nums.length; i++) {\\n    // 和78.subsets的区别在于这道题nums可以有重复\\n    // 因此需要过滤这种情况\\n    if (i > start && nums[i] === nums[i - 1]) continue;\\n    tempList.push(nums[i]);\\n    backtrack(list, tempList, nums, i + 1);\\n    tempList.pop();\\n  }\\n}\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsetsWithDup = function (nums) {\\n  const list = [];\\n  backtrack(\\n    list,\\n    [],\\n    nums.sort((a, b) => a - b),\\n    0,\\n    []\\n  );\\n  return list;\\n};\\n\"\n        }\n    ]\n},\n\"decode-ways\":{\n    \"id\": \"91\",\n    \"name\": \"decode-ways\",\n    \"pre\": [\n        {\n            \"text\": \"爬楼梯问题\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"爬楼梯问题（我把这种题目统称为爬楼梯问题）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/91.decode-ways.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/91.decode-ways.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar numDecodings = function (s) {\\n  if (s == null || s.length == 0) {\\n    return 0;\\n  }\\n  const dp = Array(s.length + 1).fill(0);\\n  dp[0] = 1;\\n  dp[1] = s[0] !== \\\"0\\\" ? 1 : 0;\\n  for (let i = 2; i < s.length + 1; i++) {\\n    const one = +s.slice(i - 1, i);\\n    const two = +s.slice(i - 2, i);\\n\\n    if (two >= 10 && two <= 26) {\\n      dp[i] = dp[i - 2];\\n    }\\n\\n    if (one >= 1 && one <= 9) {\\n      dp[i] += dp[i - 1];\\n    }\\n  }\\n\\n  return dp[dp.length - 1];\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n  int numDecodings(string s) {\\n    int pre2 = 0, pre1 = 1;\\n    for (int i = 0; i < s.size() && pre1; ++i) {\\n      int cur = 0;\\n      if (s[i] != '0') cur += pre1;\\n      if (i != 0 && s[i - 1] != '0' && (s[i - 1] - '0') * 10 + s[i] - '0' <= 26)\\n        cur += pre2;\\n      pre2 = pre1;\\n      pre1 = cur;\\n    }\\n    return pre1;\\n  }\\n};\\n\"\n        }\n    ]\n},\n\"reverse-linked-list-ii\":{\n    \"id\": \"92\",\n    \"name\": \"reverse-linked-list-ii\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"四点法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"链表的基本操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"考虑特殊情况m是1或者n是链表长度的情况，我们可以采用虚拟节点dummy简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"用四个变量记录特殊节点，然后操作这四个节点使之按照一定方式连接即可。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"注意更新current和pre的位置，否则有可能出现溢出\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/92.reverse-linked-list-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/92.reverse-linked-list-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=92 lang=javascript\\n *\\n * [92] Reverse Linked List II\\n *\\n * https://leetcode.com/problems/reverse-linked-list-ii/description/\\n */\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} m\\n * @param {number} n\\n * @return {ListNode}\\n */\\nvar reverseBetween = function (head, m, n) {\\n  // 虚拟节点，简化操作\\n  const dummyHead = {\\n    next: head,\\n  };\\n\\n  let cur = dummyHead.next; // 当前遍历的节点\\n  let pre = cur; // 因为要反转，因此我们需要记住前一个节点\\n  let index = 0; // 链表索引，用来判断是否是特殊位置（头尾位置）\\n\\n  // 上面提到的四个特殊节点\\n  let p1 = (p2 = p3 = p4 = null);\\n\\n  while (cur) {\\n    const next = cur.next;\\n    index++;\\n\\n    // 对 (m - n) 范围内的节点进行反转\\n    if (index > m && index <= n) {\\n      cur.next = pre;\\n    }\\n\\n    // 下面四个if都是边界, 用于更新四个特殊节点的值\\n    if (index === m - 1) {\\n      p1 = cur;\\n    }\\n    if (index === m) {\\n      p2 = cur;\\n    }\\n\\n    if (index === n) {\\n      p3 = cur;\\n    }\\n\\n    if (index === n + 1) {\\n      p4 = cur;\\n    }\\n\\n    pre = cur;\\n\\n    cur = next;\\n  }\\n\\n  // 两个链表合并起来\\n  (p1 || dummyHead).next = p3; // 特殊情况需要考虑\\n  p2.next = p4;\\n\\n  return dummyHead.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n        pre = None\\n        cur = head\\n        i = 0\\n        p1 = p2 = p3 = p4 = None\\n        # 一坨逻辑\\n        if p1:\\n            p1.next = p3\\n        else:\\n            dummy.next = p3\\n        if p2:\\n            p2.next = p4\\n        return head\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n   def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\\n       pre = None\\n       cur = head\\n       i = 0\\n       p1 = p2 = p3 = p4 = None\\n       dummy = ListNode(0)\\n       dummy.next = head\\n       # 一坨逻辑\\n       if p1:\\n           p1.next = p3\\n       else:\\n           dummy.next = p3\\n       if p2:\\n           p2.next = p4\\n\\n       return dummy.next\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n    while cur:\\n           i += 1\\n           if i == m - 1:\\n               p1 = cur\\n           next = cur.next\\n           if m < i <= n:\\n               cur.next = pre\\n\\n           if i == m:\\n               p2 = cur\\n               p2.next = None\\n\\n           if i == n:\\n               p3 = cur\\n\\n           if i == n + 1:\\n               p4 = cur\\n\\n           pre = cur\\n           cur = next\\n\"\n        }\n    ]\n},\n\"binary-tree-inorder-traversal\":{\n    \"id\": \"94\",\n    \"name\": \"binary-tree-inorder-traversal\",\n    \"pre\": [\n        {\n            \"text\": \"二叉树\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二叉树的基本操作（遍历）>不同的遍历算法差异还是蛮大的\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果非递归的话利用栈来简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果数据规模不大的话，建议使用递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"递归的问题需要注意两点，一个是终止条件，一个如何缩小规模1.终止条件，自然是当前这个元素是null（链表也是一样）2.由于二叉树本身就是一个递归结构，每次处理一个子树其实就是缩小了规模，难点在于如何合并结果，这里的合并结果其实就是`left.concat(mid).concat(right)`,mid是一个具体的节点，left和right`递归求出即可`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/94.binary-tree-inorder-traversal.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/94.binary-tree-inorder-traversal.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    List<Integer> res = new LinkedList<>();\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        inorder(root);\\n        return res;\\n    }\\n\\n    public void inorder (TreeNode root) {\\n        if (root == null) return;\\n\\n        inorder(root.left);\\n\\n        res.add(root.val);\\n\\n        inorder(root.right);\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<> ();\\n        Stack<TreeNode> stack = new Stack<> ();\\n\\n        while (root != null || !stack.isEmpty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            res.add(root.val);\\n            root = root.right;\\n        }\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar inorderTraversal = function (root) {\\n  // 1. Recursive solution\\n  // if (!root) return [];\\n  // const left = root.left ? inorderTraversal(root.left) : [];\\n  // const right = root.right ? inorderTraversal(root.right) : [];\\n  // return left.concat([root.val]).concat(right);\\n\\n  // 2. iterative solutuon\\n  if (!root) return [];\\n  const stack = [root];\\n  const ret = [];\\n  let left = root.left;\\n\\n  let item = null; // stack 中弹出的当前项\\n\\n  while (left) {\\n    stack.push(left);\\n    left = left.left;\\n  }\\n\\n  while ((item = stack.pop())) {\\n    ret.push(item.val);\\n    let t = item.right;\\n\\n    while (t) {\\n      stack.push(t);\\n      t = t.left;\\n    }\\n  }\\n\\n  return ret;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<TreeNode*> s;\\n        vector<int> v;\\n        while (root != NULL || !s.empty()) {\\n            for (; root != NULL; root = root->left)\\n                s.push_back(root);\\n            v.push_back(s.back()->val);\\n            root = s.back()->right;\\n            s.pop_back();\\n        }\\n        return v;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"unique-binary-search-trees-ii\":{\n    \"id\": \"95\",\n    \"name\": \"unique-binary-search-trees-ii\",\n    \"pre\": [\n        {\n            \"text\": \"二叉搜索树\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分治法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/95.unique-binary-search-trees-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/95.unique-binary-search-trees-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n    vector<TreeNode*> generateTrees(int first, int last) {\\n        if (first > last) return { NULL };\\n        vector<TreeNode*> v;\\n        for (int i = first; i <= last; ++i) {\\n            auto lefts = generateTrees(first, i - 1);\\n            auto rights = generateTrees(i + 1, last);\\n            for (auto left : lefts) {\\n                for (auto right : rights) {\\n                    v.push_back(new TreeNode(i));\\n                    v.back()->left = left;\\n                    v.back()->right = right;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\npublic:\\n    vector<TreeNode*> generateTrees(int n) {\\n        if (n <= 0) return {};\\n        return generateTrees(1, n);\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"unique-binary-search-trees\":{\n    \"id\": \"96\",\n    \"name\": \"unique-binary-search-trees\",\n    \"pre\": [\n        {\n            \"text\": \"二叉搜索树\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分治法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"笛卡尔积\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"记忆化递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/96.unique-binary-search-trees.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/96.unique-binary-search-trees.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\n    vector<int> visited;\\n    int dp(int n) {\\n        if (visited[n]) return visited[n];\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) ans += dp(i) * dp(n - i - 1);\\n        return visited[n] = ans;\\n    }\\npublic:\\n    int numTrees(int n) {\\n        visited.assign(n + 1, 0);\\n        visited[0] = 1;\\n        return dp(n);\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def numTrees(self, n: int) -> int:\\n        if n <= 1:\\n            return 1\\n        res = 0\\n        for i in range(1, n + 1):\\n            res += self.numTrees(i - 1) * self.numTrees(n - i)\\n        return res\\n\"\n        }\n    ]\n},\n\"validate-binary-search-tree\":{\n    \"id\": \"98\",\n    \"name\": \"validate-binary-search-tree\",\n    \"pre\": [\n        {\n            \"text\": \"中序遍历\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二叉树的基本操作（遍历）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"中序遍历一个二叉查找树（BST）的结果是一个有序数组\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果一个树遍历的结果是有序数组，那么他也是一个二叉查找树(BST)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/98.validate-binary-search-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/98.validate-binary-search-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        Stack<Integer> stack = new Stack<> ();\\n        TreeNode previous = null;\\n\\n        while (root != null || !stack.isEmpty()) {\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            if (previous != null && root.val <= previous.val ) return false;\\n            previous = root;\\n            root = root.right;\\n        }\\n        return true;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, null, null);\\n    }\\n\\n    private boolean helper(TreeNode root, Integer lower, Integer higher) {\\n        if (root == null) return true;\\n\\n        if (lower != null && root.val <= lower) return false;\\n        if (higher != null && root.val >= higher) return false;\\n\\n        if (!helper(root.left, lower, root.val)) return false;\\n        if (!helper(root.right, root.val, higher)) return false;\\n\\n        return true;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=98 lang=javascript\\n *\\n * [98] Validate Binary Search Tree\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function (root) {\\n  if (root === null) return true;\\n  if (root.left === null && root.right === null) return true;\\n  const stack = [root];\\n  let cur = root;\\n  let pre = null;\\n\\n  function insertAllLefts(cur) {\\n    while (cur && cur.left) {\\n      const l = cur.left;\\n      stack.push(l);\\n      cur = l;\\n    }\\n  }\\n  insertAllLefts(cur);\\n\\n  while ((cur = stack.pop())) {\\n    if (pre && cur.val <= pre.val) return false;\\n    const r = cur.right;\\n\\n    if (r) {\\n      stack.push(r);\\n      insertAllLefts(r);\\n    }\\n    pre = cur;\\n  }\\n\\n  return true;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function (root) {\\n  if (!root) return true;\\n  return valid(root);\\n};\\n\\nfunction valid(root, min = -Infinity, max = Infinity) {\\n  if (!root) return true;\\n  const val = root.val;\\n  if (val <= min) return false;\\n  if (val >= max) return false;\\n  return valid(root.left, min, val) && valid(root.right, val, max);\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n// 递归\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return validateBstInorder(root, prev);\\n    }\\n\\nprivate:\\n    bool validateBstInorder(TreeNode* root, TreeNode*& prev) {\\n        if (root == nullptr) return true;\\n        if (!validateBstInorder(root->left, prev)) return false;\\n        if (prev != nullptr && prev->val >= root->val) return false;\\n        prev = root;\\n        return validateBstInorder(root->right, prev);\\n    }\\n};\\n\\n// 迭代\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        auto s = vector<TreeNode*>();\\n        TreeNode* prev = nullptr;\\n        while (root != nullptr || !s.empty()) {\\n            while (root != nullptr) {\\n                s.push_back(root);\\n                root = root->left;\\n            }\\n            root = s.back();\\n            s.pop_back();\\n            if (prev != nullptr && prev->val >= root->val) return false;\\n            prev = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"same-tree\":{\n    \"id\": \"100\",\n    \"name\": \"same-tree\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"层序遍历\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"前中序确定一棵树\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/100.same-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/100.same-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar isSameTree = function (p, q) {\\n  if (!p || !q) {\\n    return !p && !q;\\n  }\\n  return (\\n    p.val === q.val &&\\n    isSameTree(p.left, q.left) &&\\n    isSameTree(p.right, q.right)\\n  );\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar isSameTree = function (p, q) {\\n  let curLevelA = [p];\\n  let curLevelB = [q];\\n\\n  while (curLevelA.length && curLevelB.length) {\\n    let nextLevelA = [];\\n    let nextLevelB = [];\\n    const isOK = isSameCurLevel(curLevelA, curLevelB, nextLevelA, nextLevelB);\\n    if (isOK) {\\n      curLevelA = nextLevelA;\\n      curLevelB = nextLevelB;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n};\\n\\nfunction isSameCurLevel(curLevelA, curLevelB, nextLevelA, nextLevelB) {\\n  if (curLevelA.length !== curLevelB.length) {\\n    return false;\\n  }\\n  for (let i = 0; i < curLevelA.length; i++) {\\n    if (!isSameNode(curLevelA[i], curLevelB[i])) {\\n      return false;\\n    }\\n    curLevelA[i] && nextLevelA.push(curLevelA[i].left, curLevelA[i].right);\\n    curLevelB[i] && nextLevelB.push(curLevelB[i].left, curLevelB[i].right);\\n  }\\n  return true;\\n}\\n\\nfunction isSameNode(nodeA, nodeB) {\\n  if (!nodeA || !nodeB) {\\n    return nodeA === nodeB;\\n  }\\n  return nodeA.val === nodeB.val;\\n  // return nodeA === nodeB || (nodeA && nodeB && nodeA.val === nodeB.val);\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar isSameTree = function (p, q) {\\n  const preorderP = preorder(p, []);\\n  const preorderQ = preorder(q, []);\\n  const inorderP = inorder(p, []);\\n  const inorderQ = inorder(q, []);\\n  return (\\n    preorderP.join(\\\"\\\") === preorderQ.join(\\\"\\\") &&\\n    inorderP.join(\\\"\\\") === inorderQ.join(\\\"\\\")\\n  );\\n};\\n\\nfunction preorder(root, arr) {\\n  if (root === null) {\\n    arr.push(\\\" \\\");\\n    return arr;\\n  }\\n  arr.push(root.val);\\n  preorder(root.left, arr);\\n  preorder(root.right, arr);\\n  return arr;\\n}\\n\\nfunction inorder(root, arr) {\\n  if (root === null) {\\n    arr.push(\\\" \\\");\\n    return arr;\\n  }\\n  inorder(root.left, arr);\\n  arr.push(root.val);\\n  inorder(root.right, arr);\\n  return arr;\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (!p && !q) || (p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        return (!p && !q) || (p && q && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"symmetric-tree\":{\n    \"id\": \"101\",\n    \"name\": \"symmetric-tree\",\n    \"pre\": [\n        {\n            \"text\": \"二叉树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"递归\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"linkedin\"\n        },\n        {\n            \"name\": \"microsoft\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/101.symmetric-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/101.symmetric-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public boolean isSymmetric(TreeNode root) {\\n        if(root == null)\\n        {\\n            return true;\\n        }\\n        else{\\n            return recur(root.left, root.right);\\n        }\\n        // return root == null ? true : recur(root.left, root.right);\\n    }\\n\\n    public boolean recur(TreeNode l, TreeNode r)\\n    {\\n        if(l == null && r==null)\\n        {\\n            return true;\\n        }\\n        // 只存在一个子节点 或者左右不相等\\n        if(l==null || r==null || l.val != r.val)\\n        {\\n            return false;\\n        }\\n\\n        return recur(l.left, r.right) && recur(l.right, r.left);\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        return root==NULL?true:recur(root->left, root->right);\\n    }\\n\\n    bool recur(TreeNode* l, TreeNode* r)\\n    {\\n        if(l == NULL && r==NULL)\\n        {\\n            return true;\\n        }\\n        // 只存在一个子节点 或者左右不相等\\n        if(l==NULL || r==NULL || l->val != r->val)\\n        {\\n            return false;\\n        }\\n\\n        return recur(l->left, r->right) && recur(l->right, r->left);\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nseen = dict()\\nfor i, num in enumerate(nums):\\n    seen[i] = num\\nfor i, num in enumerate(nums):\\n    if  seen[len(nums) - 1 - i] != num:\\n      return False\\nreturn True\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nl = 0\\nr = len(nums) - 1\\n\\nwhile l < r:\\n   if nums[l] != nums[r]: return False\\n   l += 1\\n   r -= 1\\nreturn True\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def isSymmetric(self, root: TreeNode) -> bool:\\n        def dfs(root1, root2):\\n            if root1 == root2 == None: return True\\n            if not root1 or not root2: return False\\n            if root1.val != root2.val: return False\\n            return dfs(root1.left, root2.right) and dfs(root1.right, root2.left)\\n        if not root: return True\\n        return dfs(root.left, root.right)\\n\"\n        }\n    ]\n},\n\"binary-tree-level-order-traversal\":{\n    \"id\": \"102\",\n    \"name\": \"binary-tree-level-order-traversal\",\n    \"pre\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"队列中用Null(一个特殊元素)来划分每层\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"树的基本操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"层次遍历（BFS）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"注意塞入null的时候，判断一下当前队列是否为空，不然会无限循环\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/102.binary-tree-level-order-traversal.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/102.binary-tree-level-order-traversal.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {TreeNode} root\\n * @return {number[][]}\\n */\\nvar levelOrder = function (root) {\\n  if (!root) return [];\\n  const items = []; // 存放所有节点\\n  const queue = [root, null]; // null 简化操作\\n  let levelNodes = []; // 存放每一层的节点\\n\\n  while (queue.length > 0) {\\n    const t = queue.shift();\\n\\n    if (t) {\\n      levelNodes.push(t.val);\\n      if (t.left) {\\n        queue.push(t.left);\\n      }\\n      if (t.right) {\\n        queue.push(t.right);\\n      }\\n    } else {\\n      // 一层已经遍历完了\\n      items.push(levelNodes);\\n      levelNodes = [];\\n      if (queue.length > 0) {\\n        queue.push(null);\\n      }\\n    }\\n  }\\n\\n  return items;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\\n        \\\"\\\"\\\"递归法\\\"\\\"\\\"\\n        if root is None:\\n            return []\\n\\n        result = []\\n\\n        def add_to_result(level, node):\\n            \\\"\\\"\\\"递归函数\\n            :param level int 当前在二叉树的层次\\n            :param node TreeNode 当前节点\\n            \\\"\\\"\\\"\\n            if level > len(result) - 1:\\n                result.append([])\\n\\n            result[level].append(node.val)\\n            if node.left:\\n                add_to_result(level+1, node.left)\\n            if node.right:\\n                add_to_result(level+1, node.right)\\n\\n        add_to_result(0, root)\\n        return result\\n\"\n        }\n    ]\n},\n\"binary-tree-zigzag-level-order-traversal\":{\n    \"id\": \"103\",\n    \"name\": \"binary-tree-zigzag-level-order-traversal\",\n    \"pre\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"队列中用Null(一个特殊元素)来划分每层\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"树的基本操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"层次遍历（BFS）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/103.binary-tree-zigzag-level-order-traversal.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/103.binary-tree-zigzag-level-order-traversal.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {TreeNode} root\\n * @return {number[][]}\\n */\\nvar zigzagLevelOrder = function(root) {\\n  if (!root) return [];   \\n  const items = [];\\n  let isOdd = true;\\n  let levelNodes = [];\\n  \\n  const queue = [root, null];\\n\\n\\n  while(queue.length > 0) {\\n      const t = queue.shift();\\n\\n      if (t) {\\n          levelNodes.push(t.val)\\n          if (t.left) {\\n            queue.push(t.left)\\n          }\\n          if (t.right) {\\n            queue.push(t.right)\\n          }\\n      } else {\\n        if (!isOdd) {\\n          levelNodes = levelNodes.reverse();\\n        }\\n        items.push(levelNodes)\\n        levelNodes = [];\\n        isOdd = !isOdd;\\n        if (queue.length > 0) {\\n            queue.push(null);\\n        }\\n      }\\n  }\\n\\n  return items\\n    \\n};\\n\"\n        }\n    ]\n},\n\"maximum-depth-of-binary-tree\":{\n    \"id\": \"104\",\n    \"name\": \"maximum-depth-of-binary-tree\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"队列中用Null(一个特殊元素)来划分每层，或者在对每层进行迭代之前保存当前队列元素的个数（即当前层所含元素个数）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"树的基本操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"层次遍历（BFS）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"apple\"\n        },\n        {\n            \"name\": \"linkedin\"\n        },\n        {\n            \"name\": \"uber\"\n        },\n        {\n            \"name\": \"yahoo\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/104.maximum-depth-of-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/104.maximum-depth-of-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int maxDepth(TreeNode root) {\\n        if(root == null)\\n        {\\n            return 0;\\n        }\\n        // 队列\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        int res = 0;\\n        // 按层扩展\\n        while(!queue.isEmpty())\\n        {\\n            // 拿出该层所有节点，并压入子节点\\n            int size = queue.size();\\n            while(size > 0)\\n            {\\n                TreeNode node = queue.poll();\\n\\n                if(node.left != null)\\n                {\\n                    queue.offer(node.left);\\n                }\\n                if(node.right != null)\\n                {\\n                    queue.offer(node.right);\\n                }\\n                size-=1;\\n            }\\n            // 统计层数\\n            res +=1;\\n        }\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxDepth = function (root) {\\n  if (!root) return 0;\\n  if (!root.left && !root.right) return 1;\\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=104 lang=javascript\\n *\\n * [104] Maximum Depth of Binary Tree\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxDepth = function (root) {\\n  if (!root) return 0;\\n  if (!root.left && !root.right) return 1;\\n\\n  // 层次遍历 BFS\\n  let cur = root;\\n  const queue = [root, null];\\n  let depth = 1;\\n\\n  while ((cur = queue.shift()) !== undefined) {\\n    if (cur === null) {\\n      // 注意⚠️： 不处理会无限循环，进而堆栈溢出\\n      if (queue.length === 0) return depth;\\n      depth++;\\n      queue.push(null);\\n      continue;\\n    }\\n    const l = cur.left;\\n    const r = cur.right;\\n\\n    if (l) queue.push(l);\\n    if (r) queue.push(r);\\n  }\\n\\n  return depth;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxDepth(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        q, depth = [root, None], 1\\n        while q:\\n            node = q.pop(0)\\n            if node:\\n                if node.left: q.append(node.left)\\n                if node.right: q.append(node.right)\\n            elif q:\\n                q.append(None)\\n                depth += 1\\n        return depth\\n\"\n        }\n    ]\n},\n\"Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\":{\n    \"id\": \"105\",\n    \"name\": \"Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal\",\n    \"pre\": [\n        {\n            \"text\": \"二叉树\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npreorder = [3,9,20,15,7]\\ninorder = [9,3,15,20,7]\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n  public TreeNode buildTree(int[] preorder, int[] inorder) {\\n    if (preorder.length != inorder.length) return null;\\n    \\n    HashMap<Integer, Integer> map = new HashMap<> ();\\n\\n    for (int i=0; i<inorder.length; i++) {\\n      map.put(inorder[i], i);\\n    }\\n\\n    return helper(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1, map);\\n  }\\n\\n  public TreeNode helper(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd, HashMap<Integer, Integer> map) {\\n    if (preStart>preEnd || inStart>inEnd) return null;\\n    \\n    TreeNode root = new TreeNode(preorder[prestart]);\\n    int inRoot = map.get(preorder[preStart]);\\n    int leftChldLen = inRoot - inStart;\\n\\n    root.left = helper(preorder, preStart+1, preStart+leftChldLen, inorder, inStart, inRoot-1, map);\\n    root.left = helper(preorder, preStart+leftChldLen+1, preEnd, inorder, inRoot+1, inEnd, map);\\n\\n    return root;\\n  }\\n}\\n\"\n        }\n    ]\n},\n\"convert-sorted-array-to-binary-search-tree\":{\n    \"id\": \"108\",\n    \"name\": \"convert-sorted-array-to-binary-search-tree\",\n    \"pre\": [\n        {\n            \"text\": \"二叉搜索树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"平衡二叉树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"递归\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"找中点\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"airbnb\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/108.convert-sorted-array-to-binary-search-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/108.convert-sorted-array-to-binary-search-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        return dfs(nums, 0, nums.length - 1);\\n    }\\n\\n    private TreeNode dfs(int[] nums, int lo, int hi) {\\n        if (lo > hi) {\\n            return null;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        TreeNode root = new TreeNode(nums[mid]);\\n        root.left = dfs(nums, lo, mid - 1);\\n        root.right = dfs(nums, mid + 1, hi);\\n        return root;\\n    }\\n}\\n\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar sortedArrayToBST = function (nums) {\\n  // 由于数组是排序好的，因此一个思路就是将数组分成两半，一半是左子树，另一半是右子树\\n  // 然后运用“树的递归性质”递归完成操作即可。\\n  if (nums.length === 0) return null;\\n  const mid = nums.length >> 1;\\n  const root = new TreeNode(nums[mid]);\\n\\n  root.left = sortedArrayToBST(nums.slice(0, mid));\\n  root.right = sortedArrayToBST(nums.slice(mid + 1));\\n  return root;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n        return reBuild(nums, 0, nums.size()-1);\\n    }\\n\\n    TreeNode* reBuild(vector<int>& nums, int left, int right)\\n    {\\n        // 终止条件：中序遍历为空\\n        if(left > right)\\n        {\\n            return NULL;\\n        }\\n        // 建立当前子树的根节点\\n        int mid = (left+right)/2;\\n        TreeNode * root = new TreeNode(nums[mid]);\\n\\n        // 左子树的下层递归\\n        root->left = reBuild(nums, left, mid-1);\\n        // 右子树的下层递归\\n        root->right = reBuild(nums, mid+1, right);\\n        // 返回根节点\\n        return root;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\\n        if not nums: return None\\n        mid = (len(nums) - 1) // 2\\n        root = TreeNode(nums[mid])\\n        root.left = self.sortedArrayToBST(nums[:mid])\\n        root.right = self.sortedArrayToBST(nums[mid + 1:])\\n        return root\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def sortedArrayToBST(self, nums):\\n        \\\"\\\"\\\"\\n        :type nums: List[int]\\n        :rtype: TreeNode\\n        \\\"\\\"\\\"\\n        return self.reBuild(nums, 0, len(nums)-1)\\n\\n    def reBuild(self, nums, left, right):\\n         # 终止条件：\\n        if left > right:\\n            return\\n        # 建立当前子树的根节点\\n        mid = (left + right)//2\\n        root = TreeNode(nums[mid])\\n        # 左右子树的下层递归\\n        root.left = self.reBuild(nums, left, mid-1)\\n        root.right = self.reBuild(nums, mid+1, right)\\n\\n        return root\\n\"\n        }\n    ]\n},\n\"Convert-Sorted-List-to-Binary-Search-Tree\":{\n    \"id\": \"109\",\n    \"name\": \"Convert-Sorted-List-to-Binary-Search-Tree\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"二叉搜索树\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"> 对于树中任意一个点，当前节点的值必然大于所有左子树节点的值\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"> 同理,当前节点的值必然小于所有右子树节点的值\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/109.Convert-Sorted-List-to-Binary-Search-Tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/109.Convert-Sorted-List-to-Binary-Search-Tree.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n public TreeNode sortedListToBST(ListNode head) {\\n     if(head == null) return null;\\n     return run(head,null);\\n }\\n private TreeNode run(ListNode head, ListNode tail){\\n     if(head == tail) return null;\\n     ListNode fast = head, slow = head;\\n     while(fast != tail && fast.next != tail){\\n         fast = fast.next.next;\\n         slow = slow.next;\\n     }\\n     TreeNode root = new TreeNode(slow.val);\\n     root.left = run(head, slow);\\n     root.right = run(slow.next, tail);\\n     return root;\\n }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar sortedListToBST = function (head) {\\n  if (!head) return null;\\n  return run(head, null);\\n};\\n\\nfunction run(head, tail) {\\n  if (head == tail) return null;\\n  let fast = head;\\n  let slow = head;\\n  while (fast != tail && fast.next != tail) {\\n    fast = fast.next.next;\\n    slow = slow.next;\\n  }\\n  let root = new TreeNode(slow.val);\\n  root.left = run(head, slow);\\n  root.right = run(slow.next, tail);\\n  return root;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar sortedListToBST = function (head) {\\n  let res = [];\\n  while (head) {\\n    res.push(head.val);\\n    head = head.next;\\n  }\\n  return run(res);\\n};\\n\\nfunction run(res) {\\n  if (res.length == 0) return null;\\n  let mid = parseInt(res.length / 2);\\n  let root = new TreeNode(res[mid]);\\n  root.left = mid > 0 ? run(res.slice(0, mid)) : null;\\n  root.right = mid >= res.length - 1 ? null : run(res.slice(mid + 1));\\n  return root;\\n}\\n\"\n        }\n    ]\n},\n\"path-sum-ii\":{\n    \"id\": \"113\",\n    \"name\": \"path-sum-ii\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"backtrack解题公式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/113.path-sum-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/113.path-sum-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=113 lang=javascript\\n *\\n * [113] Path Sum II\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\nfunction backtrack(root, sum, res, tempList) {\\n  if (root === null) return;\\n  if (root.left === null && root.right === null && sum === root.val)\\n    return res.push([...tempList, root.val]);\\n\\n  tempList.push(root.val);\\n  backtrack(root.left, sum - root.val, res, tempList);\\n\\n  backtrack(root.right, sum - root.val, res, tempList);\\n  tempList.pop();\\n}\\n/**\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @return {number[][]}\\n */\\nvar pathSum = function (root, sum) {\\n  if (root === null) return [];\\n  const res = [];\\n  backtrack(root, sum, res, []);\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\\n        if not root:\\n            return []\\n\\n        result = []\\n\\n        def trace_node(pre_list, left_sum, node):\\n            new_list = pre_list.copy()\\n            new_list.append(node.val)\\n            if not node.left and not node.right:\\n                # 这个判断可以和上面的合并，但分开写会快几毫秒，可以省去一些不必要的判断\\n                if left_sum == node.val:\\n                    result.append(new_list)\\n            else:\\n                if node.left:\\n                    trace_node(new_list, left_sum-node.val, node.left)\\n                if node.right:\\n                    trace_node(new_list, left_sum-node.val, node.right)\\n\\n        trace_node([], sum, root)\\n        return result\\n\"\n        }\n    ]\n},\n\"best-time-to-buy-and-sell-stock\":{\n    \"id\": \"121\",\n    \"name\": \"best-time-to-buy-and-sell-stock\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"这类题只要你在心中（或者别的地方）画出上面这种图就很容易解决\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"amazon\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"facebook\"\n        },\n        {\n            \"name\": \"microsoft\"\n        },\n        {\n            \"name\": \"uber\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/121.best-time-to-buy-and-sell-stock.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/121.best-time-to-buy-and-sell-stock.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minprice = Integer.MAX_VALUE;\\n        int maxprofit = 0;\\n        for (int price: prices) {\\n            maxprofit = Math.max(maxprofit, price - minprice);\\n             minprice = Math.min(price, minprice);\\n        }\\n        return maxprofit;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function (prices) {\\n  let min = prices[0];\\n  let profit = 0;\\n  // 7 1 5 3 6 4\\n  for (let i = 1; i < prices.length; i++) {\\n    if (prices[i] > prices[i - 1]) {\\n      profit = Math.max(profit, prices[i] - min);\\n    } else {\\n      min = Math.min(min, prices[i]);\\n    }\\n  }\\n\\n  return profit;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n/**\\n * 系统上C++的测试用例中的输入有[]，因此需要加一个判断\\n */\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.empty()) return 0;\\n        auto min = prices[0];\\n        auto profit = 0;\\n        for (auto i = 1; i < prices.size(); ++i) {\\n            if (prices[i] > prices[i -1]) {\\n                profit = max(profit, prices[i] - min);\\n            } else {\\n                min = std::min(min, prices[i]);;\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxProfit(self, prices: 'List[int]') -> int:\\n        if not prices: return 0\\n\\n        min_price = float('inf')\\n        max_profit = 0\\n\\n        for price in prices:\\n            if price < min_price:\\n                min_price = price\\n            elif max_profit < price - min_price:\\n                max_profit = price - min_price\\n        return max_profit\\n\"\n        }\n    ]\n},\n\"best-time-to-buy-and-sell-stock-ii\":{\n    \"id\": \"122\",\n    \"name\": \"best-time-to-buy-and-sell-stock-ii\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"这类题只要你在心中（或者别的地方）画出上面这种图就很容易解决\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/122.best-time-to-buy-and-sell-stock-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/122.best-time-to-buy-and-sell-stock-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int res = 0;\\n        for(int i=1;i<prices.length;i++)\\n        {\\n            if(prices[i] > prices[i-1])\\n            {\\n                res += prices[i] - prices[i-1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function (prices) {\\n  let profit = 0;\\n\\n  for (let i = 1; i < prices.length; i++) {\\n    if (prices[i] > prices[i - 1]) {\\n      profit = profit + prices[i] - prices[i - 1];\\n    }\\n  }\\n\\n  return profit;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int res = 0;\\n        for(int i=1;i<prices.size();i++)\\n        {\\n            if(prices[i] > prices[i-1])\\n            {\\n                res += prices[i] - prices[i-1];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"binary-tree-maximum-path-sum\":{\n    \"id\": \"124\",\n    \"name\": \"binary-tree-maximum-path-sum\",\n    \"pre\": [\n        {\n            \"text\": \"树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"理解题目中的path定义\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/124.binary-tree-maximum-path-sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/124.binary-tree-maximum-path-sum.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n  int ans;\\n  public int maxPathSum(TreeNode root) {\\n    ans = Integer.MIN_VALUE;\\n    helper(root);   // recursion\\n    return ans;\\n  }\\n\\n  public int helper(TreeNode root) {\\n    if (root == null) return 0;\\n    int leftMax = Math.max(0, helper(root.left));     // find the max sub-path sum in left sub-tree\\n    int rightMax = Math.max(0, helper(root.right));   // find the max sub-path sum in right sub-tree\\n    ans = Math.max(ans, leftMax+rightMax+root.val);   // find the max path sum at current node\\n    return max(leftMax, rightMax) + root.val;         // according to the definition of path, the return value of current node can only be that the sum of current node value plus either left or right max path sum.\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=124 lang=javascript\\n *\\n * [124] Binary Tree Maximum Path Sum\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\nfunction helper(node, payload) {\\n  if (node === null) return 0;\\n\\n  const l = helper(node.left, payload);\\n  const r = helper(node.right, payload);\\n\\n  payload.max = Math.max(\\n    node.val + Math.max(0, l) + Math.max(0, r),\\n    payload.max\\n  );\\n\\n  return node.val + Math.max(l, r, 0);\\n}\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar maxPathSum = function (root) {\\n  if (root === null) return 0;\\n  const payload = {\\n    max: root.val,\\n  };\\n  helper(root, payload);\\n  return payload.max;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n    int ans = INT_MIN;\\n    int postOrder(TreeNode *root) {\\n        if (!root) return INT_MIN;\\n        int L = max(0, postOrder(root->left)), R = max(0, postOrder(root->right));\\n        ans = max(ans, L + R + root->val);\\n        return root->val + max(L, R);\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        postOrder(root);\\n        return ans;\\n    }\\n};\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    ans = float('-inf')\\n    def maxPathSum(self, root: TreeNode) -> int:\\n        def helper(node):\\n            if not node: return 0\\n            l = helper(node.left)\\n            r = helper(node.right)\\n            self.ans = max(self.ans, max(l,0) + max(r, 0) + node.val)\\n            return max(l, r, 0) + node.val\\n        helper(root)\\n        return self.ans\\n\"\n        }\n    ]\n},\n\"valid-palindrome\":{\n    \"id\": \"125\",\n    \"name\": \"valid-palindrome\",\n    \"pre\": [\n        {\n            \"text\": \"回文\",\n            \"link\": null,\n            \"color\": \"lime\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"facebook\"\n        },\n        {\n            \"name\": \"microsoft\"\n        },\n        {\n            \"name\": \"uber\"\n        },\n        {\n            \"name\": \"zenefits\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/125.valid-palindrome.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/125.valid-palindrome.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=125 lang=javascript\\n *\\n * [125] Valid Palindrome\\n */\\n// 只处理英文字符（题目忽略大小写，我们前面全部转化成了小写， 因此这里我们只判断小写）和数字\\nfunction isValid(c) {\\n  const charCode = c.charCodeAt(0);\\n  const isDigit =\\n    charCode >= \\\"0\\\".charCodeAt(0) && charCode <= \\\"9\\\".charCodeAt(0);\\n  const isChar = charCode >= \\\"a\\\".charCodeAt(0) && charCode <= \\\"z\\\".charCodeAt(0);\\n\\n  return isDigit || isChar;\\n}\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar isPalindrome = function (s) {\\n  s = s.toLowerCase();\\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left < right) {\\n    if (!isValid(s[left])) {\\n      left++;\\n      continue;\\n    }\\n    if (!isValid(s[right])) {\\n      right--;\\n      continue;\\n    }\\n\\n    if (s[left] === s[right]) {\\n      left++;\\n      right--;\\n    } else {\\n      break;\\n    }\\n  }\\n\\n  return right <= left;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def isPalindrome(self, s: str) -> bool:\\n        left, right = 0, len(s) - 1\\n        while left < right:\\n            if not s[left].isalnum():\\n                left += 1\\n                continue\\n            if not s[right].isalnum():\\n                right -= 1\\n                continue\\n            if s[left].lower() == s[right].lower():\\n                left += 1\\n                right -= 1\\n            else:\\n                break\\n        return right <= left\\n\\n    def isPalindrome2(self, s: str) -> bool:\\n        \\\"\\\"\\\"\\n        使用语言特性进行求解\\n        \\\"\\\"\\\"\\n        s = ''.join(i for i in s if i.isalnum()).lower()\\n        return s == s[::-1]\\n\"\n        }\n    ]\n},\n\"longest-consecutive-sequence\":{\n    \"id\": \"128\",\n    \"name\": \"longest-consecutive-sequence\",\n    \"pre\": [\n        {\n            \"text\": \"hashmap\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/128.longest-consecutive-sequence.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/128.longest-consecutive-sequence.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int longestConsecutive(int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int ans = 0;\\n        for (int num : nums) {\\n            set.add(num);\\n        }\\n        for(int i = 0;i < nums.length; i ++) {\\n            int x = nums[i];\\n            // 说明x是连续序列的开头元素\\n            if  (!set.contains(x - 1)) {\\n                while(set.contains(x + 1)) {\\n                    x ++;\\n                }\\n            }\\n            ans = Math.max(ans, x - nums[i] + 1);\\n        }\\n        return ans;\\n\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nif (nums.length === 0) return 0;\\nlet count = 1;\\nlet maxCount = 1;\\n// 这里其实可以不需要排序，这么做只不过是为了方便理解\\nnums = [...new Set(nums)].sort((a, b) => a - b);\\nfor (let i = 0; i < nums.length - 1; i++) {\\n  if (nums[i + 1] - nums[i] === 1) {\\n    count++;\\n  } else {\\n    if (count > maxCount) {\\n      maxCount = count;\\n    }\\n    count = 1;\\n  }\\n}\\nreturn Math.max(count, maxCount);\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar longestConsecutive = function (nums) {\\n  set = new Set(nums);\\n  let max = 0;\\n  let temp = 0;\\n  set.forEach((x) => {\\n    // 说明x是连续序列的开头元素。加这个条件相当于剪枝的作用，否则时间复杂度会退化到 N ^ 2\\n    if (!set.has(x - 1)) {\\n      temp = x + 1;\\n      while (set.has(y)) {\\n        temp = temp + 1;\\n      }\\n      max = Math.max(max, y - x); // y - x 就是从x开始到最后有多少连续的数字\\n    }\\n  });\\n  return max;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def longestConsecutive(self, A: List[int]) -> int:\\n        seen = set(A)\\n        ans = 0\\n        for a in A:\\n            t = a\\n            #  if 的作用是剪枝\\n            if t + 1 not in seen:\\n                while t - 1 in seen:\\n                    t -= 1\\n            ans = max(ans, a - t + 1)\\n        return ans\\n\"\n        }\n    ]\n},\n\"sum-root-to-leaf-numbers\":{\n    \"id\": \"129\",\n    \"name\": \"sum-root-to-leaf-numbers\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"递归分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/129.sum-root-to-leaf-numbers.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/129.sum-root-to-leaf-numbers.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=129 lang=javascript\\n *\\n * [129] Sum Root to Leaf Numbers\\n */\\nfunction helper(node, cur) {\\n  if (node === null) return 0;\\n  const next = node.val + cur * 10;\\n\\n  if (node.left === null && node.right === null) return next;\\n\\n  const l = helper(node.left, next);\\n  const r = helper(node.right, next);\\n\\n  return l + r;\\n}\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar sumNumbers = function (root) {\\n  // tag: `tree` `dfs` `math`\\n  return helper(root, 0);\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n\\n        def helper(node, cur_val):\\n            if not node: return 0\\n            next_val = cur_val * 10 + node.val\\n\\n            if not (node.left or node.right):\\n                return next_val\\n\\n            left_val = helper(node.left, next_val)\\n            right_val = helper(node.right, next_val)\\n\\n            return left_val + right_val\\n\\n        return helper(root, 0)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def sumNumbers(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        result = 0\\n        node_queue, sum_queue = [root], [root.val]\\n        while node_queue:\\n            for i in node_queue:\\n                cur_node = node_queue.pop(0)\\n                cur_val = sum_queue.pop(0)\\n                if cur_node.left:\\n                    node_queue.append(cur_node.left)\\n                    sum_queue.append(cur_val * 10 + cur_node.left.val)\\n                if cur_node.right:\\n                    node_queue.append(cur_node.right)\\n                    sum_queue.append(cur_val * 10 + cur_node.right.val)\\n                if not (cur_node.left or cur_node.right):\\n                    result += cur_val\\n        return result\\n\"\n        }\n    ]\n},\n\"surrounded-regions\":{\n    \"id\": \"130\",\n    \"name\": \"surrounded-regions\",\n    \"pre\": [\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二维数组DFS解题模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"转化问题为`连通区域问题`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"直接mutate原数组，节省空间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/130.surrounded-regions.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/130.surrounded-regions.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=130 lang=javascript\\n *\\n * [130] Surrounded Regions\\n */\\n// 将O以及周边的O转化为A\\nfunction mark(board, i, j, rows, cols) {\\n  if (i < 0 || i > rows - 1 || j < 0 || j > cols - 1 || board[i][j] !== \\\"O\\\")\\n    return;\\n\\n  board[i][j] = \\\"A\\\";\\n  mark(board, i + 1, j, rows, cols);\\n  mark(board, i - 1, j, rows, cols);\\n  mark(board, i, j + 1, rows, cols);\\n  mark(board, i, j - 1, rows, cols);\\n}\\n/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function (board) {\\n  const rows = board.length;\\n  if (rows === 0) return [];\\n  const cols = board[0].length;\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (i === 0 || i == rows - 1 || j === 0 || j === cols - 1) {\\n        mark(board, i, j, rows, cols);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (board[i][j] === \\\"O\\\") {\\n        board[i][j] = \\\"X\\\";\\n      } else if (board[i][j] === \\\"A\\\") {\\n        board[i][j] = \\\"O\\\";\\n      }\\n    }\\n  }\\n\\n  return board;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\n    int M, N, dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    void dfs(vector<vector<char>> &board, int x, int y) {\\n        if (x < 0 || x >= M || y < 0 || y >= N || board[x][y] != 'O') return;\\n        board[x][y] = '#';\\n        for (auto &dir : dirs) dfs(board, x + dir[0], y + dir[1]);\\n    }\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if (board.empty() || board[0].empty()) return;\\n        M = board.size(), N = board[0].size();\\n        for (int i = 0; i < M; ++i) {\\n            dfs(board, i, 0);\\n            dfs(board, i, N - 1);\\n        }\\n        for (int j = 0; j < N; ++j) {\\n            dfs(board, 0, j);\\n            dfs(board, M - 1, j);\\n        }\\n        for (auto &row : board) {\\n            for (auto &cell : row) {\\n                cell = cell == '#' ? 'O' : 'X';\\n            }\\n        }\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify board in-place instead.\\n        \\\"\\\"\\\"\\n        # 如果数组长或宽小于等于2，则不需要替换\\n        if len(board) <= 2 or len(board[0]) <= 2:\\n            return\\n\\n        row, col = len(board), len(board[0])\\n\\n        def dfs(i, j):\\n            \\\"\\\"\\\"\\n            深度优先算法，如果符合条件，替换为A并进一步测试，否则停止\\n            \\\"\\\"\\\"\\n            if i < 0 or j < 0 or i >= row or j >= col or board[i][j] != 'O':\\n                return\\n            board[i][j] = 'A'\\n\\n            dfs(i - 1, j)\\n            dfs(i + 1, j)\\n            dfs(i, j - 1)\\n            dfs(i, j + 1)\\n\\n        # 从外围开始\\n        for i in range(row):\\n            dfs(i, 0)\\n            dfs(i, col-1)\\n\\n        for j in range(col):\\n            dfs(0, j)\\n            dfs(row-1, j)\\n\\n        # 最后完成替换\\n        for i in range(row):\\n            for j in range(col):\\n                if board[i][j] == 'O':\\n                    board[i][j] = 'X'\\n                elif board[i][j] == 'A':\\n                    board[i][j] = 'O'\\n\"\n        }\n    ]\n},\n\"palindrome-partitioning\":{\n    \"id\": \"131\",\n    \"name\": \"palindrome-partitioning\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/131.palindrome-partitioning.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/131.palindrome-partitioning.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=131 lang=javascript\\n *\\n * [131] Palindrome Partitioning\\n */\\n\\nfunction isPalindrom(s) {\\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left < right && s[left] === s[right]) {\\n    left++;\\n    right--;\\n  }\\n\\n  return left >= right;\\n}\\nfunction backtrack(s, list, tempList, start) {\\n  const sliced = s.slice(start);\\n\\n  if (isPalindrom(sliced) && tempList.join(\\\"\\\").length === s.length)\\n    list.push([...tempList]);\\n\\n  for (let i = 0; i < sliced.length; i++) {\\n    const sub = sliced.slice(0, i + 1);\\n    if (isPalindrom(sub)) {\\n      tempList.push(sub);\\n    } else {\\n      continue;\\n    }\\n    backtrack(s, list, tempList, start + i + 1);\\n    tempList.pop();\\n  }\\n}\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function (s) {\\n  // \\\"aab\\\"\\n  // [\\\"aa\\\", \\\"b\\\"]\\n  // [\\\"a\\\", \\\"a\\\", \\\"b\\\"]\\n  const list = [];\\n  backtrack(s, list, [], 0);\\n  return list;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n\\tclass Solution {\\nprivate:\\n  vector<vector<string>> ans;\\n  vector<string> tmp;\\n  bool isPalindrome(string &s, int first, int last) {\\n    while (first < last && s[first] == s[last]) ++first, --last;\\n    return first >= last;\\n  }\\n  void dfs(string &s, int start) {\\n    if (start == s.size()) { ans.push_back(tmp); return; }\\n    for (int i = start; i < s.size(); ++i) {\\n      if (isPalindrome(s, start, i)) {\\n        tmp.push_back(s.substr(start, i - start + 1));\\n        dfs(s, i + 1);\\n        tmp.pop_back();\\n      }\\n    }\\n  }\\npublic:\\n  vector<vector<string>> partition(string s) {\\n    dfs(s, 0);\\n    return ans;\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\\"\\\"\\\"回溯法\\\"\\\"\\\"\\n\\n        res = []\\n\\n        def helper(s, tmp):\\n            \\\"\\\"\\\"\\n            如果是空字符串，说明已经处理完毕\\n            否则逐个字符往前测试，判断是否是回文\\n            如果是，则处理剩余字符串，并将已经得到的列表作为参数\\n            \\\"\\\"\\\"\\n            if not s:\\n                res.append(tmp)\\n            for i in range(1, len(s) + 1):\\n                if s[:i] == s[:i][::-1]:\\n                    helper(s[i:], tmp + [s[:i]])\\n\\n        helper(s, [])\\n        return res\\n\"\n        }\n    ]\n},\n\"palindrome-partitioning-ii\":{\n    \"id\": \"132\",\n    \"name\": \"palindrome-partitioning-ii\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"预处理。将s[i:j]是否为回文的数据提前计算出来存储到一个二维数组中。接下来就是普通的动态规划。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果s[0:j]本身就是一个回文，那么dp[j]应该是0\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/132.palindrome-partitioning-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/132.palindrome-partitioning-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in range(n):\\n    for j in range(i + 1, n):\\n        if judge(i + 1, j):\\n            # 你的逻辑\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\npalindrome_pairs[i][j] = (s[i] == s[j]) and palindrome_pairs[i + 1][j - 1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in range(n):\\n    for j in range(i + 1, n):\\n        if judge(i + 1, j):\\n            dp[j] = min(dp[j], dp[i] + 1)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def minCut(self, s: str) -> int:\\n        n = len(s)\\n        palindrome_pairs = [[True] * n for _ in range(n)]\\n\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i + 1, n):\\n                palindrome_pairs[i][j] = (s[i] == s[j]) and palindrome_pairs[i + 1][j - 1]\\n\\n        def judge(i, j):\\n            return palindrome_pairs[i][j]\\n\\n        dp = [float(\\\"inf\\\")] * n\\n        dp[0] = 0\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if palindrome_pairs[0][j]:\\n                    dp[j] = 0\\n                elif judge(i + 1, j):\\n                    dp[j] = min(dp[j], dp[i] + 1)\\n        return dp[-1]\\n\\n\"\n        }\n    ]\n},\n\"single-number\":{\n    \"id\": \"136\",\n    \"name\": \"single-number\",\n    \"pre\": [\n        {\n            \"text\": \"位运算\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/bit.md\",\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"1.异或的性质两个数字异或的结果`a^b`是将a和b的二进制每一位进行运算，得出的数字。运算的逻辑是如果同一位的数字相同则为0，不同则为12.异或的规律\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"任何数和本身异或则为`0`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"任何数和0异或是`本身`3.很多人只是记得异或的性质和规律，但是缺乏对其本质的理解，导致很难想到这种解法（我本人也没想到）4.bit运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/136.single-number.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/136.single-number.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for(int n:nums)\\n        {\\n            // 异或\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function (nums) {\\n  let ret = 0;\\n  for (let index = 0; index < nums.length; index++) {\\n    const element = nums[index];\\n    ret = ret ^ element;\\n  }\\n  return ret;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        single_number = 0\\n        for num in nums:\\n            single_number ^= num\\n        return single_number\\n\"\n        }\n    ]\n},\n\"word-break\":{\n    \"id\": \"139\",\n    \"name\": \"word-break\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/139.word-break.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/139.word-break.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {boolean}\\n */\\nvar wordBreak = function (s, wordDict) {\\n  const dp = Array(s.length + 1);\\n  dp[0] = true;\\n  for (let i = 0; i < s.length + 1; i++) {\\n    for (let word of wordDict) {\\n      if (word.length <= i && dp[i - word.length]) {\\n        if (s.substring(i - word.length, i) === word) {\\n          dp[i] = true;\\n        }\\n      }\\n    }\\n  }\\n\\n  return dp[s.length] || false;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> st(begin(dict), end(dict));\\n        int N = s.size();\\n        vector<bool> dp(N + 1);\\n        dp[0] = true;\\n        for (int i = 1; i <= N; ++i) {\\n            for (int j = 0; j < i && !dp[i]; ++j) {\\n                dp[i] = dp[j] && st.count(s.substr(j, i - j));\\n            }\\n        }\\n        return dp[N];\\n    }\\n};\\n\\n\"\n        }\n    ]\n},\n\"word-break-ii\":{\n    \"id\": \"140\",\n    \"name\": \"word-break-ii\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"笛卡尔积\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/140.word-break-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/140.word-break-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n\\\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\\"[\\n  (\\\"a\\\",\\n  \\\"aa\\\",\\n  \\\"aaa\\\",\\n  \\\"aaaa\\\",\\n  \\\"aaaaa\\\",\\n  \\\"aaaaaa\\\",\\n  \\\"aaaaaaa\\\",\\n  \\\"aaaaaaaa\\\",\\n  \\\"aaaaaaaaa\\\",\\n  \\\"aaaaaaaaaa\\\")\\n];\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n{\\n  hi: true,\\n  h: true,\\n  i: true,\\n  world: true,\\n  hello: true,\\n\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\n    int maxLen = 0;\\n    unordered_set<string> ws;\\n    vector<int> m;\\n    vector<string> ans;\\n    bool dfs(string &s, int i, string tmp) {\\n        if (i == s.size()) {\\n            ans.push_back(tmp);\\n            return true;\\n        }\\n        if (m[i] == 0) return m[i];\\n        m[i] = 0;\\n        for (int j = min((int)s.size(), i + maxLen); j > i; --j) {\\n            auto sub = s.substr(i, j - i);\\n            if (ws.count(sub) && dfs(s, j, tmp.size() ? tmp + \\\" \\\" + sub : sub)) m[i] = 1;\\n        }\\n        return m[i];\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& dict) {\\n        ws = { dict.begin(), dict.end() };\\n        for (auto &w : dict) maxLen = max(maxLen, (int)w.size());\\n        m.assign(s.size(), -1); // -1 = unvisited, 0 = can not reach end, 1 = can reach end.\\n        dfs(s, 0, \\\"\\\");\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        ans = []\\n        n = len(s)\\n\\n        def backtrack(temp, start):\\n            if start == n: ans.append(temp[1:])\\n            for i in range(start, n):\\n                if s[start:i + 1] in wordDict:\\n                    backtrack(temp + \\\" \\\" + s[start:i + 1], i + 1)\\n        backtrack('', 0)\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        n = len(s)\\n        @lru_cache(None)\\n        def backtrack(start):\\n            ans = []\\n            if start == n:\\n                ans.append('')\\n            for i in range(start, n):\\n                if s[start:i + 1] in wordDict:\\n                    if start == 0: temp = s[start:i + 1]\\n                    else: temp = \\\" \\\" + s[start:i + 1]\\n                    ps = backtrack(i + 1)\\n                    for p in ps:\\n                        ans.append(temp + p)\\n            return ans\\n        return backtrack(0)\\n\"\n        }\n    ]\n},\n\"Linked-List-Cycle-II\":{\n    \"id\": \"142\",\n    \"name\": \"Linked-List-Cycle-II\",\n    \"pre\": [],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/142.Linked-List-Cycle-II.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/142.Linked-List-Cycle-II.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\ndata = new Set() // 声明哈希表\\nwhile head不为空{\\n  if 当前节点在哈希表中存在{\\n    return head // 当前节点就是环的入口节点\\n  } else {\\n    将当前节点插入哈希表\\n  }\\n  head指针后移\\n}\\nreturn null // 环不存在\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nlet data = new Set();\\nwhile (head) {\\n  if (data.has(head)) {\\n    return head;\\n  } else {\\n    data.add(head);\\n  }\\n  head = head.next;\\n}\\nreturn null;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"x\\nfast = head\\nslow = head //快慢指针都指向头部\\ndo {\\n  快指针向后两步\\n  慢指针向后一步\\n} while 快慢指针不相等时\\nif 指针都为空时{\\n  return null // 没有环\\n}\\nwhile 快慢指针不相等时{\\n  快指针向后一步\\n  慢指针向后一步\\n}\\nreturn fast\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nif (head == null || head.next == null) return null;\\nlet fast = (slow = head);\\ndo {\\n  if (fast != null && fast.next != null) {\\n    fast = fast.next.next;\\n  } else {\\n    fast = null;\\n  }\\n  slow = slow.next;\\n} while (fast != slow);\\nif (fast == null) return null;\\nfast = head;\\nwhile (fast != slow) {\\n  fast = fast.next;\\n  slow = slow.next;\\n}\\nreturn fast;\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        if (!head) return NULL;\\n        auto p = head, q = head;\\n        while (p && p->next) {\\n            p = p->next->next;\\n            q = q->next;\\n            if (p == q) break;\\n        }\\n        if (!p || !p->next) return NULL;\\n        p = head;\\n        for (; p != q; p = p->next, q = q->next);\\n        return p;\\n    }\\n};\\n\\n\"\n        }\n    ]\n},\n\"binary-tree-preorder-traversal\":{\n    \"id\": \"144\",\n    \"name\": \"binary-tree-preorder-traversal\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二叉树的基本操作（遍历）>不同的遍历算法差异还是蛮大的\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果非递归的话利用栈来简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果数据规模不大的话，建议使用递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"递归的问题需要注意两点，一个是终止条件，一个如何缩小规模1.终止条件，自然是当前这个元素是null（链表也是一样）2.由于二叉树本身就是一个递归结构，每次处理一个子树其实就是缩小了规模，难点在于如何合并结果，这里的合并结果其实就是`mid.concat(left).concat(right)`,mid是一个具体的节点，left和right`递归求出即可`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/144.binary-tree-preorder-traversal.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/144.binary-tree-preorder-traversal.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function (root) {\\n  // 1. Recursive solution\\n\\n  // if (!root) return [];\\n\\n  // return [root.val].concat(preorderTraversal(root.left)).concat(preorderTraversal(root.right));\\n\\n  // 2. iterative solutuon\\n\\n  if (!root) return [];\\n  const ret = [];\\n  const stack = [root];\\n  let t = stack.pop();\\n\\n  while (t) {\\n    if (t.right) {\\n      stack.push(t.right);\\n    }\\n    if (t.left) {\\n      stack.push(t.left);\\n    }\\n    ret.push(t.val);\\n    t = stack.pop();\\n  }\\n\\n  return ret;\\n};\\n\"\n        }\n    ]\n},\n\"binary-tree-postorder-traversal\":{\n    \"id\": \"145\",\n    \"name\": \"binary-tree-postorder-traversal\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二叉树的基本操作（遍历）>不同的遍历算法差异还是蛮大的\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果非递归的话利用栈来简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果数据规模不大的话，建议使用递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"递归的问题需要注意两点，一个是终止条件，一个如何缩小规模1.终止条件，自然是当前这个元素是null（链表也是一样）2.由于二叉树本身就是一个递归结构，每次处理一个子树其实就是缩小了规模，难点在于如何合并结果，这里的合并结果其实就是`left.concat(right).concat(mid)`,mid是一个具体的节点，left和right`递归求出即可`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/145.binary-tree-postorder-traversal.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/145.binary-tree-postorder-traversal.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar postorderTraversal = function (root) {\\n  // 1. Recursive solution\\n\\n  // if (!root) return [];\\n\\n  // return postorderTraversal(root.left).concat(postorderTraversal(root.right)).concat(root.val);\\n\\n  // 2. iterative solutuon\\n\\n  if (!root) return [];\\n  const ret = [];\\n  const stack = [root];\\n  let p = root; // 标识元素，用来判断节点是否应该出栈\\n\\n  while (stack.length > 0) {\\n    const top = stack[stack.length - 1];\\n    if (\\n      top.left === p ||\\n      top.right === p || // 子节点已经遍历过了\\n      (top.left === null && top.right === null) // 叶子元素\\n    ) {\\n      p = stack.pop();\\n      ret.push(p.val);\\n    } else {\\n      if (top.right) {\\n        stack.push(top.right);\\n      }\\n      if (top.left) {\\n        stack.push(top.left);\\n      }\\n    }\\n  }\\n\\n  return ret;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> s;\\n        TreeNode *prev = NULL;\\n        while (root || s.size()) {\\n            while (root) {\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            if (!root->right || root->right == prev) {\\n                ans.push_back(root->val);\\n                s.pop();\\n                prev = root;\\n                root = NULL;\\n            } else root = root->right;\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"lru-cache\":{\n    \"id\": \"146\",\n    \"name\": \"lru-cache\",\n    \"pre\": [],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/146.lru-cache.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/146.lru-cache.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar LRUCache = function(capacity) {\\n\\t保存一个该数据结构的最大容量\\n\\t生成一个双向链表,同时保存该链表的头结点与尾节点\\n\\t生成一个哈希表\\n};\\n\\nfunction get (key) {\\n\\tif 哈希表中存在该关键字 {\\n\\t\\t根据哈希表获取该链表节点\\n\\t\\t将该节点放置于链表头部\\n\\t\\treturn 链表节点的值\\n\\t} else {\\n\\t\\t  return -1\\n\\t}\\n};\\n\\nfunction put (key, value) {\\n    if 哈希表中存在该关键字 {\\n\\t\\t根据哈希表获取该链表节点\\n\\t\\t将该链表节点的值更新\\n\\t\\t将该节点放置于链表头部\\n\\t} else {\\n\\t\\tif 容量已满 {\\n\\t\\t\\t删除链表尾部的节点\\n\\t\\t\\t新生成一个节点\\n\\t\\t\\t将该节点放置于链表头部\\n\\t\\t} else {\\n\\t\\t\\t新生成一个节点\\n\\t\\t\\t将该节点放置于链表头部\\n\\t\\t}\\n\\t}\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction ListNode(key, val) {\\n  this.key = key;\\n  this.val = val;\\n  this.pre = this.next = null;\\n}\\n\\nvar LRUCache = function (capacity) {\\n  this.capacity = capacity;\\n  this.size = 0;\\n  this.data = {};\\n  this.head = new ListNode();\\n  this.tail = new ListNode();\\n  this.head.next = this.tail;\\n  this.tail.pre = this.head;\\n};\\n\\nfunction get(key) {\\n  if (this.data[key] !== undefined) {\\n    let node = this.data[key];\\n    this.removeNode(node);\\n    this.appendHead(node);\\n    return node.val;\\n  } else {\\n    return -1;\\n  }\\n}\\n\\nfunction put(key, value) {\\n  let node;\\n  if (this.data[key] !== undefined) {\\n    node = this.data[key];\\n    this.removeNode(node);\\n    node.val = value;\\n  } else {\\n    node = new ListNode(key, value);\\n    this.data[key] = node;\\n    if (this.size < this.capacity) {\\n      this.size++;\\n    } else {\\n      key = this.removeTail();\\n      delete this.data[key];\\n    }\\n  }\\n  this.appendHead(node);\\n}\\n\\nfunction removeNode(node) {\\n  let preNode = node.pre,\\n    nextNode = node.next;\\n  preNode.next = nextNode;\\n  nextNode.pre = preNode;\\n}\\n\\nfunction appendHead(node) {\\n  let firstNode = this.head.next;\\n  this.head.next = node;\\n  node.pre = this.head;\\n  node.next = firstNode;\\n  firstNode.pre = node;\\n}\\n\\nfunction removeTail() {\\n  let key = this.tail.pre.key;\\n  this.removeNode(this.tail.pre);\\n  return key;\\n}\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass DLinkedNode:\\n    def __init__(self, key=0, value=0):\\n        self.key = key\\n        self.value = value\\n        self.prev = None\\n        self.next = None\\n\\n\\nclass LRUCache:\\n    def __init__(self, capacity: int):\\n        self.cache = dict()\\n        # 使用伪头部和伪尾部节点\\n        self.head = DLinkedNode()\\n        self.tail = DLinkedNode()\\n        self.head.next = self.tail\\n        self.tail.prev = self.head\\n        self.capacity = capacity\\n        self.size = 0\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.cache:\\n            return -1\\n        # 如果 key 存在，先通过哈希表定位，再移到头部\\n        node = self.cache[key]\\n        self.moveToHead(node)\\n        return node.value\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key not in self.cache:\\n            # 如果 key 不存在，创建一个新的节点\\n            node = DLinkedNode(key, value)\\n            # 添加进哈希表\\n            self.cache[key] = node\\n            # 添加至双向链表的头部\\n            self.addToHead(node)\\n            self.size += 1\\n            if self.size > self.capacity:\\n                # 如果超出容量，删除双向链表的尾部节点\\n                removed = self.removeTail()\\n                # 删除哈希表中对应的项\\n                self.cache.pop(removed.key)\\n                self.size -= 1\\n        else:\\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\\n            node = self.cache[key]\\n            node.value = value\\n            self.moveToHead(node)\\n\\n    def addToHead(self, node):\\n        node.prev = self.head\\n        node.next = self.head.next\\n        self.head.next.prev = node\\n        self.head.next = node\\n\\n    def removeNode(self, node):\\n        node.prev.next = node.next\\n        node.next.prev = node.prev\\n\\n    def moveToHead(self, node):\\n        self.removeNode(node)\\n        self.addToHead(node)\\n\\n    def removeTail(self):\\n        node = self.tail.prev\\n        self.removeNode(node)\\n        return node\\n\\n\"\n        }\n    ]\n},\n\"insertion-sort-list\":{\n    \"id\": \"147\",\n    \"name\": \"insertion-sort-list\",\n    \"pre\": [],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/147.insertion-sort-list.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/147.insertion-sort-list.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public ListNode insertionSortList(ListNode head) {\\n\\t\\tListNode ans = new ListNode(-1);\\n\\t\\twhile( head != null ){\\n\\t\\t\\tListNode next = head.next;\\n            ListNode cur = ans;\\n\\t\\t\\twhile(cur.next != null && cur.next.val < head.val ){\\n\\t\\t\\t\\tcur = cur.next;\\n\\t\\t\\t}\\n\\t\\t\\thead.next = cur.next;\\n\\t\\t\\tcur.next = head;\\n\\t\\t\\thead = next;\\n\\t\\t}\\n\\n\\t\\treturn ans.next;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar insertionSortList = function (head) {\\n  ans = new ListNode(-1);\\n  while (head != null) {\\n    next = head.next;\\n    cur = ans;\\n    while (cur.next != null && cur.next.val < head.val) {\\n      cur = cur.next;\\n    }\\n    head.next = cur.next;\\n    cur.next = head;\\n    head = next;\\n  }\\n\\n  return ans.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    ListNode* insertionSortList(ListNode* head) {\\n        ListNode dummy, *p;\\n        while (head) {\\n            auto *n = head;\\n            head = head->next;\\n            p = &dummy;\\n            while (p->next && p->next->val < n->val) p = p->next;\\n            n->next = p->next;\\n            p->next = n;\\n        }\\n        return dummy.next;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        ans = ListNode(float(\\\"-inf\\\"))\\n        # do domething\\n        return ans.next\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        ans = ListNode(float(\\\"-inf\\\"))\\n\\n        def insert(to_be_insert):\\n            # 选择插入的位置，并插入\\n\\n        while head:\\n            insert(head)\\n            head = head.next\\n        return ans.next\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# ans 就是上面我提到的虚拟节点\\nans = cur\\nwhile cur.next and cur.next.val < to_be_insert.val:\\n    cur = cur.next\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nto_be_insert.next = cur.next\\ncur.next = to_be_insert\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        ans = ListNode(float(\\\"-inf\\\"))\\n\\n        def helper(inserted):\\n            cur = ans\\n            while cur.next and cur.next.val < inserted.val:\\n                cur = cur.next\\n            inserted.next = cur.next\\n            cur.next = inserted\\n\\n        while head:\\n            helper(head)\\n            head = head.next\\n        return ans.next\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ninserted.next = cur.next\\ncur.next = inserted\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n        ans = ListNode(float(\\\"-inf\\\"))\\n\\n        def insert(to_be_insert):\\n            # 选择插入的位置，并插入\\n            # 这里 to_to_insert 的 next 会被修改，进而影响外层的 head\\n\\n        while head:\\n            # 留下联系方式\\n            next = head.next\\n            insert(head)\\n            # 使用联系方式更新 head\\n            head = next\\n        return ans.next\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def insertionSortList(self, head: ListNode) -> ListNode:\\n       ans = ListNode(float(\\\"-inf\\\"))\\n\\n        while head:\\n            next = head.next\\n            cur = ans\\n            while cur.next and cur.next.val < head.val:\\n                cur = cur.next\\n            head.next = cur.next\\n            cur.next = head\\n            head = next\\n        return ans.next\\n\"\n        }\n    ]\n},\n\"evaluate-reverse-polish-notation\":{\n    \"id\": \"150\",\n    \"name\": \"evaluate-reverse-polish-notation\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"1.栈的基本用法2.如果你用的是JS的话，需要注意/和其他很多语言是不一样的3.如果你用的是JS的话，需要先将字符串转化为数字。否则有很多意想不到的结果4.操作符的顺序应该是先出栈的是第二位，后出栈的是第一位。这在不符合交换律的操作中很重要，比如减法和除法。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/150.evaluate-reverse-polish-notation.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/150.evaluate-reverse-polish-notation.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public static int evalRPN(String[] tokens) {\\n\\tint[] numStack = new int[tokens.length / 2 + 1];\\n\\tint index = 0;\\n\\tfor (String s : tokens) {\\n\\t    if (s.equals(\\\"+\\\")) {\\n                numStack[index - 2] += numStack[--index];\\n            } else if (s.equals(\\\"-\\\")) {\\n                numStack[index - 2] -= numStack[--index];\\n            } else if (s.equals(\\\"*\\\")) {\\n                numStack[index - 2] *= numStack[--index];\\n            } else if (s.equals(\\\"/\\\")) {\\n                numStack[index - 2] /= numStack[--index];\\n            } else {\\n                numStack[index++] = Integer.parseInt(s);\\n            }\\n\\t}\\n\\treturn numStack[0];\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {string[]} tokens\\n * @return {number}\\n */\\nvar evalRPN = function (tokens) {\\n  // 这种算法的前提是 tokens是有效的，\\n  // 当然这由算法来保证\\n  const stack = [];\\n\\n  for (let index = 0; index < tokens.length; index++) {\\n    const token = tokens[index];\\n    // 对于运算数， 我们直接入栈\\n    if (!Number.isNaN(Number(token))) {\\n      stack.push(token);\\n    } else {\\n      // 遇到操作符，我们直接大胆运算，不用考虑算术优先级\\n      // 然后将运算结果入栈即可\\n\\n      // 当然如果题目进一步扩展，允许使用单目等其他运算符，我们的算法需要做微小的调整\\n      const a = Number(stack.pop());\\n      const b = Number(stack.pop());\\n      if (token === \\\"*\\\") {\\n        stack.push(b * a);\\n      } else if (token === \\\"/\\\") {\\n        stack.push((b / a) >> 0);\\n      } else if (token === \\\"+\\\") {\\n        stack.push(b + a);\\n      } else if (token === \\\"-\\\") {\\n        stack.push(b - a);\\n      }\\n    }\\n  }\\n\\n  return stack.pop();\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n\\tclass Solution {\\npublic:\\n  int evalRPN(vector<string>& tokens) {\\n    stack<int> s;\\n    for (string t : tokens) {\\n      if (isdigit(t.back())) s.push(stoi(t));\\n      else {\\n        int n = s.top();\\n        s.pop();\\n        switch(t[0]) {\\n          case '+': s.top() += n; break;\\n          case '-': s.top() -= n; break;\\n          case '*': s.top() *= n; break;\\n          case '/': s.top() /= n; break;\\n        }\\n      }\\n    }\\n    return s.top();\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def evalRPN(self, tokens: List[str]) -> int:\\n        if len(tokens) > 2:\\n            stack = []\\n            operations = ['+', '-', '*', '/']\\n            for token in tokens:\\n                if token in operations:\\n                    b = int(stack.pop())\\n                    a = int(stack.pop())\\n                    if '+' == token:\\n                        tmp = a + b\\n                    elif '-' == token:\\n                        tmp = a - b\\n                    elif '*' == token:\\n                        tmp = a * b\\n                    else:\\n                        tmp = int(a / b)\\n                    stack.append(tmp)\\n                else:\\n                    stack.append(token)\\n            return stack[0]\\n        return int(tokens[-1])\\n\"\n        }\n    ]\n},\n\"maximum-product-subarray\":{\n    \"id\": \"152\",\n    \"name\": \"maximum-product-subarray\",\n    \"pre\": [\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"同时记录乘积最大值和乘积最小值\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/152.maximum-product-subarray.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/152.maximum-product-subarray.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxProduct = function (nums) {\\n  let max = nums[0];\\n  let temp = null;\\n  for (let i = 0; i < nums.length; i++) {\\n    temp = nums[i];\\n    for (let j = i + 1; j < nums.length; j++) {\\n      temp *= nums[j];\\n      max = Math.max(temp, max);\\n    }\\n  }\\n\\n  return max;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxProduct = function (nums) {\\n  let max = nums[0];\\n  let min = nums[0];\\n  let res = nums[0];\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    let tmp = min;\\n    min = Math.min(nums[i], Math.min(max * nums[i], min * nums[i])); // 取最小\\n    max = Math.max(nums[i], Math.max(max * nums[i], tmp * nums[i])); /// 取最大\\n    res = Math.max(res, max);\\n  }\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& A) {\\n        int maxProd = 1, minProd = 1, ans = INT_MIN;\\n        for (int n : A) {\\n            int a = n * maxProd, b = n * minProd;\\n            maxProd = max({n, a, b});\\n            minProd = min({n, a, b});\\n            ans = max(ans, maxProd);\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        max__dp = [1] * (n + 1)\\n        min_dp = [1] * (n + 1)\\n        ans = float('-inf')\\n\\n        for i in range(1, n + 1):\\n            max__dp[i] = max(max__dp[i - 1] * nums[i - 1],\\n                             min_dp[i - 1] * nums[i - 1], nums[i - 1])\\n            min_dp[i] = min(max__dp[i - 1] * nums[i - 1],\\n                            min_dp[i - 1] * nums[i - 1], nums[i - 1])\\n            ans = max(ans, max__dp[i])\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        a = b = 1\\n        ans = float('-inf')\\n\\n        for i in range(1, n + 1):\\n            temp = a\\n            a = max(a * nums[i - 1],\\n                    b * nums[i - 1], nums[i - 1])\\n            b = min(temp * nums[i - 1],\\n                    b * nums[i - 1], nums[i - 1])\\n            ans = max(ans, a)\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"min-stack\":{\n    \"id\": \"155\",\n    \"name\": \"min-stack\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"往minstack中push的判断条件。应该是stack为空或者x小于等于minstack栈顶元素\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"amazon\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"google\"\n        },\n        {\n            \"name\": \"snapchat\"\n        },\n        {\n            \"name\": \"uber\"\n        },\n        {\n            \"name\": \"zenefits\"\n        },\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/155.min-stack.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/155.min-stack.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic class MinStack {\\n\\n    // 数据栈\\n    private Stack<Integer> data;\\n    // 辅助栈\\n    private Stack<Integer> helper;\\n\\n    /**\\n     * initialize your data structure here.\\n     */\\n    public MinStack() {\\n        data = new Stack<>();\\n        helper = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        // 辅助栈在必要的时候才增加\\n        data.add(x);\\n        if (helper.isEmpty() || helper.peek() >= x) {\\n            helper.add(x);\\n        }\\n    }\\n\\n    public void pop() {\\n        // 关键 3：data 一定得 pop()\\n        if (!data.isEmpty()) {\\n            // 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，\\n            // 因此下面的比较可以使用 \\\"==\\\" 运算符\\n            int top = data.pop();\\n            if(top == helper.peek()){\\n                helper.pop();\\n            }\\n        }\\n    }\\n\\n    public int top() {\\n        if(!data.isEmpty()){\\n            return data.peek();\\n        }\\n    }\\n\\n    public int getMin() {\\n        if(!helper.isEmpty()){\\n            return helper.peek();\\n        }\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MinStack {\\n    long min;\\n    Stack<Long> stack;\\n    \\n    /** initialize your data structure here. */\\n    public MinStack() {\\n        stack = new Stack<>();\\n    }\\n    \\n    public void push(int x) {\\n        if (stack.isEmpty()) {\\n            stack.push(0L);\\n            min = x;\\n        }\\n        else {\\n            stack.push(x - min);\\n            if (x < min)\\n                min = x;\\n        }\\n    }\\n    \\n    public void pop() {\\n        long p = stack.pop();\\n        \\n        if (p < 0) {\\n            // if (p < 0), the popped value is the min\\n            // Recall p is added by this statement: stack.push(x - min);\\n            // So, p = x - old_min\\n            // old_min = x - p\\n            // again, if (p < 0), x is the min so:\\n            // old_min = min - p\\n            min = min - p;\\n        }\\n    }\\n    \\n    public int top() {\\n        long p = stack.peek();\\n        \\n        if (p < 0) {\\n            return (int) min;\\n        }\\n        else {\\n            // p = x - min\\n            // x = p + min\\n            return (int) (p + min);\\n        }\\n    }\\n    \\n    public int getMin() {\\n        return (int) min;    \\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * initialize your data structure here.\\n */\\nvar MinStack = function() {\\n    this.stack = []\\n    this.minStack = []\\n};\\n\\n/** \\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n    this.stack.push(x)\\n    if (this.minStack.length == 0 ||  x <= this.minStack[this.minStack.length - 1]) {\\n        this.minStack.push(x)\\n    }\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n    const x = this.stack.pop()\\n    if (x !== void 0 &&  x === this.minStack[this.minStack.length - 1]) {\\n        this.minStack.pop()\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n    return this.stack[this.stack.length - 1]\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.min = function() {\\n    return this.minStack[this.minStack.length - 1]\\n};\\n\\n/** \\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(x)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.min()\\n */\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=155 lang=javascript\\n *\\n * [155] Min Stack\\n */\\n/**\\n * initialize your data structure here.\\n */\\nvar MinStack = function() {\\n  this.stack = [];\\n  this.minV = Number.MAX_VALUE;\\n};\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nMinStack.prototype.push = function(x) {\\n  // update 'min'\\n  const minV = this.minV;\\n  if (x < this.minV) {\\n    this.minV = x;\\n  }\\n  return this.stack.push(x - minV);\\n};\\n\\n/**\\n * @return {void}\\n */\\nMinStack.prototype.pop = function() {\\n  const item = this.stack.pop();\\n  const minV = this.minV;\\n\\n  if (item < 0) {\\n    this.minV = minV - item;\\n    return minV;\\n  }\\n  return item + minV;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.top = function() {\\n  const item = this.stack[this.stack.length - 1];\\n  const minV = this.minV;\\n\\n  if (item < 0) {\\n    return minV;\\n  }\\n  return item + minV;\\n};\\n\\n/**\\n * @return {number}\\n */\\nMinStack.prototype.min = function() {\\n  return this.minV;\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * var obj = new MinStack()\\n * obj.push(x)\\n * obj.pop()\\n * var param_3 = obj.top()\\n * var param_4 = obj.min()\\n */\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass MinStack {\\n    stack<int> data;\\n    stack<int> helper;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x);\\n        if(helper.empty() || helper.top() >= x)\\n        {\\n            helper.push(x);\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        int top = data.top();\\n        data.pop();\\n        if(top == helper.top())\\n        {\\n            helper.pop();\\n        }\\n        \\n    }\\n    \\n    int top() {\\n        return data.top();\\n    }\\n    \\n    int getMin() {\\n        return helper.top();\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(x);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass MinStack {\\n    stack<long> data;\\n    long min = INT_MAX;\\npublic:\\n    /** initialize your data structure here. */\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        data.push(x - min);\\n        if(x < min)\\n        {\\n            min = x;\\n        }\\n        \\n    }\\n    \\n    void pop() {\\n        long top = data.top();\\n        data.pop();\\n        // 更新最小值\\n        if(top < 0)\\n        {\\n            min -= top;\\n        }\\n        \\n    }\\n    \\n    int top() {\\n        long top = data.top();\\n        // 最小值为 min\\n        if (top < 0)\\n        {\\n            return min;\\n        }\\n        else{\\n            return min+top;\\n        }\\n    }\\n    \\n    int getMin() {\\n        return min;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(x);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass MinStack:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.stack = []\\n        self.minstack = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x)\\n        if not self.minstack or x <= self.minstack[-1]:\\n            self.minstack.append(x)\\n\\n    def pop(self) -> None:\\n        tmp = self.stack.pop()\\n        if tmp == self.minstack[-1]:\\n            self.minstack.pop()\\n\\n    def top(self) -> int:\\n        return self.stack[-1]\\n\\n    def min(self) -> int:\\n        return self.minstack[-1]\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(x)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.min()\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass MinStack:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.minV = float('inf')\\n        self.stack = []\\n\\n    def push(self, x: int) -> None:\\n        self.stack.append(x - self.minV)\\n        if x < self.minV:\\n            self.minV = x\\n\\n    def pop(self) -> None:\\n        if not self.stack:\\n            return\\n        tmp = self.stack.pop()\\n        if tmp < 0:\\n            self.minV -= tmp\\n\\n    def top(self) -> int:\\n        if not self.stack:\\n            return\\n        tmp = self.stack[-1]\\n        if tmp < 0:\\n            return self.minV\\n        else:\\n            return self.minV + tmp\\n\\n    def min(self) -> int:\\n        return self.minV\\n\\n\\n\\n# Your MinStack object will be instantiated and called as such:\\n# obj = MinStack()\\n# obj.push(x)\\n# obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.min()\\n\"\n        }\n    ]\n},\n\"Intersection-of-Two-Linked-Lists\":{\n    \"id\": \"160\",\n    \"name\": \"Intersection-of-Two-Linked-Lists\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/160.Intersection-of-Two-Linked-Lists.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/160.Intersection-of-Two-Linked-Lists.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"x\\ndata = new Set() // 存放A链表的所有节点的地址\\n\\nwhile A不为空{\\n  哈希表中添加A链表当前节点\\n  A指针向后移动\\n}\\n\\nwhile B不为空{\\n  if 如果哈希表中含有B链表当前节点\\n    return B\\n  B指针向后移动\\n}\\n\\nreturn null // 两条链表没有相交点\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nlet data = new Set();\\nwhile (A !== null) {\\n  data.add(A);\\n  A = A.next;\\n}\\nwhile (B !== null) {\\n  if (data.has(B)) return B;\\n  B = B.next;\\n}\\nreturn null;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\na = headA\\nb = headB\\nwhile a,b指针不相等时 {\\n    if a指针为空时\\n      a指针重定位到链表 B的头结点\\n    else\\n      a指针向后移动一位\\n    if b指针为空时\\n      b指针重定位到链表 A的头结点\\n    else\\n      b指针向后移动一位\\n}\\nreturn a\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar getIntersectionNode = function (headA, headB) {\\n  let a = headA,\\n    b = headB;\\n  while (a != b) {\\n    a = a === null ? headB : a.next;\\n    b = b === null ? headA : b.next;\\n  }\\n  return a;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\\n        a, b = headA, headB\\n        while a != b:\\n            a = a.next if a else headB\\n            b = b.next if b else headA\\n        return a\\n\"\n        }\n    ]\n},\n\"two-sum-ii-input-array-is-sorted\":{\n    \"id\": \"167\",\n    \"name\": \"two-sum-ii-input-array-is-sorted\",\n    \"pre\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"由于是有序的，因此双指针更好\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"amazon\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/167.two-sum-ii-input-array-is-sorted.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/167.two-sum-ii-input-array-is-sorted.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n        int n = numbers.length;\\n        int left = 0;\\n        int right = n-1;\\n        while(left <= right)\\n        {\\n            if(numbers[left] + numbers[right] == target)\\n            {\\n                return new int[]{left + 1, right + 1};\\n            }\\n            else if (numbers[left] + numbers[right] > target)\\n            {\\n                right--;\\n            }\\n            else\\n            {\\n                left++;\\n            }\\n        }\\n\\n        return new int[]{-1, -1};\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} numbers\\n * @param {number} target\\n * @return {number[]}\\n */\\nvar twoSum = function (numbers, target) {\\n  const visited = {}; // 记录出现的数字， 空间复杂度N\\n\\n  for (let index = 0; index < numbers.length; index++) {\\n    const element = numbers[index];\\n    if (visited[target - element] !== void 0) {\\n      return [visited[target - element], index + 1];\\n    }\\n    visited[element] = index + 1;\\n  }\\n  return [];\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& numbers, int target) {\\n        int n = numbers.size();\\n        int left = 0;\\n        int right = n-1;\\n        while(left <= right)\\n        {\\n            if(numbers[left] + numbers[right] == target)\\n            {\\n                return {left + 1, right + 1};\\n            }\\n            else if (numbers[left] + numbers[right] > target)\\n            {\\n                right--;\\n            }\\n            else\\n            {\\n                left++;\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        visited = {}\\n        for index, number in enumerate(numbers):\\n            if target - number in visited:\\n                return [visited[target-number], index+1]\\n            else:\\n                visited[number] = index + 1\\n\\n# 双指针思路实现\\nclass Solution:\\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\\n        left, right = 0, len(numbers) - 1\\n        while left < right:\\n            if numbers[left] + numbers[right] < target:\\n                left += 1\\n            if numbers[left] + numbers[right] > target:\\n                right -= 1\\n            if numbers[left] + numbers[right] == target:\\n                return [left+1, right+1]\\n\"\n        }\n    ]\n},\n\"majority-element\":{\n    \"id\": \"169\",\n    \"name\": \"majority-element\",\n    \"pre\": [\n        {\n            \"text\": \"投票算法\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"投票算法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"adobe\"\n        },\n        {\n            \"name\": \"zenefits\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/169.majority-element.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/169.majority-element.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar majorityElement = function (nums) {\\n  let count = 1;\\n  let majority = nums[0];\\n  for (let i = 1; i < nums.length; i++) {\\n    if (count === 0) {\\n      majority = nums[i];\\n    }\\n    if (nums[i] === majority) {\\n      count++;\\n    } else {\\n      count--;\\n    }\\n  }\\n  return majority;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        int ans = 0, cnt = 0;\\n        for (int n : nums) {\\n            if (ans == n) ++cnt;\\n            else if (cnt > 0) --cnt;\\n            else {\\n                ans = n;\\n                cnt = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> int:\\n        count, majority = 1, nums[0]\\n        for num in nums[1:]:\\n            if count == 0:\\n                majority = num\\n            if num == majority:\\n                count += 1\\n            else:\\n                count -= 1\\n        return majority\\n\"\n        }\n    ]\n},\n\"factorial-trailing-zeroes\":{\n    \"id\": \"172\",\n    \"name\": \"factorial-trailing-zeroes\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"数论\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/172.factorial-trailing-zeroes.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/172.factorial-trailing-zeroes.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=172 lang=javascript\\n *\\n * [172] Factorial Trailing Zeroes\\n */\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar trailingZeroes = function (n) {\\n  // tag: 数论\\n\\n  // if (n === 0) return n;\\n\\n  // 递归： f(n) = n / 5 + f(n / 5)\\n  // return Math.floor(n / 5)  + trailingZeroes(Math.floor(n / 5));\\n  let count = 0;\\n  while (n >= 5) {\\n    count += Math.floor(n / 5);\\n    n = Math.floor(n / 5);\\n  }\\n  return count;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nclass Solution {\\n    public int trailingZeroes(int n) {\\n        int res = 0;\\n        while(n >= 5)\\n        {\\n            n/=5;\\n            res += n;\\n        }\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int trailingZeroes(int n) {\\n        int res = 0;\\n        while(n >= 5)\\n        {\\n            n/=5;\\n            res += n;\\n        }\\n        return res;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        count = 0\\n        while n >= 5:\\n            n = n // 5\\n            count += n\\n        return count\\n\\n\\n# 递归\\nclass Solution:\\n    def trailingZeroes(self, n: int) -> int:\\n        if n == 0: return 0\\n        return n // 5 + self.trailingZeroes(n // 5)\\n\"\n        }\n    ]\n},\n\"reverse-bits\":{\n    \"id\": \"190\",\n    \"name\": \"reverse-bits\",\n    \"pre\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.可以用任何数字和1进行位运算的结果都取决于该数字最后一位的特性简化操作和提高性能eg:\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"n&1===1,说明n的最后一位是1\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"n&1===0,说明n的最后一位是02.对于JS，ES规范在之前很多版本都是没有无符号整形的，转化为无符号，可以用一个trick`n>>>0`3.双\\\"指针\\\"模型4.bit运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"airbnb\"\n        },\n        {\n            \"name\": \"apple\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/190.reverse-bits.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/190.reverse-bits.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number} n - a positive integer\\n * @return {number} - a positive integer\\n */\\nvar reverseBits = function (n) {\\n  let res = 0;\\n  for (let i = 0; i < 32; i++) {\\n    res = (res << 1) + (n & 1);\\n    n = n >>> 1;\\n  }\\n\\n  return res >>> 0;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    # @param n, an integer\\n    # @return an integer\\n    def reverseBits(self, n):\\n        result = 0\\n        for i in range(32):\\n            result = (result << 1) + (n & 1)\\n            n >>= 1\\n        return result\\n\"\n        }\n    ]\n},\n\"number-of-1-bits\":{\n    \"id\": \"191\",\n    \"name\": \"number-of-1-bits\",\n    \"pre\": [\n        {\n            \"text\": \"位运算\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/bit.md\",\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.`n&(n\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1)`可以`消除`n最后的一个1的原理简化操作2.bit运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"apple\"\n        },\n        {\n            \"name\": \"microsoft\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/191.number-of-1-bits.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/191.number-of-1-bits.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=191 lang=javascript\\n *\\n */\\n/**\\n * @param {number} n - a positive integer\\n * @return {number}\\n */\\nvar hammingWeight = function (n) {\\n  let count = 0;\\n  while (n !== 0) {\\n    n = n & (n - 1);\\n    count++;\\n  }\\n\\n  return count;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int hammingWeight(uint32_t v) {\\n        auto count = 0;\\n        while (v != 0) {\\n            v &= (v - 1);\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nconst uint32_t ODD_BIT_MASK = 0xAAAAAAAA;\\nconst uint32_t EVEN_BIT_MASK = 0x55555555;\\nconst uint32_t ODD_2BIT_MASK = 0xCCCCCCCC;\\nconst uint32_t EVEN_2BIT_MASK = 0x33333333;\\nconst uint32_t ODD_4BIT_MASK = 0xF0F0F0F0;\\nconst uint32_t EVEN_4BIT_MASK = 0x0F0F0F0F;\\nconst uint32_t ODD_8BIT_MASK = 0xFF00FF00;\\nconst uint32_t EVEN_8BIT_MASK = 0x00FF00FF;\\nconst uint32_t ODD_16BIT_MASK = 0xFFFF0000;\\nconst uint32_t EVEN_16BIT_MASK = 0x0000FFFF;\\n\\nclass Solution {\\npublic:\\n\\n    int hammingWeight(uint32_t v) {\\n        v = (v & EVEN_BIT_MASK) + ((v & ODD_BIT_MASK) >> 1);\\n        v = (v & EVEN_2BIT_MASK) + ((v & ODD_2BIT_MASK) >> 2);\\n        v = (v & EVEN_4BIT_MASK) + ((v & ODD_4BIT_MASK) >> 4);\\n        v = (v & EVEN_8BIT_MASK) + ((v & ODD_8BIT_MASK) >> 8);\\n        return (v & EVEN_16BIT_MASK) + ((v & ODD_16BIT_MASK) >> 16);\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def hammingWeight(self, n):\\n        \\\"\\\"\\\"\\n        :type n: int\\n        :rtype: int\\n        \\\"\\\"\\\"\\n        count = 0\\n        while n:\\n            n &= n - 1\\n            count += 1\\n        return count\\n\"\n        }\n    ]\n},\n\"house-robber\":{\n    \"id\": \"198\",\n    \"name\": \"house-robber\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"airbnb\"\n        },\n        {\n            \"name\": \"linkedin\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/198.house-robber.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/198.house-robber.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nlet a = 0;\\nlet b = 0;\\n\\nfor (let i = 0; i < nums.length; i++) {\\n  const temp = b;\\n  b = Math.max(a + nums[i], b);\\n  a = temp;\\n}\\n\\nreturn b;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar rob = function (nums) {\\n  // Tag: DP\\n  const dp = [];\\n  dp[0] = 0;\\n  dp[1] = 0;\\n\\n  for (let i = 2; i < nums.length + 2; i++) {\\n    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);\\n  }\\n\\n  return dp[nums.length + 1];\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n\\n        length = len(nums)\\n        if length == 1:\\n            return nums[0]\\n        else:\\n            prev = nums[0]\\n            cur = max(prev, nums[1])\\n            for i in range(2, length):\\n                cur, prev = max(prev + nums[i], cur), cur\\n            return cur\\n\"\n        }\n    ]\n},\n\"binary-tree-right-side-view\":{\n    \"id\": \"199\",\n    \"name\": \"binary-tree-right-side-view\",\n    \"pre\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"队列中用Null(一个特殊元素)来划分每层\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"树的基本操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"层次遍历（BFS）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"二叉树的右视图可以看作是层次遍历每次只取每一层的最右边的元素\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/199.binary-tree-right-side-view.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/199.binary-tree-right-side-view.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar rightSideView = function(root) {\\n  if (!root) return [];\\n\\n  const ret = [];\\n  const queue = [root, null];\\n\\n  let levelNodes = [];\\n\\n  while (queue.length > 0) {\\n    const node = queue.shift();\\n    if (node !== null) {\\n      levelNodes.push(node.val);\\n      if (node.right) {\\n        queue.push(node.right);\\n      }\\n      if (node.left) {\\n        queue.push(node.left);\\n      }\\n    } else {\\n      // 一层遍历已经结束\\n      ret.push(levelNodes[0]);\\n      if (queue.length > 0) {\\n        queue.push(null);\\n      }\\n      levelNodes = [];\\n    }\\n  }\\n\\n  return ret;\\n};\\n\"\n        }\n    ]\n},\n\"number-of-islands\":{\n    \"id\": \"200\",\n    \"name\": \"number-of-islands\",\n    \"pre\": [\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二维数组DFS解题模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"将已经访问的元素置为0，省去visited的空间开销\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/200.number-of-islands.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/200.number-of-islands.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n   public int numIslands(char[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\\n\\n        int count = 0;\\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[0].length; col++) {\\n                if (grid[row][col] == '1') {\\n                    dfs(grid, row, col);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void dfs(char[][] grid,int row,int col) {\\n        if (row<0||row== grid.length||col<0||col==grid[0].length||grid[row][col]!='1') {\\n            return;\\n        }\\n        grid[row][col] = '0';\\n        dfs(grid, row-1, col);\\n        dfs(grid, row+1, col);\\n        dfs(grid, row, col+1);\\n        dfs(grid, row, col-1);\\n    }\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=200 lang=javascript\\n *\\n * [200] Number of Islands\\n */\\nfunction helper(grid, i, j, rows, cols) {\\n  if (i < 0 || j < 0 || i > rows - 1 || j > cols - 1 || grid[i][j] === \\\"0\\\")\\n    return;\\n\\n  grid[i][j] = \\\"0\\\";\\n\\n  helper(grid, i + 1, j, rows, cols);\\n  helper(grid, i, j + 1, rows, cols);\\n  helper(grid, i - 1, j, rows, cols);\\n  helper(grid, i, j - 1, rows, cols);\\n}\\n/**\\n * @param {character[][]} grid\\n * @return {number}\\n */\\nvar numIslands = function (grid) {\\n  let res = 0;\\n  const rows = grid.length;\\n  if (rows === 0) return 0;\\n  const cols = grid[0].length;\\n  for (let i = 0; i < rows; i++) {\\n    for (let j = 0; j < cols; j++) {\\n      if (grid[i][j] === \\\"1\\\") {\\n        helper(grid, i, j, rows, cols);\\n        res++;\\n      }\\n    }\\n  }\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int res = 0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j] == '1')\\n                {\\n                    dfs(grid, i, j);\\n                    res += 1;\\n                }\\n            }\\n        }\\n        return res;\\n\\n    }\\n    void dfs(vector<vector<char>>& grid, int i, int j)\\n    {\\n        // edge\\n        if(i<0 || i>= grid.size() || j<0 || j>= grid[0].size() || grid[i][j] != '1')\\n        {\\n            return;\\n        }\\n        grid[i][j] = '0';\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n};\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def numIslands(self, grid: List[List[str]]) -> int:\\n        if not grid: return 0\\n\\n        count = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == '1':\\n                    self.dfs(grid, i, j)\\n                    count += 1\\n\\n        return count\\n\\n    def dfs(self, grid, i, j):\\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1':\\n            return\\n        grid[i][j] = '0'\\n        self.dfs(grid, i + 1, j)\\n        self.dfs(grid, i - 1, j)\\n        self.dfs(grid, i, j + 1)\\n        self.dfs(grid, i, j - 1)\\n\\n\"\n        }\n    ]\n},\n\"bitwise-and-of-numbers-range\":{\n    \"id\": \"201\",\n    \"name\": \"bitwise-and-of-numbers-range\",\n    \"pre\": [\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"n个连续数字求与的时候，前m位都是1\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"可以用递归实现，个人认为比较难想到\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"bit运算代码：```jsn>m?rangeBitwiseAnd(m/2,n/2)<<1:m;```>每次问题规模缩小一半，这是二分法吗？\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/201.bitwise-and-of-numbers-range.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/201.bitwise-and-of-numbers-range.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nlet res = m;\\nfor (let i = m + 1; i <= n; i++) {\\n  res = res & i;\\n}\\nreturn res;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nn > m ? rangeBitwiseAnd(m / 2, n / 2) << 1 : m;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=201 lang=javascript\\n *\\n * [201] Bitwise AND of Numbers Range\\n *\\n */\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @return {number}\\n */\\nvar rangeBitwiseAnd = function (m, n) {\\n  let count = 0;\\n  while (m !== n) {\\n    m = m >> 1;\\n    n = n >> 1;\\n    count++;\\n  }\\n\\n  return n << count;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        cnt = 0\\n        while m != n:\\n            m >>= 1\\n            n >>= 1\\n            cnt += 1\\n\\n        return m << cnt\\n\"\n        }\n    ]\n},\n\"remove-linked-list-elements\":{\n    \"id\": \"203\",\n    \"name\": \"remove-linked-list-elements\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"链表的基本操作（删除指定节点）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"虚拟节点dummy简化操作>其实设置dummy节点就是为了处理特殊位置（头节点），这这道题就是如果头节点是给定的需要删除的节点呢？>为了保证代码逻辑的一致性，即不需要为头节点特殊定制逻辑，才采用的虚拟节点。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果连续两个节点都是要删除的节点，这个情况容易被忽略。eg:```js//只有下个节点不是要删除的节点才更新currentif(!next||next.val!==val){current=next;}```\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/203.remove-linked-list-elements.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/203.remove-linked-list-elements.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 只有下个节点不是要删除的节点才更新 current\\nif (!next || next.val !== val) {\\n  current = next;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function (head, val) {\\n  const dummy = {\\n    next: head,\\n  };\\n  let current = dummy;\\n\\n  while (current && current.next) {\\n    let next = current.next;\\n    if (next.val === val) {\\n      current.next = next.next;\\n      next = next.next;\\n    }\\n\\n    if (!next || next.val !== val) {\\n      current = next;\\n    }\\n  }\\n\\n  return dummy.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        prev = ListNode(0)\\n        prev.next = head\\n        cur = prev\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return prev.next\\n\"\n        }\n    ]\n},\n\"reverse-linked-list\":{\n    \"id\": \"206\",\n    \"name\": \"reverse-linked-list\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"链表的基本操作（交换）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"虚拟节点dummy简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"注意更新current和pre的位置，否则有可能出现溢出\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"adobe\"\n        },\n        {\n            \"name\": \"amazon\"\n        },\n        {\n            \"name\": \"apple\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"facebook\"\n        },\n        {\n            \"name\": \"microsoft\"\n        },\n        {\n            \"name\": \"snapchat\"\n        },\n        {\n            \"name\": \"twitter\"\n        },\n        {\n            \"name\": \"uber\"\n        },\n        {\n            \"name\": \"yahoo\"\n        },\n        {\n            \"name\": \"yelp\"\n        },\n        {\n            \"name\": \"zenefits\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/206.reverse-linked-list.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/206.reverse-linked-list.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseList(ListNode head) {\\n        ListNode pre = null, cur = head;\\n\\n        while (cur != null) {\\n            ListNode next = cur.next;\\n            cur.next = pre;\\n            pre = cur;\\n            cur = next;\\n        }\\n\\n        return pre;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar reverseList = function (head) {\\n  if (!head || !head.next) return head;\\n\\n  let cur = head;\\n  let pre = null;\\n\\n  while (cur) {\\n    const next = cur.next;\\n    cur.next = pre;\\n    pre = cur;\\n    cur = next;\\n  }\\n\\n  return pre;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar reverseList = function (head) {\\n  // 递归结束条件\\n  if (head === null || head.next === null) {\\n    return head;\\n  }\\n\\n  // 递归反转 子链表\\n  let newReverseList = reverseList(head.next);\\n  // 获取原来链表的第 2 个节点 newReverseListTail\\n  let newReverseListTail = head.next;\\n  // 调整原来头结点和第 2 个节点的指向\\n  newReverseListTail.next = head;\\n  head.next = null;\\n\\n  // 将调整后的链表返回\\n  return newReverseList;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* prev = NULL;\\n        ListNode* cur = head;\\n        ListNode* next = NULL;\\n        while (cur != NULL) {\\n            next = cur->next;\\n            cur->next = prev;\\n            prev = cur;\\n            cur = next;\\n        }\\n        return prev;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n// 普通递归\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* tail = nullptr;\\n        return reverseRecursive(head, tail);\\n    }\\n\\n    ListNode* reverseRecursive(ListNode *head, ListNode *&tail) {\\n        if (head == nullptr) {\\n            tail = nullptr;\\n            return head;\\n        }\\n        if (head->next == nullptr) {\\n            tail = head;\\n            return head;\\n        }\\n        auto h = reverseRecursive(head->next, tail);\\n        if (tail != nullptr) {\\n            tail->next = head;\\n            tail = head;\\n            head->next = nullptr;\\n        }\\n        return h;\\n    }\\n};\\n\\n// （类似）尾递归\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if (head == nullptr) return head;\\n        return reverseRecursive(nullptr, head, head->next);\\n    }\\n\\n    ListNode* reverseRecursive(ListNode *prev, ListNode *head, ListNode *next)\\n    {\\n        if (next == nullptr) return head;\\n        auto n = next->next;\\n        next->next = head;\\n        head->next = prev;\\n        return reverseRecursive(head, next, n);\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head: return None\\n        prev = None\\n        cur = head\\n        while cur:\\n            cur.next, prev, cur = prev, cur, cur.next\\n        return prev\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def reverseList(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        ans = self.reverseList(head.next)\\n        head.next.next = head\\n        head.next = None\\n        return ans\\n\"\n        }\n    ]\n},\n\"implement-trie-prefix-tree\":{\n    \"id\": \"208\",\n    \"name\": \"implement-trie-prefix-tree\",\n    \"pre\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/208.implement-trie-prefix-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/208.implement-trie-prefix-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction TrieNode(val) {\\n  this.val = val; // 当前的字母\\n  this.children = []; // 题目要求字典仅有a-z，那么其长度最大为26（26个字母）\\n  this.isWord = false;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction computeIndex(c) {\\n  return c.charCodeAt(0) - \\\"a\\\".charCodeAt(0);\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=208 lang=javascript\\n *\\n * [208] Implement Trie (Prefix Tree)\\n *\\n * https://leetcode.com/problems/implement-trie-prefix-tree/description/\\n *\\n * algorithms\\n * Medium (36.93%)\\n * Total Accepted:    172K\\n * Total Submissions: 455.5K\\n * Testcase Example:  '[\\\"Trie\\\",\\\"insert\\\",\\\"search\\\",\\\"search\\\",\\\"startsWith\\\",\\\"insert\\\",\\\"search\\\"]\\\\n[[],[\\\"apple\\\"],[\\\"apple\\\"],[\\\"app\\\"],[\\\"app\\\"],[\\\"app\\\"],[\\\"app\\\"]]'\\n *\\n * Implement a trie with insert, search, and startsWith methods.\\n *\\n * Example:\\n *\\n *\\n * Trie trie = new Trie();\\n *\\n * trie.insert(\\\"apple\\\");\\n * trie.search(\\\"apple\\\");   // returns true\\n * trie.search(\\\"app\\\");     // returns false\\n * trie.startsWith(\\\"app\\\"); // returns true\\n * trie.insert(\\\"app\\\");\\n * trie.search(\\\"app\\\");     // returns true\\n *\\n *\\n * Note:\\n *\\n *\\n * You may assume that all inputs are consist of lowercase letters a-z.\\n * All inputs are guaranteed to be non-empty strings.\\n *\\n *\\n */\\nfunction TrieNode(val) {\\n  this.val = val;\\n  this.children = [];\\n  this.isWord = false;\\n}\\n\\nfunction computeIndex(c) {\\n  return c.charCodeAt(0) - \\\"a\\\".charCodeAt(0);\\n}\\n/**\\n * Initialize your data structure here.\\n */\\nvar Trie = function () {\\n  this.root = new TrieNode(null);\\n};\\n\\n/**\\n * Inserts a word into the trie.\\n * @param {string} word\\n * @return {void}\\n */\\nTrie.prototype.insert = function (word) {\\n  let ws = this.root;\\n  for (let i = 0; i < word.length; i++) {\\n    const c = word[i];\\n    const current = computeIndex(c);\\n    if (!ws.children[current]) {\\n      ws.children[current] = new TrieNode(c);\\n    }\\n    ws = ws.children[current];\\n  }\\n  ws.isWord = true;\\n};\\n\\n/**\\n * Returns if the word is in the trie.\\n * @param {string} word\\n * @return {boolean}\\n */\\nTrie.prototype.search = function (word) {\\n  let ws = this.root;\\n  for (let i = 0; i < word.length; i++) {\\n    const c = word[i];\\n    const current = computeIndex(c);\\n    if (!ws.children[current]) return false;\\n    ws = ws.children[current];\\n  }\\n  return ws.isWord;\\n};\\n\\n/**\\n * Returns if there is any word in the trie that starts with the given prefix.\\n * @param {string} prefix\\n * @return {boolean}\\n */\\nTrie.prototype.startsWith = function (prefix) {\\n  let ws = this.root;\\n  for (let i = 0; i < prefix.length; i++) {\\n    const c = prefix[i];\\n    const current = computeIndex(c);\\n    if (!ws.children[current]) return false;\\n    ws = ws.children[current];\\n  }\\n  return true;\\n};\\n\\n/**\\n * Your Trie object will be instantiated and called as such:\\n * var obj = new Trie()\\n * obj.insert(word)\\n * var param_2 = obj.search(word)\\n * var param_3 = obj.startsWith(prefix)\\n */\\n\"\n        }\n    ]\n},\n\"minimum-size-subarray-sum\":{\n    \"id\": \"209\",\n    \"name\": \"minimum-size-subarray-sum\",\n    \"pre\": [\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"滑动窗口简化操作(滑窗口适合用于求解这种要求`连续`的题目)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/209.minimum-size-subarray-sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/209.minimum-size-subarray-sum.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=209 lang=javascript\\n *\\n * [209] Minimum Size Subarray Sum\\n *\\n */\\n/**\\n * @param {number} s\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minSubArrayLen = function (s, nums) {\\n  if (nums.length === 0) return 0;\\n  const slideWindow = [];\\n  let acc = 0;\\n  let min = null;\\n\\n  for (let i = 0; i < nums.length + 1; i++) {\\n    const num = nums[i];\\n\\n    while (acc >= s) {\\n      if (min === null || slideWindow.length < min) {\\n        min = slideWindow.length;\\n      }\\n      acc = acc - slideWindow.shift();\\n    }\\n\\n    slideWindow.push(num);\\n\\n    acc = slideWindow.reduce((a, b) => a + b, 0);\\n  }\\n\\n  return min || 0;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar minSubArrayLen = function (s, nums) {\\n  if (nums.length === 0) return 0;\\n  const slideWindow = [];\\n  let acc = 0;\\n  let min = null;\\n\\n  for (let i = 0; i < nums.length + 1; i++) {\\n    const num = nums[i];\\n\\n    while (acc > s) {\\n      acc = acc - slideWindow.shift();\\n    }\\n    if (acc === s) {\\n      if (min === null || slideWindow.length < min) {\\n        min = slideWindow.length;\\n      }\\n      slideWindow.shift();\\n    }\\n\\n    slideWindow.push(num);\\n\\n    acc = slideWindow.reduce((a, b) => a + b, 0);\\n  }\\n\\n  return min || 0;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def minSubArrayLen(self, s: int, nums: List[int]) -> int:\\n        l = total = 0\\n        ans = len(nums) + 1\\n        for r in range(len(nums)):\\n            total += nums[r]\\n            while total >= s:\\n                ans = min(ans, r - l + 1)\\n                total -= nums[l]\\n                l += 1\\n        return  0 if ans == len(nums) + 1 else ans\\n\"\n        }\n    ]\n},\n\"add-and-search-word-data-structure-design\":{\n    \"id\": \"211\",\n    \"name\": \"add-and-search-word-data-structure-design\",\n    \"pre\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"前缀树（也叫字典树），英文名Trie（读作tree或者try）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/211.add-and-search-word-data-structure-design.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/211.add-and-search-word-data-structure-design.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef search(self, word):\\n        \\\"\\\"\\\"\\n        Returns if the word is in the trie.\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for i, w in enumerate(word):\\n            if w == '.':\\n                wizards = []\\n                for k in curr.keys():\\n                    if k == '#':\\n                        continue\\n                    wizards.append(self.search(word[:i] + k + word[i + 1:]))\\n                return any(wizards)\\n            if w not in curr:\\n                return False\\n            curr = curr[w]\\n        return \\\"#\\\" in curr\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef search(self, word):\\n        \\\"\\\"\\\"\\n        Returns if the word is in the trie.\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for w in word:\\n            if w not in curr:\\n                return False\\n            curr = curr[w]\\n        return \\\"#\\\" in curr\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Trie:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.Trie = {}\\n\\n    def insert(self, word):\\n        \\\"\\\"\\\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: void\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for w in word:\\n            if w not in curr:\\n                curr[w] = {}\\n            curr = curr[w]\\n        curr['#'] = 1\\n\\n    def search(self, word):\\n        \\\"\\\"\\\"\\n        Returns if the word is in the trie.\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for i, w in enumerate(word):\\n            if w == '.':\\n                wizards = []\\n                for k in curr.keys():\\n                    if k == '#':\\n                        continue\\n                    wizards.append(self.search(word[:i] + k + word[i + 1:]))\\n                return any(wizards)\\n            if w not in curr:\\n                return False\\n            curr = curr[w]\\n        return \\\"#\\\" in curr\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass WordDictionary:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.trie = Trie()\\n\\n    def addWord(self, word: str) -> None:\\n        \\\"\\\"\\\"\\n        Adds a word into the data structure.\\n        \\\"\\\"\\\"\\n        self.trie.insert(word)\\n\\n    def search(self, word: str) -> bool:\\n        \\\"\\\"\\\"\\n        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.\\n        \\\"\\\"\\\"\\n        return self.trie.search(word)\\n\\n\\n# Your WordDictionary object will be instantiated and called as such:\\n# obj = WordDictionary()\\n# obj.addWord(word)\\n# param_2 = obj.search(word)\\n\"\n        }\n    ]\n},\n\"word-search-ii\":{\n    \"id\": \"212\",\n    \"name\": \"word-search-ii\",\n    \"pre\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md\",\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"深度优先遍历\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md\",\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"小岛专题\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/island.md\",\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"剪枝\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"前缀树（也叫字典树），英文名Trie（读作tree或者try）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"剪枝的技巧\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/212.word-search-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/212.word-search-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Trie:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.Trie = {}\\n\\n    def insert(self, word):\\n        \\\"\\\"\\\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: void\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for w in word:\\n            if w not in curr:\\n                curr[w] = {}\\n            curr = curr[w]\\n        curr['#'] = 1\\n\\n    def startsWith(self, prefix):\\n        \\\"\\\"\\\"\\n        Returns if there is any word in the trie that starts with the given prefix.\\n        :type prefix: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n\\n        curr = self.Trie\\n        for w in prefix:\\n            if w not in curr:\\n                return False\\n            curr = curr[w]\\n        return True\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\\n        m = len(board)\\n        if m == 0:\\n            return []\\n        n = len(board[0])\\n        trie = Trie()\\n        seen = None\\n        res = set()\\n        for word in words:\\n            trie.insert(word)\\n\\n        def dfs(s, i, j):\\n            if (i, j) in seen or i < 0 or i >= m or j < 0 or j >= n or not trie.startsWith(s):\\n                return\\n            s += board[i][j]\\n            seen[(i, j)] = True\\n\\n            if s in words:\\n                res.add(s)\\n            dfs(s, i + 1, j)\\n            dfs(s, i - 1, j)\\n            dfs(s, i, j + 1)\\n            dfs(s, i, j - 1)\\n\\n            del seen[(i, j)]\\n\\n        for i in range(m):\\n            for j in range(n):\\n                seen = dict()\\n                dfs(\\\"\\\", i, j)\\n        return list(res)\\n\"\n        }\n    ]\n},\n\"kth-largest-element-in-an-array\":{\n    \"id\": \"215\",\n    \"name\": \"kth-largest-element-in-an-array\",\n    \"pre\": [\n        {\n            \"text\": \"堆\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"Quick Select\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析1.直接排序很简单2.堆（Heap）主要是要维护一个K大小的小顶堆，扫描一遍数组，最后堆顶元素即是所求。3.QuickSelect,关键是是取pivot，对数组区间做partition，比较pivot的位置，类似二分，取pivot左边或右边继续递归查找。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/215.kth-largest-element-in-an-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/215.kth-largest-element-in-an-array.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass KthLargestElementSort {\\n public int findKthlargest2(int[] nums, int k) {\\n    Arrays.sort(nums);\\n    return nums[nums.length - k];\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass KthLargestElementHeap {\\n  public int findKthLargest(int[] nums, int k) {\\n      PriorityQueue<Integer> pq = new PriorityQueue<>();\\n      for (int num : nums) {\\n        pq.offer(num);\\n        if (pq.size() > k) {\\n          pq.poll();\\n        }\\n      }\\n      return pq.poll();\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass KthLargestElementQuickSelect {\\n    static Random random = new Random();\\n    public int findKthLargest3(int[] nums, int k) {\\n      int len = nums.length;\\n      return select(nums, 0, len - 1, len - k);\\n    }\\n    \\n    private int select(int[] nums, int left, int right, int k) {\\n      if (left == right) return nums[left];\\n      // random select pivotIndex between left and right\\n      int pivotIndex = left + random.nextInt(right - left);\\n      // do partition, move smaller than pivot number into pivot left\\n      int pos = partition(nums, left, right, pivotIndex);\\n      if (pos == k) {\\n        return nums[pos];\\n      } else if (pos > k) {\\n        return select(nums, left, pos - 1, k);\\n      } else {\\n        return select(nums, pos + 1, right, k);\\n      }\\n    }\\n    \\n    private int partition(int[] nums, int left, int right, int pivotIndex) {\\n      int pivot = nums[pivotIndex];\\n      // move pivot to end\\n      swap(nums, right, pivotIndex);\\n      int pos = left;\\n      // move smaller num to pivot left\\n      for (int i = left; i <= right; i++) {\\n        if (nums[i] < pivot) {\\n          swap(nums, pos++, i);\\n        }\\n      }\\n      // move pivot to original place\\n      swap(nums, right, pos);\\n      return pos;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n      int tmp = nums[i];\\n      nums[i] = nums[j];\\n      nums[j] = tmp;\\n    }\\n}\\n\"\n        }\n    ]\n},\n\"contains-duplicate-ii\":{\n    \"id\": \"219\",\n    \"name\": \"contains-duplicate-ii\",\n    \"pre\": [\n        {\n            \"text\": \"hashmap\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/219.contains-duplicate-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/219.contains-duplicate-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.get(nums[i]) != null && (i-map.get(nums[i])) <= k)\\n            {\\n                return true;\\n            }\\n            map.put(nums[i], i);\\n        }\\n        return false;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {boolean}\\n */\\nvar containsNearbyDuplicate = function (nums, k) {\\n  const visited = {};\\n  for (let i = 0; i < nums.length; i++) {\\n    const num = nums[i];\\n    if (visited[num] !== undefined && i - visited[num] <= k) {\\n      return true;\\n    }\\n    visited[num] = i;\\n  }\\n  return false;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        d = {}\\n        for index, num in enumerate(nums):\\n            if num in d and index - d[num] <= k:\\n                return True\\n            d[num] = index\\n        return False\\n\"\n        }\n    ]\n},\n\"contains-duplicate-iii\":{\n    \"id\": \"220\",\n    \"name\": \"contains-duplicate-iii\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分桶排序思想的应用\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/220.contains-duplicate-iii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/220.contains-duplicate-iii.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        bucket = dict()\\n        if t < 0:\\n            return False\\n        for i in range(len(nums)):\\n            nth = nums[i] // (t + 1)\\n            if nth in bucket:\\n                return True\\n            if nth - 1 in bucket and abs(nums[i] - bucket[nth - 1]) <= t:\\n                return True\\n            if nth + 1 in bucket and abs(nums[i] - bucket[nth + 1]) <= t:\\n                return True\\n            bucket[nth] = nums[i]\\n            # 如果数组有相同的数会有影响么？答案是不会，因为如果有相同的数，我们直接就会在前面返回 true 了。\\n            if i >= k:\\n                bucket.pop(nums[i - k] // (t + 1))\\n        return False\\n\\n\"\n        }\n    ]\n},\n\"maximal-square\":{\n    \"id\": \"221\",\n    \"name\": \"maximal-square\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"DP\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"递归公式可以利用dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1][j]和dp[i][j\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1]的计算结果，而不用重新计算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"空间复杂度可以降低到O(n),n为列数\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/221.maximal-square.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/221.maximal-square.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=221 lang=javascript\\n *\\n * [221] Maximal Square\\n */\\n/**\\n * @param {character[][]} matrix\\n * @return {number}\\n */\\nvar maximalSquare = function (matrix) {\\n  if (matrix.length === 0) return 0;\\n  const dp = [];\\n  const rows = matrix.length;\\n  const cols = matrix[0].length;\\n  let max = Number.MIN_VALUE;\\n\\n  for (let i = 0; i < rows + 1; i++) {\\n    if (i === 0) {\\n      dp[i] = Array(cols + 1).fill(0);\\n    } else {\\n      dp[i] = [0];\\n    }\\n  }\\n\\n  for (let i = 1; i < rows + 1; i++) {\\n    for (let j = 1; j < cols + 1; j++) {\\n      if (matrix[i - 1][j - 1] === \\\"1\\\") {\\n        dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;\\n        max = Math.max(max, dp[i][j]);\\n      } else {\\n        dp[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  return max * max;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\\n        res = 0\\n        m = len(matrix)\\n        if m == 0:\\n            return 0\\n        n = len(matrix[0])\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 if matrix[i - 1][j - 1] == \\\"1\\\" else 0\\n                res = max(res, dp[i][j])\\n        return res ** 2\\n\"\n        }\n    ]\n},\n\"invert-binary-tree\":{\n    \"id\": \"226\",\n    \"name\": \"invert-binary-tree\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"递归简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"如果树很高，建议使用栈来代替递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"这道题目对顺序没要求的，因此队列数组操作都是一样的，无任何区别\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/226.invert-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/226.invert-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {TreeNode}\\n */\\nvar invertTree = function (root) {\\n  if (!root) return root;\\n  // 递归\\n  //   const left = root.left;\\n  //   const right = root.right;\\n  //   root.right = invertTree(left);\\n  //   root.left = invertTree(right);\\n  // 我们用stack来模拟递归\\n  // 本质上递归是利用了执行栈，执行栈也是一种栈\\n  // 其实这里使用队列也是一样的，因为这里顺序不重要\\n\\n  const stack = [root];\\n  let current = null;\\n  while ((current = stack.shift())) {\\n    const left = current.left;\\n    const right = current.right;\\n    current.right = left;\\n    current.left = right;\\n    if (left) {\\n      stack.push(left);\\n    }\\n    if (right) {\\n      stack.push(right);\\n    }\\n  }\\n  return root;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def invertTree(self, root: TreeNode) -> TreeNode:\\n        if not root:\\n            return None\\n        stack = [root]\\n        while stack:\\n            node = stack.pop(0)\\n            node.left, node.right = node.right, node.left\\n            if node.left:\\n                stack.append(node.left)\\n            if node.right:\\n                stack.append(node.right)\\n        return root\\n\"\n        }\n    ]\n},\n\"basic-calculator-ii\":{\n    \"id\": \"227\",\n    \"name\": \"basic-calculator-ii\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"区分一目和二目运算符，并使用栈来简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"记录pre_flag，即上一次出现的操作符\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"使用哨兵简化操作。一个是s的$，另一个是pre_flag的+\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/227.basic-calculator-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/227.basic-calculator-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n1 + 2\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n+ 1 + 2\\n# 可看成\\n(+1)(+2)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n(-1)(+2)(+3)(-4)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n(5) / (2)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n(3) * (4)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        stack = []\\n        s += '$'\\n        pre_flag = '+'\\n        num = 0\\n\\n        for c in s:\\n            if c.isdigit():\\n                num = num * 10 + int(c)\\n            elif c == ' ': continue\\n            else:\\n                if pre_flag == '+':\\n                    stack.append(num)\\n                elif pre_flag == '-':\\n                    stack.append(-num)\\n                elif pre_flag == '*':\\n                    stack.append(stack.pop() * num)\\n                elif pre_flag == '/':\\n                    stack.append(int(stack.pop() / num))\\n                pre_flag = c\\n                num = 0\\n        return sum(stack)\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        def dfs(s, start):\\n            stack = []\\n            pre_flag = '+'\\n            num = 0\\n            i = start\\n            while i < len(s):\\n                c = s[i]\\n                if  c == ' ':\\n                    i += 1\\n                    continue\\n                elif c == '(':\\n                    i, num = dfs(s, i+1)\\n                elif c.isdigit():\\n                    num = num * 10 + int(c)\\n                else:\\n                    if pre_flag == '+':\\n                        stack.append(num)\\n                    elif pre_flag == '-':\\n                        stack.append(-num)\\n                    if c == ')': break\\n                    pre_flag = c\\n                    num = 0\\n                i += 1\\n            return i, sum(stack)\\n        s += '$'\\n        return dfs(s, 0)[1]\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nif c == ')':\\n    if pre_flag == '+':\\n        stack.append(num)\\n    elif pre_flag == '-':\\n        stack.append(-num)\\n    break\\n\"\n        }\n    ]\n},\n\"majority-element-ii\":{\n    \"id\": \"229\",\n    \"name\": \"majority-element-ii\",\n    \"pre\": [\n        {\n            \"text\": \"摩尔投票法\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"摩尔投票法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"两个counter\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"最后得到的只是出现次数最多的两个数字，有可能不满足出现次数大于1/3\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/229.majority-element-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/229.majority-element-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=229 lang=java\\n *\\n * [229] Majority Element II\\n */\\nclass Solution {\\n    public List<Integer> majorityElement(int[] nums) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (nums == null || nums.length == 0)\\n            return res;\\n        int n1 = nums[0], n2 = nums[0], cnt1 = 0, cnt2 = 0, len = nums.length;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] == n1)\\n                cnt1++;\\n            else if (nums[i] == n2)\\n                cnt2++;\\n            else if (cnt1 == 0) {\\n                n1 = nums[i];\\n                cnt1 = 1;\\n            } else if (cnt2 == 0) {\\n                n2 = nums[i];\\n                cnt2 = 1;\\n            } else {\\n                cnt1--;\\n                cnt2--;\\n            }\\n        }\\n        cnt1 = 0;\\n        cnt2 = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (nums[i] == n1)\\n                cnt1++;\\n            else if (nums[i] == n2)\\n                cnt2++;\\n        }\\n        if (cnt1 > len / 3)\\n            res.add(n1);\\n        if (cnt2 > len / 3 && n1 != n2)\\n            res.add(n2);\\n        return res;\\n    }\\n}\\n\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=229 lang=javascript\\n *\\n * [229] Majority Element II\\n */\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar majorityElement = function (nums) {\\n  const res = [];\\n  const len = nums.length;\\n  let n1 = null,\\n    n2 = null,\\n    cnt1 = 0,\\n    cnt2 = 0;\\n\\n  for (let i = 0; i < len; i++) {\\n    if (n1 === nums[i]) {\\n      cnt1++;\\n    } else if (n2 === nums[i]) {\\n      cnt2++;\\n    } else if (cnt1 === 0) {\\n      n1 = nums[i];\\n      cnt1++;\\n    } else if (cnt2 === 0) {\\n      n2 = nums[i];\\n      cnt2++;\\n    } else {\\n      cnt1--;\\n      cnt2--;\\n    }\\n  }\\n\\n  cnt1 = 0;\\n  cnt2 = 0;\\n\\n  for (let i = 0; i < len; i++) {\\n    if (n1 === nums[i]) {\\n      cnt1++;\\n    } else if (n2 === nums[i]) {\\n      cnt2++;\\n    }\\n  }\\n\\n  if (cnt1 > (len / 3) >>> 0) {\\n    res.push(n1);\\n  }\\n  if (cnt2 > (len / 3) >>> 0) {\\n    res.push(n2);\\n  }\\n\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int c1 = 0, c2 = 0, v1 = 0, v2 = 1;\\n        for (int n : nums) {\\n            if (v1 == n) ++c1;\\n            else if (v2 == n) ++c2;\\n            else if (!c1) v1 = n, ++c1;\\n            else if (!c2) v2 = n, ++c2;\\n            else --c1, --c2;\\n        }\\n        c1 = c2 = 0;\\n        for (int n : nums) {\\n            if (v1 == n) ++c1;\\n            if (v2 == n) ++c2;\\n        }\\n        vector<int> v;\\n        if (c1 > nums.size() / 3) v.push_back(v1);\\n        if (c2 > nums.size() / 3) v.push_back(v2);\\n        return v;\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"kth-smallest-element-in-a-bst\":{\n    \"id\": \"230\",\n    \"name\": \"kth-smallest-element-in-a-bst\",\n    \"pre\": [\n        {\n            \"text\": \"中序遍历\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"中序遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/230.kth-smallest-element-in-a-bst.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/230.kth-smallest-element-in-a-bst.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nprivate int count = 1;\\nprivate int res;\\n\\npublic int KthSmallest (TreeNode root, int k) {\\n    inorder(root, k);\\n    return res;\\n}\\n\\npublic void inorder (TreeNode root, int k) {\\n    if (root == null) return;\\n\\n    inorder(root.left, k);\\n\\n    if (count++ == k) {\\n        res = root.val;\\n        return;\\n    }\\n\\n    inorder(root.right, k);\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=230 lang=javascript\\n *\\n * [230] Kth Smallest Element in a BST\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthSmallest = function (root, k) {\\n  const stack = [root];\\n  let cur = root;\\n  let i = 0;\\n\\n  function insertAllLefts(cur) {\\n    while (cur && cur.left) {\\n      const l = cur.left;\\n      stack.push(l);\\n      cur = l;\\n    }\\n  }\\n  insertAllLefts(cur);\\n\\n  while ((cur = stack.pop())) {\\n    i++;\\n    if (i === k) return cur.val;\\n    const r = cur.right;\\n\\n    if (r) {\\n      stack.push(r);\\n      insertAllLefts(r);\\n    }\\n  }\\n\\n  return -1;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\nfunction nodeCount(node) {\\n  if (node === null) return 0;\\n\\n  const l = nodeCount(node.left);\\n  const r = nodeCount(node.right);\\n\\n  return 1 + l + r;\\n}\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthSmallest = function (root, k) {\\n  const c = nodeCount(root.left);\\n  if (c === k - 1) return root.val;\\n  else if (c < k - 1) return kthSmallest(root.right, k - c - 1);\\n  return kthSmallest(root.left, k);\\n};\\n\"\n        }\n    ]\n},\n\"implement-queue-using-stacks\":{\n    \"id\": \"232\",\n    \"name\": \"implement-queue-using-stacks\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"在push的时候利用辅助栈(双栈)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/232.implement-queue-using-stacks.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/232.implement-queue-using-stacks.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass MyQueue {\\n    Stack<Integer> pushStack = new Stack<> ();\\n    Stack<Integer> popStack = new Stack<> ();\\n\\n    /** Initialize your data structure here. */\\n    public MyQueue() {\\n\\n    }\\n\\n    /** Push element x to the back of queue. */\\n    public void push(int x) {\\n        while (!popStack.isEmpty()) {\\n            pushStack.push(popStack.pop());\\n        }\\n        pushStack.push(x);\\n    }\\n\\n    /** Removes the element from in front of queue and returns that element. */\\n    public int pop() {\\n        while (!pushStack.isEmpty()) {\\n            popStack.push(pushStack.pop());\\n        }\\n        return popStack.pop();\\n    }\\n\\n    /** Get the front element. */\\n    public int peek() {\\n        while (!pushStack.isEmpty()) {\\n            popStack.push(pushStack.pop());\\n        }\\n        return popStack.peek();\\n    }\\n\\n    /** Returns whether the queue is empty. */\\n    public boolean empty() {\\n        return pushStack.isEmpty() && popStack.isEmpty();\\n    }\\n}\\n\\n/**\\n * Your MyQueue object will be instantiated and called as such:\\n * MyQueue obj = new MyQueue();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.peek();\\n * boolean param_4 = obj.empty();\\n */\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=232 lang=javascript\\n *\\n * [232] Implement Queue using Stacks\\n */\\n/**\\n * Initialize your data structure here.\\n */\\nvar MyQueue = function () {\\n  // tag: queue stack array\\n  this.stack = [];\\n  this.helperStack = [];\\n};\\n\\n/**\\n * Push element x to the back of queue.\\n * @param {number} x\\n * @return {void}\\n */\\nMyQueue.prototype.push = function (x) {\\n  let cur = null;\\n  while ((cur = this.stack.pop())) {\\n    this.helperStack.push(cur);\\n  }\\n  this.helperStack.push(x);\\n\\n  while ((cur = this.helperStack.pop())) {\\n    this.stack.push(cur);\\n  }\\n};\\n\\n/**\\n * Removes the element from in front of queue and returns that element.\\n * @return {number}\\n */\\nMyQueue.prototype.pop = function () {\\n  return this.stack.pop();\\n};\\n\\n/**\\n * Get the front element.\\n * @return {number}\\n */\\nMyQueue.prototype.peek = function () {\\n  return this.stack[this.stack.length - 1];\\n};\\n\\n/**\\n * Returns whether the queue is empty.\\n * @return {boolean}\\n */\\nMyQueue.prototype.empty = function () {\\n  return this.stack.length === 0;\\n};\\n\\n/**\\n * Your MyQueue object will be instantiated and called as such:\\n * var obj = new MyQueue()\\n * obj.push(x)\\n * var param_2 = obj.pop()\\n * var param_3 = obj.peek()\\n * var param_4 = obj.empty()\\n */\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass MyQueue:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.stack = []\\n        self.help_stack = []\\n\\n    def push(self, x: int) -> None:\\n        \\\"\\\"\\\"\\n        Push element x to the back of queue.\\n        \\\"\\\"\\\"\\n        while self.stack:\\n            self.help_stack.append(self.stack.pop())\\n        self.help_stack.append(x)\\n        while self.help_stack:\\n            self.stack.append(self.help_stack.pop())\\n\\n    def pop(self) -> int:\\n        \\\"\\\"\\\"\\n        Removes the element from in front of queue and returns that element.\\n        \\\"\\\"\\\"\\n        return self.stack.pop()\\n\\n    def peek(self) -> int:\\n        \\\"\\\"\\\"\\n        Get the front element.\\n        \\\"\\\"\\\"\\n        return self.stack[-1]\\n\\n    def empty(self) -> bool:\\n        \\\"\\\"\\\"\\n        Returns whether the queue is empty.\\n        \\\"\\\"\\\"\\n        return not bool(self.stack)\\n\\n\\n# Your MyQueue object will be instantiated and called as such:\\n# obj = MyQueue()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.peek()\\n# param_4 = obj.empty()\\n\"\n        }\n    ]\n},\n\"lowest-common-ancestor-of-a-binary-tree\":{\n    \"id\": \"236\",\n    \"name\": \"lowest-common-ancestor-of-a-binary-tree\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"用递归的思路去思考树\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/236.lowest-common-ancestor-of-a-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/236.lowest-common-ancestor-of-a-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 如果我们找到了p，直接进行返回，那如果下面就是q呢？ 其实这没有影响，但是还是要多考虑一下\\nif (!root || root === p || root === q) return root;\\nconst left = lowestCommonAncestor(root.left, p, q); // 去左边找，我们期望返回找到的节点\\nconst right = lowestCommonAncestor(root.right, p, q); // 去右边找，我们期望返回找到的节点\\nif (!left) return right; // 左子树找不到，返回右子树\\nif (!right) return left; // 右子树找不到，返回左子树\\nreturn root; // 左右子树分别有一个，则返回root\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function (root, p, q) {\\n  if (!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  if (!left) return right; // 左子树找不到，返回右子树\\n  if (!right) return left; // 右子树找不到，返回左子树\\n  return root; // 左右子树分别有一个，则返回root\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\\n        if not root or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n\\n        if not left:\\n            return right\\n        if not right:\\n            return left\\n        else:\\n            return root\\n\\n\"\n        }\n    ]\n},\n\"product-of-array-except-self\":{\n    \"id\": \"238\",\n    \"name\": \"product-of-array-except-self\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"两次遍历，一次正向，一次反向。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"维护一个数组，第i项代表前i个元素（不包括i）的乘积\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/238.product-of-array-except-self.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/238.product-of-array-except-self.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function (nums) {\\n  const ret = [];\\n\\n  for (let i = 0, temp = 1; i < nums.length; i++) {\\n    ret[i] = temp;\\n    temp *= nums[i];\\n  }\\n  // 此时ret[i]存放的是前i个元素相乘的结果(不包含第i个)\\n\\n  // 如果没有上面的循环的话，\\n  // ret经过下面的循环会变成ret[i]存放的是后i个元素相乘的结果(不包含第i个)\\n\\n  // 我们的目标是ret[i]存放的所有数字相乘的结果(不包含第i个)\\n\\n  // 因此我们只需要对于上述的循环产生的ret[i]基础上运算即可\\n  for (let i = nums.length - 1, temp = 1; i >= 0; i--) {\\n    ret[i] *= temp;\\n    temp *= nums[i];\\n  }\\n  return ret;\\n};\\n\"\n        }\n    ]\n},\n\"sliding-window-maximum\":{\n    \"id\": \"239\",\n    \"name\": \"sliding-window-maximum\",\n    \"pre\": [\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        },\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"双端队列简化时间复杂度\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/239.sliding-window-maximum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/239.sliding-window-maximum.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxSlidingWindow = function (nums, k) {\\n  // bad 时间复杂度O(n * k)\\n  if (nums.length === 0 || k === 0) return [];\\n  let slideWindow = [];\\n  const ret = [];\\n  for (let i = 0; i < nums.length - k + 1; i++) {\\n    for (let j = 0; j < k; j++) {\\n      slideWindow.push(nums[i + j]);\\n    }\\n    ret.push(Math.max(...slideWindow));\\n    slideWindow = [];\\n  }\\n  return ret;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxSlidingWindow = function (nums, k) {\\n  // 双端队列优化时间复杂度, 时间复杂度O(n)\\n  const deque = []; // 存放在接下来的滑动窗口可能成为最大值的数\\n  const ret = [];\\n  for (let i = 0; i < nums.length; i++) {\\n    // 清空失效元素\\n    while (deque[0] < i - k + 1) {\\n      deque.shift();\\n    }\\n\\n    while (nums[deque[deque.length - 1]] < nums[i]) {\\n      deque.pop();\\n    }\\n\\n    deque.push(i);\\n\\n    if (i >= k - 1) {\\n      ret.push(nums[deque[0]]);\\n    }\\n  }\\n  return ret;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        if k == 0: return []\\n        res = []\\n        for r in range(k - 1, len(nums)):\\n            res.append(max(nums[r - k + 1:r + 1]))\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\\n        q = collections.deque() # 本质就是单调队列\\n        ans = []\\n        for i in range(len(nums)):\\n            while q and nums[q[-1]] <= nums[i]: q.pop() # 维持单调性\\n            while q and i - q[0] >= k: q.popleft() # 移除失效元素\\n            q.append(i)\\n            if i >= k - 1: ans.append(nums[q[0]])\\n        return ans\\n\"\n        }\n    ]\n},\n\"search-a-2-d-matrix-ii\":{\n    \"id\": \"240\",\n    \"name\": \"search-a-2-d-matrix-ii\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"从角落开始遍历，利用递增的特性简化时间复杂\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/240.search-a-2-d-matrix-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/240.search-a-2-d-matrix-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=240 lang=javascript\\n *\\n * [240] Search a 2D Matrix II\\n *\\n * https://leetcode.com/problems/search-a-2d-matrix-ii/description/\\n *\\n *\\n */\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  if (!matrix || matrix.length === 0) return false;\\n\\n  let colIndex = 0;\\n  let rowIndex = matrix.length - 1;\\n  while (rowIndex > 0 && target < matrix[rowIndex][colIndex]) {\\n    rowIndex--;\\n  }\\n\\n  while (colIndex < matrix[0].length) {\\n    if (target === matrix[rowIndex][colIndex]) return true;\\n    if (target > matrix[rowIndex][colIndex]) {\\n      colIndex++;\\n    } else if (rowIndex > 0) {\\n      rowIndex--;\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  return false;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m == 0:\\n            return False\\n        n = len(matrix[0])\\n        i = m - 1\\n        j = 0\\n\\n        while i >= 0 and j < n:\\n            if matrix[i][j] == target:\\n                return True\\n            if matrix[i][j] > target:\\n                i -= 1\\n            else:\\n                j += 1\\n        return False\\n\"\n        }\n    ]\n},\n\"ugly-number\":{\n    \"id\": \"263\",\n    \"name\": \"ugly-number\",\n    \"pre\": [\n        {\n            \"text\": \"数学\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"因数分解\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"数论\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"因数分解\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/263.ugly-number.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/263.ugly-number.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public boolean isUgly(int num) {\\n        int [] ugly = {2,3,5};\\n        for(int u : ugly)\\n        {\\n            while(num%u==0 && num%u < num)\\n            {\\n                num/=u;\\n            }\\n        }\\n        return num == 1;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nwhile (num % 2 === 0) num = num / 2;\\nwhile (num % 3 === 0) num = num / 3;\\nwhile (num % 5 === 0) num = num / 5;\\n\\nreturn num === 1;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=263 lang=javascript\\n *\\n * [263] Ugly Number\\n */\\n/**\\n * @param {number} num\\n * @return {boolean}\\n */\\nvar isUgly = function (num) {\\n  // TAG: 数论\\n  if (num <= 0) return false;\\n  if (num === 1) return true;\\n\\n  const list = [2, 3, 5];\\n\\n  if (list.includes(num)) return true;\\n\\n  for (let i of list) {\\n    if (num % i === 0) return isUgly(Math.floor(num / i));\\n  }\\n  return false;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    bool isUgly(int num) {\\n        int ugly[] = {2,3,5};\\n        for(int u : ugly)\\n        {\\n            while(num%u==0 && num%u < num)\\n            {\\n                num/=u;\\n            }\\n        }\\n        return num == 1;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# 非递归写法\\nclass Solution:\\n    def isUgly(self, num: int) -> bool:\\n        if num <= 0:\\n            return False\\n        for i in (2, 3, 5):\\n            while num % i == 0:\\n                num /= i\\n        return num == 1\\n\"\n        }\n    ]\n},\n\"perfect-squares\":{\n    \"id\": \"279\",\n    \"name\": \"perfect-squares\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"如果用递归+缓存，缓存的设计很重要我的做法是key就是n，value是以n为起点，到达底端的深度。下次取出缓存的时候用当前的level+存的深度就是我们想要的level.\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"使用动态规划的核心点还是选和不选的问题```jsfor(leti=1;i<=n;i++){for(letj=1;j*j<=i;j++){//不选（dp[i]）还是选（dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"j*j]）dp[i]=Math.min(dp[i],dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"j*j]+1);}}```\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/279.perfect-squares.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/279.perfect-squares.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nconst mapper = {};\\n\\nfunction d(n, level) {\\n  if (n === 0) return level;\\n\\n  let i = 1;\\n  const arr = [];\\n\\n  while (n - i * i >= 0) {\\n    const hit = mapper[n - i * i];\\n    if (hit) {\\n      arr.push(hit + level);\\n    } else {\\n      const depth = d(n - i * i, level + 1) - level;\\n      mapper[n - i * i] = depth;\\n      arr.push(depth + level);\\n    }\\n    i++;\\n  }\\n\\n  return Math.min(...arr);\\n}\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar numSquares = function (n) {\\n  return d(n, 0);\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfor (let i = 1; i <= n; i++) {\\n  for (let j = 1; j * j <= i; j++) {\\n    // 不选（dp[i]） 还是  选（dp[i - j * j]）\\n    dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar numSquares = function (n) {\\n  if (n <= 0) {\\n    return 0;\\n  }\\n\\n  const dp = Array(n + 1).fill(Number.MAX_VALUE);\\n  dp[0] = 0;\\n  for (let i = 1; i <= n; i++) {\\n    for (let j = 1; j * j <= i; j++) {\\n      // 不选（dp[i]） 还是  选（dp[i - j * j]）\\n      dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\\n    }\\n  }\\n\\n  return dp[n];\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int numSquares(int n) {\\n        static vector<int> dp{0};\\n        while (dp.size() <= n) {\\n            int m = dp.size(), minVal = INT_MAX;\\n            for (int i = 1; i * i <= m; ++i) minVal = min(minVal, 1 + dp[m - i * i]);\\n            dp.push_back(minVal);\\n        }\\n        return dp[n];\\n    }\\n};\\n\"\n        }\n    ]\n},\n\"move-zeroes\":{\n    \"id\": \"283\",\n    \"name\": \"move-zeroes\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"bloomberg\"\n        },\n        {\n            \"name\": \"facebook\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/283.move-zeroes.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/283.move-zeroes.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        // 双指针\\n        int i = 0;\\n        for(int j=0; j<nums.length; j++)\\n        {\\n            // 不为0，前移\\n            if(nums[j] != 0)\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar moveZeroes = function (nums) {\\n  let index = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    const num = nums[i];\\n    if (num !== 0) {\\n      nums[index++] = num;\\n    }\\n  }\\n\\n  for (let i = index; i < nums.length; i++) {\\n    nums[index++] = 0;\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def moveZeroes(self, nums: List[int]) -> None:\\n        \\\"\\\"\\\"\\n        Do not return anything, modify nums in-place instead.\\n        \\\"\\\"\\\"\\n        slow = fast = 0\\n        while fast < len(nums):\\n            if nums[fast] != 0:\\n                nums[fast], nums[slow] = nums[slow], nums[fast]\\n                slow += 1\\n            fast += 1\\n\"\n        }\n    ]\n},\n\"find-median-from-data-stream\":{\n    \"id\": \"295\",\n    \"name\": \"find-median-from-data-stream\",\n    \"pre\": [\n        {\n            \"text\": \"堆\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"用两个堆（一个大顶堆，一个小顶堆）来简化时间复杂度\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"用优先级队列简化操作>JavaScript不像Java，C++等语言都有`优先级队列`中这种数据结构，因此大家可以使用社区的实现>个人认为没有非要纠结于优先级队列怎么实现，至少这道题不是考这个的>优先级队列的实现个人认为已经超过了这道题想考察的范畴\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/295.find-median-from-data-stream.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/295.find-median-from-data-stream.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction findMedian(a) {\\n  return a.length % 2 === 0\\n    ? (a[a.length >> 1] + a[a.length >> (1 + 1)]) / 2\\n    : a[a.length >> 1];\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * initialize your data structure here.\\n */\\nvar MedianFinder = function () {\\n  this.maxHeap = [];\\n  this.minHeap = [];\\n};\\n\\nfunction minHeapify() {\\n  this.minHeap.unshift(null);\\n  const a = this.minHeap;\\n\\n  // 为了方便大家理解，这里选用了粗暴的实现\\n  // 时间复杂度为O(n)\\n  // 其实可以降到O(logn)， 具体细节我不想在这里讲解和实现\\n  for (let i = a.length - 1; i >> 1 > 0; i--) {\\n    // 自下往上堆化\\n    if (a[i] < a[i >> 1]) {\\n      // 如果子元素更小，则交换位置\\n      const temp = a[i];\\n      this.minHeap[i] = a[i >> 1];\\n      this.minHeap[i >> 1] = temp;\\n    }\\n  }\\n  this.minHeap.shift(null);\\n}\\n\\nfunction maxHeapify() {\\n  this.maxHeap.unshift(null);\\n  const a = this.maxHeap;\\n\\n  // 为了方便大家理解，这里选用了粗暴的实现\\n  // 时间复杂度为O(n)\\n  // 其实可以降到O(logn)， 具体细节我不想在这里讲解和实现\\n  for (let i = a.length - 1; i >> 1 > 0; i--) {\\n    // 自下往上堆化\\n    if (a[i] > a[i >> 1]) {\\n      // 如果子元素更大，则交换位置\\n      const temp = a[i];\\n      this.maxHeap[i] = a[i >> 1];\\n      this.maxHeap[i >> 1] = temp;\\n    }\\n  }\\n  this.maxHeap.shift(null);\\n}\\n\\n/**\\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function (num) {\\n  // 为了大家容易理解，这部分代码写的比较冗余\\n\\n  // 插入\\n  if (num >= (this.minHeap[0] || Number.MIN_VALUE)) {\\n    this.minHeap.push(num);\\n  } else {\\n    this.maxHeap.push(num);\\n  }\\n  // 调整两个堆的节点数量平衡\\n  // 使得大顶堆的数量最多大于小顶堆一个， 且一定不小于小顶堆数量\\n  if (this.maxHeap.length > this.minHeap.length + 1) {\\n    // 大顶堆的堆顶元素移动到小顶堆\\n    this.minHeap.push(this.maxHeap.shift());\\n  }\\n\\n  if (this.minHeap.length > this.maxHeap.length) {\\n    // 小顶堆的堆顶元素移动到大顶堆\\n    this.maxHeap.push(this.minHeap.shift());\\n  }\\n\\n  // 调整堆顶元素\\n  if (this.maxHeap[0] > this.minHeap[0]) {\\n    const temp = this.maxHeap[0];\\n    this.maxHeap[0] = this.minHeap[0];\\n    this.minHeap[0] = temp;\\n  }\\n\\n  // 堆化\\n  maxHeapify.call(this);\\n  minHeapify.call(this);\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function () {\\n  if ((this.maxHeap.length + this.minHeap.length) % 2 === 0) {\\n    return (this.minHeap[0] + this.maxHeap[0]) / 2;\\n  } else {\\n    return this.maxHeap[0];\\n  }\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nthis.heap.unshift(null);\\n// ....\\nthis.heap.shift(null);\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar MedianFinder = function () {\\n  this.maxHeap = new PriorityQueue((a, b) => a - b);\\n  this.minHeap = new PriorityQueue((a, b) => b - a);\\n};\\n\\n/**\\n * @param {number} num\\n * @return {void}\\n */\\nMedianFinder.prototype.addNum = function (num) {\\n  // 我们的目标就是建立两个堆，一个大顶堆，一个小顶堆\\n  // 结合中位数的特点\\n  // 这两个堆需要满足:\\n  // 1. 大顶堆元素都比小顶堆小（由于堆的特点其实只要比较堆顶即可）\\n  // 2. 大顶堆元素不小于小顶堆，且最多比小顶堆多一个元素\\n\\n  // 满足上面两个条件的话，如果想要找到中位数，就比较简单了\\n  // 如果两个堆数量相等（本质是总数为偶数）, 就两个堆顶元素的平均数\\n  // 如果两个堆数量不相等（本质是总数为奇数）， 就取大顶堆的堆顶元素\\n\\n  // 问题如果保证满足上述两个特点\\n\\n  // 1. 保证第一点\\n  this.maxHeap.enq(num);\\n  // 由于小顶堆的所有数都来自大顶堆的堆顶元素（最大值）\\n  // 因此可以保证第一点\\n  this.minHeap.enq(this.maxHeap.deq());\\n\\n  // 2. 保证第二点\\n  if (this.maxHeap.size() < this.minHeap.size()) {\\n    this.maxHeap.enq(this.minHeap.deq());\\n  }\\n};\\n\\n/**\\n * @return {number}\\n */\\nMedianFinder.prototype.findMedian = function () {\\n  if (this.maxHeap.size() == this.minHeap.size())\\n    return (this.maxHeap.peek() + this.minHeap.peek()) / 2.0;\\n  else return this.maxHeap.peek();\\n};\\n\\n/**\\n * Your MedianFinder object will be instantiated and called as such:\\n * var obj = new MedianFinder()\\n * obj.addNum(num)\\n * var param_2 = obj.findMedian()\\n */\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass MedianFinder {\\npublic:\\n    /** initialize your data structure here. */\\n    MedianFinder() {\\n\\n    }\\n\\n    void addNum(int num) {\\n        if (big_queue.empty()) {\\n            big_queue.push(num);\\n            return;\\n        }\\n        if (big_queue.size() == small_queue.size()) {\\n            if (num <= big_queue.top()) {\\n                big_queue.push(num);\\n            } else {\\n                small_queue.push(num);\\n            }\\n        } else if (big_queue.size() > small_queue.size()) {\\n            if (big_queue.top() > num) {\\n                small_queue.push(big_queue.top());\\n                big_queue.pop();\\n                big_queue.push(num);\\n            } else {\\n                small_queue.push(num);\\n            }\\n        } else if (big_queue.size() < small_queue.size()) {\\n            if (small_queue.top() > num) {\\n                big_queue.push(num);\\n            } else {\\n                big_queue.push(small_queue.top());\\n                small_queue.pop();\\n                small_queue.push(num);\\n            }\\n        }\\n    }\\n\\n    double findMedian() {\\n        if (big_queue.size() == small_queue.size()) {\\n            return (big_queue.top() + small_queue.top()) * 0.5;\\n        }\\n        if (big_queue.size() < small_queue.size()) {\\n            return small_queue.top();\\n        }\\n        return big_queue.top();\\n    }\\n\\nprivate:\\n    std::priority_queue<int, std::vector<int>, std::greater<int>> small_queue;  // 最小堆\\n    std::priority_queue<int> big_queue; // 最大堆\\n};\\n\"\n        }\n    ]\n},\n\"serialize-and-deserialize-binary-tree\":{\n    \"id\": \"297\",\n    \"name\": \"serialize-and-deserialize-binary-tree\",\n    \"pre\": [],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/297.serialize-and-deserialize-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/297.serialize-and-deserialize-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nconst serialize = (root) => {\\n  const queue = [root];\\n  let res = [];\\n  while (queue.length) {\\n    const node = queue.shift();\\n    if (node) {\\n      res.push(node.val);\\n      queue.push(node.left);\\n      queue.push(node.right);\\n    } else {\\n      res.push(\\\"#\\\");\\n    }\\n  }\\n  return res.join(\\\",\\\");\\n};\\n\\nconst deserialize = (data) => {\\n  if (data == \\\"#\\\") return null;\\n\\n  const list = data.split(\\\",\\\");\\n\\n  const root = new TreeNode(list[0]);\\n  const queue = [root];\\n  let cursor = 1;\\n\\n  while (cursor < list.length) {\\n    const node = queue.shift();\\n\\n    const leftVal = list[cursor];\\n    const rightVal = list[cursor + 1];\\n\\n    if (leftVal != \\\"#\\\") {\\n      const leftNode = new TreeNode(leftVal);\\n      node.left = leftNode;\\n      queue.push(leftNode);\\n    }\\n    if (rightVal != \\\"#\\\") {\\n      const rightNode = new TreeNode(rightVal);\\n      node.right = rightNode;\\n      queue.push(rightNode);\\n    }\\n    cursor += 2;\\n  }\\n  return root;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Codec:\\n\\n    def serialize(self, root):\\n        q = collections.deque([root])\\n        ans = ''\\n        while q:\\n            cur = q.popleft()\\n            if cur:\\n                ans += str(cur.val) + ','\\n                q.append(cur.left)\\n                q.append(cur.right)\\n            else:\\n                # 除了这里不一样，其他和普通的不记录层的 BFS 没区别\\n                ans += 'null,'\\n        # 末尾会多一个逗号，我们去掉它。\\n        return ans[:-1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n    def deserialize(self, data):\\n        if data == 'null': return None\\n        nodes = data.split(',')\\n        root = TreeNode(nodes[0])\\n        # 从一号开始编号，编号信息一起入队\\n        q = collections.deque([(root, 1)])\\n        while q:\\n            cur, i = q.popleft()\\n            # 2 * i 是左节点，而 2 * i 编号对应的其实是索引为 2 * i - 1 的元素， 右节点同理。\\n            if 2 * i - 1 < len(nodes): lv = nodes[2 * i - 1]\\n            if 2 * i < len(nodes): rv = nodes[2 * i]\\n            if lv != 'null':\\n                l = TreeNode(lv)\\n                # 将左节点和 它的编号 2 * i 入队\\n                q.append((l, 2 * i))\\n                cur.left = l\\n            if rv != 'null':\\n                r = TreeNode(rv)\\n                # 将右节点和 它的编号 2 * i + 1 入队\\n                q.append((r, 2 * i + 1))\\n                cur.right = r\\n\\n        return root\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef deserialize(self, data):\\n    if data == 'null': return None\\n    nodes = data.split(',')\\n    root = TreeNode(nodes[0])\\n    q = collections.deque([root])\\n    i = 0\\n    while q and i < len(nodes) - 2:\\n        cur = q.popleft()\\n        lv = nodes[i + 1]\\n        rv = nodes[i + 2]\\n        i += 2\\n        if lv != 'null':\\n            l = TreeNode(lv)\\n            q.append(l)\\n            cur.left = l\\n        if rv != 'null':\\n            r = TreeNode(rv)\\n            q.append(r)\\n            cur.right = r\\n\\n    return root\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Codec:\\n    def serialize(self, root):\\n        ans = ''\\n        queue = [root]\\n        while queue:\\n            node = queue.pop(0)\\n            if node:\\n                ans += str(node.val) + ','\\n                queue.append(node.left)\\n                queue.append(node.right)\\n            else:\\n                ans += '#,'\\n        print(ans[:-1])\\n        return ans[:-1]\\n\\n\\n\\n    def deserialize(self, data: str):\\n        if data == '#': return None\\n        nodes = data.split(',')\\n        if not nodes: return None\\n        root = TreeNode(nodes[0])\\n        queue = [root]\\n        # 已经有 root 了，因此从 1 开始\\n        i = 1\\n\\n        while i < len(nodes) - 1:\\n            node = queue.pop(0)\\n            lv = nodes[i]\\n            rv = nodes[i + 1]\\n            i += 2\\n            if lv != '#':\\n                l = TreeNode(lv)\\n                node.left = l\\n                queue.append(l)\\n\\n            if rv != '#':\\n                r = TreeNode(rv)\\n                node.right = r\\n                queue.append(r)\\n        return root\\n\\n\"\n        }\n    ]\n},\n\"remove-invalid-parentheses\":{\n    \"id\": \"301\",\n    \"name\": \"remove-invalid-parentheses\",\n    \"pre\": [\n        {\n            \"text\": \"BFS\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"广度优先遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"使用队列简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"使用一个visited的mapper，来避免遍历同样的字符串\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/301.remove-invalid-parentheses.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/301.remove-invalid-parentheses.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar isValid = function(s) {\\n  let openParenthes = 0;\\n  for(let i = 0; i < s.length; i++) {\\n    if (s[i] === '(') {\\n      openParenthes++;\\n    } else if (s[i] === ')') {\\n      if (openParenthes === 0) return false;\\n      openParenthes--;\\n    }\\n  }\\n  return openParenthes === 0;\\n};\\n/**\\n * @param {string} s\\n * @return {string[]}\\n */\\nvar removeInvalidParentheses = function(s) {\\n  if (!s || s.length === 0) return [\\\"\\\"];\\n  const ret = [];\\n  const queue = [s];\\n  const visited = {};\\n  let current = null;\\n  let removedParentheses = 0; // 只记录最小改动\\n\\n  while ((current = queue.shift())) {\\n    let hit = isValid(current);\\n    if (hit) {\\n      if (!removedParentheses) {\\n       removedParentheses =  s.length - current.length\\n      }\\n      if (s.length - current.length > removedParentheses) return ret.length === 0 ? [\\\"\\\"] : ret;;\\n      ret.unshift(current);\\n      continue;\\n    }\\n    for (let i = 0; i < current.length; i++) {\\n      if (current[i] !== ')' && current[i] !== '(') continue;\\n      const subString = current.slice(0, i).concat(current.slice(i + 1));\\n      if (visited[subString]) continue;\\n      visited[subString] = true;\\n      queue.push(subString);\\n    }\\n  }\\n\\n  return ret.length === 0 ? [\\\"\\\"] : ret;\\n};\\n\"\n        }\n    ]\n},\n\"best-time-to-buy-and-sell-stock-with-cooldown\":{\n    \"id\": \"309\",\n    \"name\": \"best-time-to-buy-and-sell-stock-with-cooldown\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"多状态动态规划\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/309.best-time-to-buy-and-sell-stock-with-cooldown.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/309.best-time-to-buy-and-sell-stock-with-cooldown.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=309 lang=javascript\\n *\\n * [309] Best Time to Buy and Sell Stock with Cooldown\\n *\\n */\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function (prices) {\\n  if (prices == null || prices.length <= 1) return 0;\\n\\n  // 定义状态变量\\n  const buy = [];\\n  const sell = [];\\n  // 寻常\\n  buy[0] = -prices[0];\\n  buy[1] = Math.max(-prices[0], -prices[1]);\\n  sell[0] = 0;\\n  sell[1] = Math.max(0, prices[1] - prices[0]);\\n  for (let i = 2; i < prices.length; i++) {\\n    // 状态转移方程\\n    // 第i天只能是买或者cooldown\\n    // 如果买利润就是sell[i - 2] - prices[i], 注意这里是i - 2，不是 i-1 ，因为有cooldown的限制\\n    // cooldown就是buy[i -1]\\n    buy[i] = Math.max(buy[i - 1], sell[i - 2] - prices[i]);\\n    // 第i天只能是卖或者cooldown\\n    // 如果卖利润就是buy[i  -1] + prices[i]\\n    // cooldown就是sell[i -1]\\n    sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\\n  }\\n\\n  return Math.max(buy[prices.length - 1], sell[prices.length - 1], 0);\\n};\\n\"\n        }\n    ]\n},\n\"burst-balloons\":{\n    \"id\": \"312\",\n    \"name\": \"burst-balloons\",\n    \"pre\": [\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"这道题属于是切割型dp\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"反向思考\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"遍历方向的确定\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/312.burst-balloons.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/312.burst-balloons.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxCoins = function (nums) {\\n  let res = Number.MIN_VALUE;\\n  backtrack(nums, 0);\\n  return res;\\n  // 回溯法，状态树很大\\n  function backtrack(nums, score) {\\n    if (nums.length == 0) {\\n      res = Math.max(res, score);\\n      return;\\n    }\\n    for (let i = 0, n = nums.length; i < n; i++) {\\n      let point =\\n        (i - 1 < 0 ? 1 : nums[i - 1]) *\\n        nums[i] *\\n        (i + 1 >= n ? 1 : nums[i + 1]);\\n      let tempNums = [].concat(nums);\\n      // 做选择 在 nums 中删除元素 nums[i]\\n      nums.splice(i, 1);\\n      // 递归回溯\\n      backtrack(nums, score + point);\\n      // 撤销选择\\n      nums = [...tempNums];\\n    }\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxCoins = function (nums) {\\n  let n = nums.length;\\n  // 添加两侧的虚拟气球\\n  let points = [1, ...nums, 1];\\n  let dp = Array.from(Array(n + 2), () => Array(n + 2).fill(0));\\n  // 最后一行开始遍历,从下往上\\n  for (let i = n; i >= 0; i--) {\\n    // 从左往右\\n    for (let j = i + 1; j < n + 2; j++) {\\n      for (let k = i + 1; k < j; k++) {\\n        dp[i][j] = Math.max(\\n          dp[i][j],\\n          points[j] * points[k] * points[i] + dp[i][k] + dp[k][j]\\n        );\\n      }\\n    }\\n  }\\n  return dp[0][n + 1];\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        points = [1] + nums + [1]\\n        dp = [[0] * (n + 2) for _ in range(n + 2)]\\n\\n        for i in range(n, -1, -1):\\n            for j in range(i + 1, n + 2):\\n                for k in range(i + 1, j):\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[i] * points[k] * points[j])\\n        return dp[0][-1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxCoins(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums = [1] + nums + [1]\\n\\n        @lru_cache(None)\\n        def dp(left, right):\\n            if left + 1 == right:\\n                return 0\\n            if left + 2 == right:\\n                return nums[left] * nums[left + 1] * nums[left + 2]\\n            ans = 0\\n            for i in range(left + 1, right):\\n                ans = max(ans, nums[i] * nums[left] * nums[right] + dp(left, i) + dp(i, right))\\n            return ans\\n\\n        return dp(0, len(nums) - 1)\\n\\n\"\n        }\n    ]\n},\n\"coin-change\":{\n    \"id\": \"322\",\n    \"name\": \"coin-change\",\n    \"pre\": [\n        {\n            \"text\": \"贪心算法\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"子问题用dp[i]来表示组成i块钱，需要最少的硬币数，那么1.第j个硬币我可以选择不拿这个时候，硬币数=dp[i]2.第j个硬币我可以选择拿这个时候，硬币数=dp[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"coins[j]]+1\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"和背包问题不同，硬币是可以拿任意个\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"对于每一个dp[i]我们都选择遍历一遍coin，不断更新dp[i]\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"阿里巴巴（盒马生鲜）\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/322.coin-change.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/322.coin-change.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar coinChange = function (coins, amount) {\\n  if (amount === 0) {\\n    return 0;\\n  }\\n  const dp = Array(amount + 1).fill(Number.MAX_VALUE);\\n  dp[0] = 0;\\n  for (let i = 1; i < dp.length; i++) {\\n    for (let j = 0; j < coins.length; j++) {\\n      if (i - coins[j] >= 0) {\\n        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\\n      }\\n    }\\n  }\\n\\n  return dp[dp.length - 1] === Number.MAX_VALUE ? -1 : dp[dp.length - 1];\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def coinChange(self, coins: List[int], amount: int) -> int:\\n        if amount < 0:\\n            return - 1\\n        dp = [[amount + 1 for _ in range(len(coins) + 1)]\\n              for _ in range(amount + 1)]\\n        # 初始化第一行为0，其他为最大值（也就是amount + 1）\\n\\n        for j in range(len(coins) + 1):\\n            dp[0][j] = 0\\n\\n        for i in range(1, amount + 1):\\n            for j in range(1, len(coins) + 1):\\n                if i - coins[j - 1] >= 0:\\n                    dp[i][j] = min(\\n                        dp[i][j - 1], dp[i - coins[j - 1]][j] + 1)\\n                else:\\n                    dp[i][j] = dp[i][j - 1]\\n\\n        return -1 if dp[-1][-1] == amount + 1 else dp[-1][-1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def coinChange(self, coins: List[int], amount: int) -> int:\\n        dp = [amount + 1] * (amount + 1)\\n        dp[0] = 0\\n\\n        for i in range(1, amount + 1):\\n            for j in range(len(coins)):\\n                if i >= coins[j]:\\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1)\\n\\n        return -1 if dp[-1] == amount + 1 else dp[-1]\\n\"\n        }\n    ]\n},\n\"odd-even-linked-list\":{\n    \"id\": \"328\",\n    \"name\": \"odd-even-linked-list\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"用虚拟节点来简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"循环的结束条件设置为`odd&&odd.next&&even&&even.next`,不应该是`odd&&even`,否则需要记录一下奇数节点的最后一个节点，复杂了操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/328.odd-even-linked-list.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/328.odd-even-linked-list.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=328 lang=javascript\\n *\\n * [328] Odd Even Linked List\\n *\\n *\\n */\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar oddEvenList = function (head) {\\n  if (!head || !head.next) return head;\\n\\n  const dummyHead1 = {\\n    next: head,\\n  };\\n  const dummyHead2 = {\\n    next: head.next,\\n  };\\n\\n  let odd = dummyHead1.next;\\n  let even = dummyHead2.next;\\n\\n  while (odd && odd.next && even && even.next) {\\n    const oddNext = odd.next.next;\\n    const evenNext = even.next.next;\\n\\n    odd.next = oddNext;\\n    even.next = evenNext;\\n\\n    odd = oddNext;\\n    even = evenNext;\\n  }\\n\\n  odd.next = dummyHead2.next;\\n\\n  return dummyHead1.next;\\n};\\n\"\n        }\n    ]\n},\n\"patching-array\":{\n    \"id\": \"330\",\n    \"name\": \"patching-array\",\n    \"pre\": [\n        {\n            \"text\": \"贪心\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"前缀和\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"维护端点信息，并用前缀和更新区间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/330.patching-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/330.patching-array.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        furthest = i = ans = 0\\n        while furthest < n:\\n            # 可覆盖到，直接用前缀和更新区间\\n            if i < len(nums) and nums[i] <= furthest + 1:\\n                furthest += nums[i] #  [1, furthest] -> [1, furthest + nums[i]]\\n                i += 1\\n            else:\\n                # 不可覆盖到，增加一个数 furthest + 1，并用前缀和更新区间\\n                # 如果 nums[i] > furthest + 1，说明我们必须添加一个数 x，其中 1 <= x <= furthest + 1，从贪心的角度我们应该选择  furthest + 1，这在前面已经讲过\\n                furthest = 2 * furthest + 1 # [1, furthest] -> [1, furthest + furthest + 1]\\n                ans += 1\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        furthest, i, ans = 1, 0, 0\\n        # 结束条件也要相应改变\\n        while furthest <= n:\\n            if i < len(nums) and nums[i] <= furthest:\\n                furthest += nums[i] #  [1, furthest) -> [1, furthest + nums[i])\\n                i += 1\\n            else:\\n                furthest = 2 * furthest # [1, furthest) -> [1, furthest + furthest)\\n                ans += 1\\n        return ans\\n\"\n        }\n    ]\n},\n\"verify-preorder-serialization-of-a-binary-tree\":{\n    \"id\": \"331\",\n    \"name\": \"verify-preorder-serialization-of-a-binary-tree\",\n    \"pre\": [\n        {\n            \"text\": \"图论\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"从入度和出度的角度思考\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/331.verify-preorder-serialization-of-a-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/331.verify-preorder-serialization-of-a-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        diff = 0\\n\\n        for node in preorder.split(\\\",\\\"):\\n            diff -= 1\\n            if diff < -1:\\n                return False\\n            if node != \\\"#\\\":\\n                diff += 2\\n        return diff == -1\\n\\n\"\n        }\n    ]\n},\n\"increasing-triplet-subsequence\":{\n    \"id\": \"334\",\n    \"name\": \"increasing-triplet-subsequence\",\n    \"pre\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"维护三个变量，分别记录最小值，第二小值，第三小值。只要我们能够填满这三个变量就返回true，否则返回false\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/334.increasing-triplet-subsequence.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/334.increasing-triplet-subsequence.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n/**\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar increasingTriplet = function (nums) {\\n  if (nums.length < 3) return false;\\n  let n1 = Number.MAX_VALUE;\\n  let n2 = Number.MAX_VALUE;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] <= n1) {\\n      n1 = nums[i];\\n    } else if (nums[i] <= n2) {\\n      n2 = nums[i];\\n    } else {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n\"\n        }\n    ]\n},\n\"self-crossing\":{\n    \"id\": \"335\",\n    \"name\": \"self-crossing\",\n    \"pre\": [\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"一定要画图辅助\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"对于这种$O(1)$空间复杂度有固定的套路。常见的有：1.直接修改原数组2.滑动窗口（当前状态并不是和之前所有状态有关，而是仅和某几个有关）。我们采用的是滑动窗口。但是难点就在于我们怎么知道当前状态和哪几个有关。对于这道题来说，画图或许可以帮助你打开思路。另外面试的时候说出$O(N)$的思路也不失为一个帮助你冷静分析问题的手段。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/335.self-crossing.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/335.self-crossing.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def isSelfCrossing(self, x: List[int]) -> bool:\\n        n = len(x)\\n        if n < 4:\\n            return False\\n        for i in range(3, n):\\n            if x[i] >= x[i - 2] and x[i - 1] <= x[i - 3]:\\n                return True\\n            if x[i - 1] <= x[i - 3] and x[i - 2] <= x[i]:\\n                return True\\n            if i > 3 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] == x[i - 2]:\\n                return True\\n            if i > 4 and x[i] + x[i - 4] >= x[i - 2] and x[i - 1] >= x[i - 3] - x[i - 5] \\\\\\n                    and x[i - 1] <= x[i - 3] and x[i - 2] >= x[i - 4] and x[i - 3] >= x[i - 5]:\\n                return True\\n        return False\\n\"\n        }\n    ]\n},\n\"house-robber-iii\":{\n    \"id\": \"337\",\n    \"name\": \"house-robber-iii\",\n    \"pre\": [\n        {\n            \"text\": \"二叉树\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"对每一个节点都分析，是抢还是不抢\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/337.house-robber-iii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/337.house-robber-iii.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int rob(TreeNode root) {\\n        int[] res = dfs(root);\\n        return Math.max(res[0], res[1]);\\n    }\\n\\n    public int[] dp(TreeNode root)\\n    {\\n        int[] res = new int[2];\\n        if(root == null)\\n        {\\n            return res;\\n        }\\n\\n        int[] left = dfs(root.left);\\n        int[] right = dfs(root.right);\\n        // 0 代表不偷，1 代表偷\\n        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\\n        res[1] = left[0] + right[0] + root.val;\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction helper(root) {\\n  if (root === null) return [0, 0];\\n  // 0: rob 1: notRob\\n  const l = helper(root.left);\\n  const r = helper(root.right);\\n\\n  const robed = root.val + l[1] + r[1];\\n  const notRobed = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);\\n\\n  return [robed, notRobed];\\n}\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar rob = function (root) {\\n  const [robed, notRobed] = helper(root);\\n  return Math.max(robed, notRobed);\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int rob(TreeNode* root) {\\n        pair<int, int> res = dfs(root);\\n        return max(res.first, res.second);\\n    }\\n\\n    pair<int, int> dfs(TreeNode* root)\\n    {\\n        pair<int, int> res = {0, 0};\\n        if(root == NULL)\\n        {\\n            return res;\\n        }\\n\\n        pair<int, int> left = dfs(root->left);\\n        pair<int, int> right = dfs(root->right);\\n        // 0 代表不偷，1 代表偷\\n        res.first = max(left.first, left.second) + max(right.first, right.second);\\n        res.second = left.first + right.first + root->val;\\n        return res;\\n    }\\n\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def rob(self, root: TreeNode) -> int:\\n        def dfs(node):\\n            if not node:\\n                return [0, 0]\\n            [l_rob, l_not_rob] = dfs(node.left)\\n            [r_rob, r_not_rob] = dfs(node.right)\\n            return [node.val + l_not_rob + r_not_rob, max([l_rob, l_not_rob]) +  max([r_rob, r_not_rob])]\\n        return max(dfs(root))\\n\\n\\n# @lc code=end\\n\\n\"\n        }\n    ]\n},\n\"power-of-four\":{\n    \"id\": \"342\",\n    \"name\": \"power-of-four\",\n    \"pre\": [\n        {\n            \"text\": \"数论\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"数论\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"2的幂次方特点（数学性质以及二进制表示）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"4的幂次方特点（数学性质以及二进制表示）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"twosigma\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/342.power-of-four.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/342.power-of-four.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nwhile (num && num % 4 == 0) {\\n  num /= 4;\\n}\\nreturn num == 1;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nreturn num > 0 && (num & (num - 1)) === 0 && (num - 1) % 3 === 0;\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=342 lang=javascript\\n *\\n * [342] Power of Four\\n */\\n/**\\n * @param {number} num\\n * @return {boolean}\\n */\\nvar isPowerOfFour = function (num) {\\n  // tag: 数论\\n\\n  if (num === 1) return true;\\n  if (num < 4) return false;\\n\\n  if ((num & (num - 1)) !== 0) return false;\\n\\n  return (num & 0x55555555) === num;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def isPowerOfFour(self, num: int) -> bool:\\n        if num == 1:\\n            return True\\n        elif num < 4:\\n            return False\\n        else:\\n            if not num & (num-1) == 0:\\n                return False\\n            else:\\n                return num & 0x55555555 == num\\n\\n    # 另一种解法：将数字转化为二进制表示的字符串，利用字符串的相关操作进行判断\\n    def isPowerOfFour(self, num: int) -> bool:\\n        binary_num = bin(num)[2:]\\n        return binary_num.strip('0') == '1' and len(binary_num) % 2 == 1\\n\"\n        }\n    ]\n},\n\"integer-break\":{\n    \"id\": \"343\",\n    \"name\": \"integer-break\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"数学抽象\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"递归分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"记忆化递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/343.integer-break.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/343.integer-break.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [1] * (n + 1)\\n        for i in range(3, n + 1):\\n            for j in range(1, i):\\n                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])\\n        return dp[n]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2: return 1\\n        res = 0\\n        for i in range(1, n):\\n            res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    @lru_cache()\\n    def integerBreak(self, n: int) -> int:\\n        if n == 2: return 1\\n        res = 0\\n        for i in range(1, n):\\n            res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [1] * (n + 1)\\n        for i in range(3, n + 1):\\n            for j in range(1, i):\\n                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])\\n        return dp[n]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def integerBreak(self, n: int) -> int:\\n        dp = [1] * (n + 1)\\n        for i in range(3, n + 1):\\n            for j in range(1, i):\\n                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])\\n        return dp[n]\\n\"\n        }\n    ]\n},\n\"intersection-of-two-arrays\":{\n    \"id\": \"349\",\n    \"name\": \"intersection-of-two-arrays\",\n    \"pre\": [\n        {\n            \"text\": \"hashtable\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/349.intersection-of-two-arrays.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/349.intersection-of-two-arrays.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number[]}\\n */\\nvar intersection = function (nums1, nums2) {\\n  const visited = {};\\n  const ret = [];\\n  for (let i = 0; i < nums1.length; i++) {\\n    const num = nums1[i];\\n\\n    visited[num] = num;\\n  }\\n\\n  for (let i = 0; i < nums2.length; i++) {\\n    const num = nums2[i];\\n\\n    if (visited[num] !== undefined) {\\n      ret.push(num);\\n      visited[num] = undefined;\\n    }\\n  }\\n\\n  return ret;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        visited, result = {}, []\\n        for num in nums1:\\n            visited[num] = num\\n        for num in nums2:\\n            if num in visited:\\n                result.append(num)\\n                visited.pop(num)\\n        return result\\n\\n    # 另一种解法：利用 Python 中的集合进行计算\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return set(nums1) & set(nums2)\\n\"\n        }\n    ]\n},\n\"water-and-jug-problem\":{\n    \"id\": \"365\",\n    \"name\": \"water-and-jug-problem\",\n    \"pre\": [\n        {\n            \"text\": \"BFS\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"最大公约数\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/365.water-and-jug-problem.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/365.water-and-jug-problem.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number} x\\n * @param {number} y\\n * @param {number} z\\n * @return {boolean}\\n */\\nvar canMeasureWater = function (x, y, z) {\\n  if (x + y < z) return false;\\n\\n  if (z === 0) return true;\\n\\n  if (x === 0) return y === z;\\n\\n  if (y === 0) return x === z;\\n\\n  function GCD(a, b) {\\n    let min = Math.min(a, b);\\n    while (min) {\\n      if (a % min === 0 && b % min === 0) return min;\\n      min--;\\n    }\\n    return 1;\\n  }\\n\\n  return z % GCD(x, y) === 0;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def canMeasureWater(self, x: int, y: int, z: int) -> bool:\\n        if x + y < z:\\n            return False\\n        queue = [(0, 0)]\\n        seen = set((0, 0))\\n\\n        while(len(queue) > 0):\\n            a, b = queue.pop(0)\\n            if a ==z or b == z or a + b == z:\\n                return True\\n            states = set()\\n\\n            states.add((x, b))\\n            states.add((a, y))\\n            states.add((0, b))\\n            states.add((a, 0))\\n            states.add((min(x, b + a), 0 if b < x - a else b - (x - a)))\\n            states.add((0 if a + b < y else a - (y - b), min(b + a, y)))\\n            for state in states:\\n                if state in seen:\\n                    continue;\\n                queue.append(state)\\n                seen.add(state)\\n        return False\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def canMeasureWater(self, x: int, y: int, z: int) -> bool:\\n        if x + y < z:\\n            return False\\n\\n        if (z == 0):\\n            return True\\n\\n        if (x == 0):\\n            return y == z\\n\\n        if (y == 0):\\n            return x == z\\n\\n        def GCD(a, b):\\n            smaller = min(a, b)\\n            while smaller:\\n                if a % smaller == 0 and b % smaller == 0:\\n                    return smaller\\n                smaller -= 1\\n\\n        return z % GCD(x, y) == 0\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef GCD(a, b):\\n    if b == 0: return a\\n    return GCD(b, a % b)\\n\"\n        }\n    ]\n},\n\"sum-of-two-integers\":{\n    \"id\": \"371\",\n    \"name\": \"sum-of-two-integers\",\n    \"pre\": [\n        {\n            \"text\": \"位运算\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/bit.md\",\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"异或是一种不进位的加减法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"求与之后左移一位来可以表示进位\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/371.sum-of-two-integers.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/371.sum-of-two-integers.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int getSum(int a, int b) {\\n        if(a==0) return b;\\n        if(b==0) return a;\\n\\n        while(b!=0)\\n        {\\n            int carry = a&b;\\n            // 计算无进位的结果\\n            a = a^b;\\n            //将存在进位的位置置1\\n            b =carry<<1;\\n        }\\n        return a;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=371 lang=javascript\\n *\\n * [371] Sum of Two Integers\\n */\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @return {number}\\n */\\nvar getSum = function (a, b) {\\n  if (a === 0) return b;\\n\\n  if (b === 0) return a;\\n\\n  return getSum(a ^ b, (a & b) << 1);\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int getSum(int a, int b) {\\n        if(a==0) return b;\\n        if(b==0) return a;\\n\\n        while(b!=0)\\n        {\\n            // 防止 AddressSanitizer 对有符号左移的溢出保护处理\\n            auto carry = ((unsigned int ) (a & b))<<1;\\n            // 计算无进位的结果\\n            a = a^b;\\n            //将存在进位的位置置1\\n            b =carry;\\n        }\\n        return a;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# python整数类型为Unifying Long Integers, 即无限长整数类型.\\n# 模拟 32bit 有符号整型加法\\nclass Solution:\\n    def getSum(self, a: int, b: int) -> int:\\n        a &= 0xFFFFFFFF\\n        b &= 0xFFFFFFFF\\n        while b:\\n            carry = a & b\\n            a ^= b\\n            b = ((carry) << 1) & 0xFFFFFFFF\\n            # print((a, b))\\n        return a if a < 0x80000000 else ~(a^0xFFFFFFFF)\\n\"\n        }\n    ]\n},\n\"kth-smallest-element-in-a-sorted-matrix\":{\n    \"id\": \"378\",\n    \"name\": \"kth-smallest-element-in-a-sorted-matrix\",\n    \"pre\": [\n        {\n            \"text\": \"二分查找\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"堆\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二分查找\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"有序矩阵的套路（文章末尾还有一道有序矩阵的题目）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"堆（优先级队列）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/378.kth-smallest-element-in-a-sorted-matrix.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/378.kth-smallest-element-in-a-sorted-matrix.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=378 lang=javascript\\n *\\n * [378] Kth Smallest Element in a Sorted Matrix\\n */\\nfunction notGreaterCount(matrix, target) {\\n  // 等价于在matrix 中搜索mid，搜索的过程中利用有序的性质记录比mid小的元素个数\\n\\n  // 我们选择左下角，作为开始元素\\n  let curRow = 0;\\n  // 多少列\\n  const COL_COUNT = matrix[0].length;\\n  // 最后一列的索引\\n  const LAST_COL = COL_COUNT - 1;\\n  let res = 0;\\n\\n  while (curRow < matrix.length) {\\n    // 比较最后一列的数据和target的大小\\n    if (matrix[curRow][LAST_COL] < target) {\\n      res += COL_COUNT;\\n    } else {\\n      let i = COL_COUNT - 1;\\n      while (i < COL_COUNT && matrix[curRow][i] > target) {\\n        i--;\\n      }\\n      // 注意这里要加1\\n      res += i + 1;\\n    }\\n    curRow++;\\n  }\\n\\n  return res;\\n}\\n/**\\n * @param {number[][]} matrix\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthSmallest = function (matrix, k) {\\n  if (matrix.length < 1) return null;\\n  let start = matrix[0][0];\\n  let end = matrix[matrix.length - 1][matrix[0].length - 1];\\n  while (start < end) {\\n    const mid = start + ((end - start) >> 1);\\n    const count = notGreaterCount(matrix, mid);\\n    if (count < k) start = mid + 1;\\n    else end = mid;\\n  }\\n  // 返回start,mid, end 都一样\\n  return start;\\n};\\n\"\n        }\n    ]\n},\n\"insert-delete-getrandom-o1\":{\n    \"id\": \"380\",\n    \"name\": \"insert-delete-getrandom-o1\",\n    \"pre\": [],\n    \"keyPoints\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"数组+哈希表\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"基本算法时间复杂度分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/380.insert-delete-getrandom-o1.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/380.insert-delete-getrandom-o1.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfrom random import random\\n\\n\\nclass RandomizedSet:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.data = dict()\\n        self.arr = []\\n        self.n = 0\\n\\n    def insert(self, val: int) -> bool:\\n        \\\"\\\"\\\"\\n        Inserts a value to the set. Returns true if the set did not already contain the specified element.\\n        \\\"\\\"\\\"\\n        if val in self.data:\\n            return False\\n        self.data[val] = self.n\\n        self.arr.append(val)\\n        self.n += 1\\n\\n        return True\\n\\n    def remove(self, val: int) -> bool:\\n        \\\"\\\"\\\"\\n        Removes a value from the set. Returns true if the set contained the specified element.\\n        \\\"\\\"\\\"\\n        if val not in self.data:\\n            return False\\n        i = self.data[val]\\n        # 更新data\\n        self.data[self.arr[-1]] = i\\n        self.data.pop(val)\\n        # 更新arr\\n        self.arr[i] = self.arr[-1]\\n        # 删除最后一项\\n        self.arr.pop()\\n        self.n -= 1\\n\\n        return True\\n\\n    def getRandom(self) -> int:\\n        \\\"\\\"\\\"\\n        Get a random element from the set.\\n        \\\"\\\"\\\"\\n\\n        return self.arr[int(random() * self.n)]\\n\\n\\n# Your RandomizedSet object will be instantiated and called as such:\\n# obj = RandomizedSet()\\n# param_1 = obj.insert(val)\\n# param_2 = obj.remove(val)\\n# param_3 = obj.getRandom()\\n\"\n        }\n    ]\n},\n\"decode-string\":{\n    \"id\": \"394\",\n    \"name\": \"decode-string\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"括号匹配\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/394.decode-string.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/394.decode-string.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def decodeString(self, s: str) -> str:\\n        stack = []\\n        for c in s:\\n            if c == ']':\\n                repeatStr = ''\\n                repeatCount = ''\\n                while stack and stack[-1] != '[':\\n                    repeatStr = stack.pop() + repeatStr\\n                # pop 掉 \\\"[\\\"\\n                stack.pop()\\n                while stack and stack[-1].isnumeric():\\n                    repeatCount = stack.pop() + repeatCount\\n                stack.append(repeatStr * int(repeatCount))\\n            else:\\n                stack.append(c)\\n        return \\\"\\\".join(stack)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n\\n    def decodeString(self, s: str) -> str:\\n        def dfs(start):\\n            repeat_str = repeat_count = ''\\n            while start < len(s):\\n                if s[start].isnumeric():\\n                    repeat_count += s[start]\\n                elif s[start] == '[':\\n                    # 更新指针\\n                    start, t_str = dfs(start + 1)\\n                    # repeat_count 仅作用于 t_str，而不作用于当前的 repeat_str\\n                    repeat_str = repeat_str + t_str * int(repeat_count)\\n                    repeat_count = ''\\n                elif s[start] == ']':\\n                    return start, repeat_str\\n                else:\\n                    repeat_str += s[start]\\n                start += 1\\n            return repeat_str\\n        return dfs(0)\\n\"\n        }\n    ]\n},\n\"binary-watch\":{\n    \"id\": \"401\",\n    \"name\": \"binary-watch\",\n    \"pre\": [\n        {\n            \"text\": \"笛卡尔积\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"回溯\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/backtrack.md\",\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/401.binary-watch.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/401.binary-watch.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# 枚举小时\\nfor a in possible_number(i):\\n    # 小时确定了，分就是 num - i\\n    for b in possible_number(num - i, True):\\n        ans.add(str(a) + \\\":\\\" + str(b).rjust(2, '0'))\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in range(min(4, num + 1)):\\n    for a in possible_number(i):\\n        for b in possible_number(num - i, True):\\n            ans.add(str(a) + \\\":\\\" + str(b).rjust(2, '0'))\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        def possible_number(count, minute=False):\\n            if count == 0: return [0]\\n            if minute:\\n                return filter(lambda a: a < 60, map(sum, combinations([1, 2, 4, 8, 16, 32], count)))\\n            return filter(lambda a: a < 12, map(sum, combinations([1, 2, 4, 8], count)))\\n        ans = set()\\n        for i in range(min(4, num + 1)):\\n            for a in possible_number(i):\\n                for b in possible_number(num - i, True):\\n                    ans.add(str(a) + \\\":\\\" + str(b).rjust(2, '0'))\\n        return list(ans)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def readBinaryWatch(self, num: int) -> List[str]:\\n        return [str(a) + \\\":\\\" + str(b).rjust(2, '0') for a in range(12) for b in range(60) if (bin(a)+bin(b)).count('1') == num]\\n\"\n        }\n    ]\n},\n\"partition-equal-subset-sum\":{\n    \"id\": \"416\",\n    \"name\": \"partition-equal-subset-sum\",\n    \"pre\": [\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/416.partition-equal-subset-sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/416.partition-equal-subset-sum.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar canPartition = function (nums) {\\n  let sum = nums.reduce((acc, num) => acc + num, 0);\\n  if (sum % 2) {\\n    return false;\\n  }\\n  sum = sum / 2;\\n  return dfs(nums, sum, 0);\\n};\\n\\nfunction dfs(nums, target, cur) {\\n  if (target < 0 || cur > nums.length) {\\n    return false;\\n  }\\n  return (\\n    target === 0 ||\\n    dfs(nums, target - nums[cur], cur + 1) ||\\n    dfs(nums, target, cur + 1)\\n  );\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar canPartition = function (nums) {\\n  let sum = nums.reduce((acc, num) => acc + num, 0);\\n  if (sum % 2) {\\n    return false;\\n  }\\n  sum = sum / 2;\\n  nums = nums.sort((a, b) => b - a);\\n  if (sum < nums[0]) {\\n    return false;\\n  }\\n  return dfs(nums, sum, sum, 0);\\n};\\n\\nfunction dfs(nums, pickRemain, discardRemain, cur) {\\n  if (pickRemain === 0 || discardRemain === 0) {\\n    return true;\\n  }\\n\\n  if (pickRemain < 0 || discardRemain < 0 || cur > nums.length) {\\n    return false;\\n  }\\n\\n  return (\\n    dfs(nums, pickRemain - nums[cur], discardRemain, cur + 1) ||\\n    dfs(nums, pickRemain, discardRemain - nums[cur], cur + 1)\\n  );\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar canPartition = function (nums) {\\n  let sum = nums.reduce((acc, num) => acc + num, 0);\\n  if (sum % 2) {\\n    return false;\\n  } else {\\n    sum = sum / 2;\\n  }\\n\\n  const dp = Array.from(nums).map(() =>\\n    Array.from({ length: sum + 1 }).fill(false)\\n  );\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    dp[i][0] = true;\\n  }\\n\\n  for (let i = 0; i < dp.length - 1; i++) {\\n    for (let j = 0; j < dp[0].length; j++) {\\n      dp[i + 1][j] =\\n        j - nums[i] >= 0 ? dp[i][j] || dp[i][j - nums[i]] : dp[i][j];\\n    }\\n  }\\n\\n  return dp[nums.length - 1][sum];\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar canPartition = function (nums) {\\n  let sum = nums.reduce((acc, num) => acc + num, 0);\\n  if (sum % 2) {\\n    return false;\\n  }\\n  sum = sum / 2;\\n  const dp = Array.from({ length: sum + 1 }).fill(false);\\n  dp[0] = true;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = sum; j > 0; j--) {\\n      dp[j] = dp[j] || (j - nums[i] >= 0 && dp[j - nums[i]]);\\n    }\\n  }\\n\\n  return dp[sum];\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number} amount\\n * @param {number[]} coins\\n * @return {number}\\n */\\nvar change = function (amount, coins) {\\n  const dp = Array.from({ length: amount + 1 }).fill(0);\\n  dp[0] = 1;\\n  for (let i = 0; i < coins.length; i++) {\\n    for (let j = 1; j <= amount; j++) {\\n      dp[j] = dp[j] + (j - coins[i] >= 0 ? dp[j - coins[i]] : 0);\\n    }\\n  }\\n  return dp[amount];\\n};\\n\"\n        }\n    ]\n},\n\"longest-repeating-character-replacement\":{\n    \"id\": \"424\",\n    \"name\": \"longest-repeating-character-replacement\",\n    \"pre\": [],\n    \"keyPoints\": [\n        {\n            \"text\": \"最长连续1模型\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/424.longest-repeating-character-replacement.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/424.longest-repeating-character-replacement.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        def fix(c, k):\\n            ans = i = 0\\n            for j in range(len(s)):\\n                k -= s[j] != c\\n                while i < j and k < 0:\\n                    k += s[i] != c\\n                    i += 1\\n                ans = max(ans, j - i + 1)\\n            return ans\\n \\n        ans = 0\\n        for i in range(26):\\n            ans = max(ans, fix(chr(ord(\\\"A\\\") + i), k))\\n        return ans\\n \\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        if not s: return 0\\n        counts = [0] * 26\\n        i = most_fraq = 0\\n        for j in range(len(s)):\\n            counts[ord(s[j]) - ord(\\\"A\\\")] += 1\\n            most_fraq = max(most_fraq, counts[ord(s[j]) - ord(\\\"A\\\")])\\n            while i < j and j - i + 1 - most_fraq > k:\\n                counts[ord(s[i]) - ord(\\\"A\\\")] -= 1\\n                most_fraq = max(most_fraq, counts[ord(s[j]) - ord(\\\"A\\\")])\\n                i += 1\\n        return j - i + 1\\n\"\n        }\n    ]\n},\n\"path-sum-iii\":{\n    \"id\": \"437\",\n    \"name\": \"path-sum-iii\",\n    \"pre\": [\n        {\n            \"text\": \"hashmap\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"通过hashmap，以时间换空间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"对于这种连续的元素求和问题，有一个共同的思路，可以参考[这道题目](./560.subarray\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"sum\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"equals\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"k.md)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/437.path-sum-iii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/437.path-sum-iii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n// the number of the paths starting from self\\nfunction helper(root, sum) {\\n  if (root === null) return 0;\\n  const l = helper(root.left, sum - root.val);\\n  const r = helper(root.right, sum - root.val);\\n\\n  return l + r + (root.val === sum ? 1 : 0);\\n}\\n/**\\n * @param {TreeNode} root\\n * @param {number} sum\\n * @return {number}\\n */\\nvar pathSum = function (root, sum) {\\n  // 空间复杂度O(n) 时间复杂度介于O(nlogn) 和 O(n^2)\\n  // tag: dfs tree\\n  if (root === null) return 0;\\n  // the number of the paths starting from self\\n  const self = helper(root, sum);\\n  // we don't know the answer, so we just pass it down\\n  const l = pathSum(root.left, sum);\\n  // we don't know the answer, so we just pass it down\\n  const r = pathSum(root.right, sum);\\n\\n  return self + l + r;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=437 lang=javascript\\n *\\n * [437] Path Sum III\\n */\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\nfunction helper(root, acc, target, hashmap) {\\n  // see also : https://leetcode.com/problems/subarray-sum-equals-k/\\n\\n  if (root === null) return 0;\\n  let count = 0;\\n  acc += root.val;\\n  if (acc === target) count++;\\n  if (hashmap[acc - target] !== void 0) {\\n    count += hashmap[acc - target];\\n  }\\n  if (hashmap[acc] === void 0) {\\n    hashmap[acc] = 1;\\n  } else {\\n    hashmap[acc] += 1;\\n  }\\n  const res =\\n    count +\\n    helper(root.left, acc, target, hashmap) +\\n    helper(root.right, acc, target, hashmap);\\n\\n  // 这里要注意别忘记了\\n  hashmap[acc] = hashmap[acc] - 1;\\n\\n  return res;\\n}\\n\\nvar pathSum = function (root, sum) {\\n  const hashmap = {};\\n  return helper(root, 0, sum, hashmap);\\n};\\n\"\n        }\n    ]\n},\n\"add-two-numbers-ii\":{\n    \"id\": \"445\",\n    \"name\": \"add-two-numbers-ii\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"栈的基本操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"carried变量记录进位\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"循环的终止条件设置成`stack.length>0`可以简化操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"注意特殊情况，比如1+99=100\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/445.add-two-numbers-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/445.add-two-numbers-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=445 lang=javascript\\n *\\n * [445] Add Two Numbers II\\n */\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} l1\\n * @param {ListNode} l2\\n * @return {ListNode}\\n */\\nvar addTwoNumbers = function (l1, l2) {\\n  const stack1 = [];\\n  const stack2 = [];\\n  const stack = [];\\n\\n  let cur1 = l1;\\n  let cur2 = l2;\\n  let curried = 0;\\n\\n  while (cur1) {\\n    stack1.push(cur1.val);\\n    cur1 = cur1.next;\\n  }\\n\\n  while (cur2) {\\n    stack2.push(cur2.val);\\n    cur2 = cur2.next;\\n  }\\n\\n  let a = null;\\n  let b = null;\\n\\n  while (stack1.length > 0 || stack2.length > 0) {\\n    a = Number(stack1.pop()) || 0;\\n    b = Number(stack2.pop()) || 0;\\n\\n    stack.push((a + b + curried) % 10);\\n\\n    if (a + b + curried >= 10) {\\n      curried = 1;\\n    } else {\\n      curried = 0;\\n    }\\n  }\\n\\n  if (curried === 1) {\\n    stack.push(1);\\n  }\\n\\n  const dummy = {};\\n\\n  let current = dummy;\\n\\n  while (stack.length > 0) {\\n    current.next = {\\n      val: stack.pop(),\\n      next: null,\\n    };\\n\\n    current = current.next;\\n  }\\n\\n  return dummy.next;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\\n        def listToStack(l: ListNode) -> list:\\n            stack, c = [], l\\n            while c:\\n                stack.append(c.val)\\n                c = c.next\\n            return stack\\n\\n        # transfer l1 and l2 into stacks\\n        stack1, stack2 = listToStack(l1), listToStack(l2)\\n\\n        # add stack1 and stack2\\n        diff = abs(len(stack1) - len(stack2))\\n        stack1 = ([0]*diff + stack1 if len(stack1) < len(stack2) else stack1)\\n        stack2 = ([0]*diff + stack2 if len(stack2) < len(stack1) else stack2)\\n        stack3 = [x + y for x, y in zip(stack1, stack2)]\\n\\n        # calculate carry for each item in stack3 and add one to the item before it\\n        carry = 0\\n        for i, val in enumerate(stack3[::-1]):\\n            index = len(stack3) - i - 1\\n            carry, stack3[index] = divmod(val + carry, 10)\\n            if carry and index == 0:\\n                stack3 = [1] + stack3\\n            elif carry:\\n                stack3[index - 1] += 1\\n\\n        # transfer stack3 to a linkedList\\n        result = ListNode(0)\\n        c = result\\n        for item in stack3:\\n            c.next = ListNode(item)\\n            c = c.next\\n\\n        return result.next\\n\"\n        }\n    ]\n},\n\"4-sum-ii\":{\n    \"id\": \"454\",\n    \"name\": \"4-sum-ii\",\n    \"pre\": [\n        {\n            \"text\": \"hashTable\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"两两分组，求出两两结合能够得出的可能数，然后合并即可。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/454.4-sum-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/454.4-sum-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=454 lang=javascript\\n *\\n * [454] 4Sum II\\n *\\n * https://leetcode.com/problems/4sum-ii/description/\\n/**\\n * @param {number[]} A\\n * @param {number[]} B\\n * @param {number[]} C\\n * @param {number[]} D\\n * @return {number}\\n */\\nvar fourSumCount = function (A, B, C, D) {\\n  const sumMapper = {};\\n  let res = 0;\\n  for (let i = 0; i < A.length; i++) {\\n    for (let j = 0; j < B.length; j++) {\\n      sumMapper[A[i] + B[j]] = (sumMapper[A[i] + B[j]] || 0) + 1;\\n    }\\n  }\\n\\n  for (let i = 0; i < C.length; i++) {\\n    for (let j = 0; j < D.length; j++) {\\n      res += sumMapper[-(C[i] + D[j])] || 0;\\n    }\\n  }\\n\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\\n        mapper = {}\\n        res = 0\\n        for i in A:\\n            for j in B:\\n                mapper[i + j] = mapper.get(i + j, 0) + 1\\n\\n        for i in C:\\n            for j in D:\\n                res += mapper.get(-1 * (i + j), 0)\\n        return res\\n\"\n        }\n    ]\n},\n\"AssignCookies\":{\n    \"id\": \"455\",\n    \"name\": \"AssignCookies\",\n    \"pre\": [\n        {\n            \"text\": \"贪心算法\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/greedy.md\",\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"先排序再贪心\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/455.AssignCookies.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/455.AssignCookies.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} g\\n * @param {number[]} s\\n * @return {number}\\n */\\nconst findContentChildren = function (g, s) {\\n    g = g.sort((a, b) => a - b);\\n    s = s.sort((a, b) => a - b);\\n    let gi = 0; // 胃口值\\n    let sj = 0; // 饼干尺寸\\n    let res = 0;\\n    while (gi < g.length && sj < s.length) {\\n        // 当饼干 sj >= 胃口 gi 时，饼干满足胃口，更新满足的孩子数并移动指针\\n        if (s[sj] >= g[gi]) {\\n            gi++;\\n            sj++;\\n            res++;\\n        } else {\\n            // 当饼干 sj < 胃口 gi 时，饼干不能满足胃口，需要换大的\\n            sj++;\\n        }\\n    }\\n    return res;\\n};\\n\"\n        }\n    ]\n},\n\"lfu-cache\":{\n    \"id\": \"460\",\n    \"name\": \"lfu-cache\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"HashMap\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析用两个`Map`分别保存`nodeMap{key,node}`和`freqMap{frequent,DoublyLinkedList}`。实现`get`和`put`操作都是`O(1)`的时间复杂度。可以用Java自带的一些数据结构，比如HashLinkedHashSet，这样就不需要自己自建Node，DoublelyLinkedList。可以很大程度的缩减代码量。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/460.lfu-cache.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/460.lfu-cache.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic class LC460LFUCache {\\n  class Node {\\n    int key, val, freq;\\n    Node prev, next;\\n\\n    Node(int key, int val) {\\n      this.key = key;\\n      this.val = val;\\n      freq = 1;\\n    }\\n  }\\n\\n  class DoubleLinkedList {\\n    private Node head;\\n    private Node tail;\\n    private int size;\\n\\n    DoubleLinkedList() {\\n      head = new Node(0, 0);\\n      tail = new Node(0, 0);\\n      head.next = tail;\\n      tail.prev = head;\\n    }\\n\\n    void add(Node node) {\\n      head.next.prev = node;\\n      node.next = head.next;\\n      node.prev = head;\\n      head.next = node;\\n      size++;\\n    }\\n\\n    void remove(Node node) {\\n      node.prev.next = node.next;\\n      node.next.prev = node.prev;\\n      size--;\\n    }\\n\\n    // always remove last node if last node exists\\n    Node removeLast() {\\n      if (size > 0) {\\n        Node node = tail.prev;\\n        remove(node);\\n        return node;\\n      } else return null;\\n    }\\n  }\\n\\n  // cache capacity\\n  private int capacity;\\n  // min frequent\\n  private int minFreq;\\n  Map<Integer, Node> nodeMap;\\n  Map<Integer, DoubleLinkedList> freqMap;\\n  public LC460LFUCache(int capacity) {\\n    this.minFreq = 0;\\n    this.capacity = capacity;\\n    nodeMap = new HashMap<>();\\n    freqMap = new HashMap<>();\\n  }\\n\\n  public int get(int key) {\\n    Node node = nodeMap.get(key);\\n    if (node == null) return -1;\\n    update(node);\\n    return node.val;\\n  }\\n\\n  public void put(int key, int value) {\\n    if (capacity == 0) return;\\n    Node node;\\n    if (nodeMap.containsKey(key)) {\\n      node = nodeMap.get(key);\\n      node.val = value;\\n      update(node);\\n    } else {\\n      node = new Node(key, value);\\n      nodeMap.put(key, node);\\n      if (nodeMap.size() == capacity) {\\n        DoubleLinkedList lastList = freqMap.get(minFreq);\\n        nodeMap.remove(lastList.removeLast().key);\\n      }\\n      minFreq = 1;\\n      DoubleLinkedList newList = freqMap.getOrDefault(node.freq, new DoubleLinkedList());\\n      newList.add(node);\\n      freqMap.put(node.freq, newList);\\n    }\\n  }\\n\\n  private void update(Node node) {\\n    DoubleLinkedList oldList = freqMap.get(node.freq);\\n    oldList.remove(node);\\n    if (node.freq == minFreq && oldList.size == 0) minFreq++;\\n    node.freq++;\\n    DoubleLinkedList newList = freqMap.getOrDefault(node.freq, new DoubleLinkedList());\\n    newList.add(node);\\n    freqMap.put(node.freq, newList);\\n  }\\n }\\n\"\n        }\n    ]\n},\n\"can-i-win\":{\n    \"id\": \"464\",\n    \"name\": \"can-i-win\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md \\\"动态规划\\\"\",\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"回溯\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/backtrack.md\",\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"状态压缩\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"linkedin\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/464.can-i-win.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/464.can-i-win.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic class Solution {\\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\\n\\n        if (maxChoosableInteger >= desiredTotal) return true;\\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\\n\\n        Boolean[] dp = new Boolean[(1 << maxChoosableInteger) - 1];\\n        return dfs(maxChoosableInteger, desiredTotal, 0, dp);\\n    }\\n\\n    private boolean dfs(int maxChoosableInteger, int desiredTotal, int state, Boolean[] dp) {\\n        if (dp[state] != null)\\n            return dp[state];\\n        for (int i = 1; i <= maxChoosableInteger; i++){\\n            int tmp = (1 << (i - 1));\\n            if ((tmp & state) == 0){\\n                if (desiredTotal - i <= 0 || !dfs(maxChoosableInteger, desiredTotal - i, tmp|state, dp)) {\\n                    dp[state] = true;\\n                    return true;\\n                }\\n            }\\n        }\\n        dp[state] = false;\\n        return false;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar canIWin = function (maxChoosableInteger, desiredTotal) {\\n  // 直接获胜\\n  if (maxChoosableInteger >= desiredTotal) return true;\\n\\n  // 全部拿完也无法到达\\n  var sum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\\n  if (desiredTotal > sum) return false;\\n\\n  // 记忆化\\n  var dp = {};\\n\\n  /**\\n   * @param {number} total 剩余的数量\\n   * @param {number} state 使用二进制位表示抽过的状态\\n   */\\n  function f(total, state) {\\n    // 有缓存\\n    if (dp[state] !== undefined) return dp[state];\\n\\n    for (var i = 1; i <= maxChoosableInteger; i++) {\\n      var curr = 1 << i;\\n      // 已经抽过这个数\\n      if (curr & state) continue;\\n      // 直接获胜\\n      if (i >= total) return (dp[state] = true);\\n      // 可以让对方输\\n      if (!f(total - i, state | curr)) return (dp[state] = true);\\n    }\\n\\n    // 没有任何让对方输的方法\\n    return (dp[state] = false);\\n  }\\n\\n  return f(desiredTotal, 0);\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\\n        int sum = (1+maxChoosableInteger)*maxChoosableInteger/2;\\n        if(sum < desiredTotal){\\n            return false;\\n        }\\n        unordered_map<int,int> d;\\n        return dfs(maxChoosableInteger,0,desiredTotal,0,d);\\n    }\\n\\n    bool dfs(int n,int s,int t,int S,unordered_map<int,int>& d){\\n        if(d[S]) return  d[S];\\n        int& ans = d[S];\\n\\n        if(s >= t){\\n            return ans = true;\\n        }\\n        if(S == (((1 << n)-1) << 1)){\\n            return ans = false;\\n        }\\n\\n        for(int m = 1;m <=n;++m){\\n            if(S & (1 << m)){\\n                continue;\\n            }\\n            int nextS = S|(1 << m);\\n            if(s+m >= t){\\n                return ans = true;\\n            }\\n            bool r1 = dfs(n,s+m,t,nextS,d);\\n            if(!r1){\\n                return ans = true;\\n            }\\n        }\\n        return ans = false;\\n    }\\n};\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        # acc 表示当前累计的数字和\\n        def dfs(acc):\\n            if acc >= desiredTotal:\\n                return False\\n            for n in range(1, maxChoosableInteger + 1):\\n                # 对方有一种情况赢不了，我就选这个数字就能赢了，返回 true，代表可以赢。\\n                if not dfs(acc + n):\\n                    return True\\n            return False\\n\\n        # 初始化集合，用于保存当前已经选择过的数。\\n        return dfs(0)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal <= maxChoosableInteger:\\n            return True\\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\\n            return False\\n        # picked 用于保存当前已经选择过的数。\\n        # acc 表示当前累计的数字和\\n        def backtrack(picked, acc):\\n            if acc >= desiredTotal:\\n                return False\\n            if len(picked) == maxChoosableInteger:\\n                # 说明全部都被选了，没得选了，返回 False， 代表输了。\\n                return False\\n            for n in range(1, maxChoosableInteger + 1):\\n                if n not in picked:\\n                    picked.add(n)\\n                    # 对方有一种情况赢不了，我就选这个数字就能赢了，返回 true，代表可以赢。\\n                    if not backtrack(picked, acc + n):\\n                        picked.remove(n)\\n                        return True\\n                    picked.remove(n)\\n            return False\\n\\n        # 初始化集合，用于保存当前已经选择过的数。\\n        return backtrack(set(), 0)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n1 << a\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\na | b\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nseen = 0b0000000\\na = 0b0000001\\nb = ob0000010\\n\\nseen |= a 后，  seen 为 0b0000001\\nseen |= b 后，  seen 为 0b0000011\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\na & b\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nmask = 0b0000010\\na & mask == 1 说明 a 在第二位（从低到高）是 1\\na & mask == 0 说明 a 在第二位（从低到高）是 0\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\npicked == (1 << (maxChoosableInteger + 1)) - 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\\n        if desiredTotal <= maxChoosableInteger:\\n            return True\\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\\n            return False\\n\\n        @lru_cache(None)\\n        def dp(picked, acc):\\n            if acc >= desiredTotal:\\n                return False\\n            if picked == (1 << (maxChoosableInteger + 1)) - 1:\\n                return False\\n            for n in range(1, maxChoosableInteger + 1):\\n                if picked & 1 << n == 0:\\n                    if not dp(picked | 1 << n, acc + n):\\n                        return True\\n            return False\\n\\n        return dp(0, 0)\\n\"\n        }\n    ]\n},\n\"concatenated-words\":{\n    \"id\": \"472\",\n    \"name\": \"concatenated-words\",\n    \"pre\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"前缀树\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/472.concatenated-words.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/472.concatenated-words.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Trie:\\n\\n    def __init__(self):\\n        self.Trie = {}\\n        self.visited = {}\\n\\n    def insert(self, word):\\n        curr = self.Trie\\n        for w in word:\\n            if w not in curr:\\n                curr[w] = {}\\n            curr = curr[w]\\n        curr['#'] = 1\\n\\n    def cntWords(self, word):\\n        if not word:\\n            return 0\\n        if word in self.visited:\\n            return self.visited[word]\\n        curr = self.Trie\\n        res = float('-inf')\\n\\n        for i, w in enumerate(word):\\n            if w not in curr:\\n                return res\\n            curr = curr[w]\\n            if '#' in curr:\\n                res = max(res, 1 + self.cntWords(word[i + 1:]))\\n        self.visited[word] = res\\n        return res\\n\\n\\nclass Solution:\\n    def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:\\n        self.trie = Trie()\\n        res = []\\n\\n        for word in words:\\n            self.trie.insert(word)\\n        for word in words:\\n            if self.trie.cntWords(word) >= 2:\\n                res.append(word)\\n        return res\\n\"\n        }\n    ]\n},\n\"sliding-window-median\":{\n    \"id\": \"480\",\n    \"name\": \"sliding-window-median\",\n    \"pre\": [\n        {\n            \"text\": \"二分查找\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/91/binary-search.md\",\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"滑动窗口+二分\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/480.sliding-window-median.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/480.sliding-window-median.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def medianSlidingWindow(self, A: List[int], k: int) -> List[float]:\\n        ans = []\\n        win = []\\n\\n        for i, a in enumerate(A):\\n            bisect.insort(win, a)\\n            if i >= k:\\n                win.pop(bisect.bisect_left(win, A[i - k]))\\n            if i >= k - 1:\\n                if k & 1:\\n                    median = win[k // 2]\\n                else:\\n                    median = (win[k // 2] + win[k // 2 - 1]) / 2\\n                ans.append(median)\\n        return ans\\n\\n\\n\"\n        }\n    ]\n},\n\"smallest-good-base\":{\n    \"id\": \"483\",\n    \"name\": \"smallest-good-base\",\n    \"pre\": [\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"进制转换\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"利用等比数列求和公式可降低时间复杂度\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"从进制转换入手发现单调性，从而使用二分解决\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/483.smallest-good-base.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/483.smallest-good-base.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def smallestGoodBase(self, n: str) -> str:\\n        n = int(n)\\n        # 上面提到的 base 进制转十进制公式。\\n        # 使用等比数列求和公式可简化时间复杂度\\n        def sum_with(base, N):\\n            return (1 - base ** N) // (1 - base)\\n            # return sum(1 * base ** i for i in range(N))\\n        # bin(n) 会计算出 n 的二进制表示， 其会返回形如 '0b10111' 的字符串，因此需要减去 2。\\n        for N in range(len(bin(n)) - 2, 0, -1):\\n            l = 2\\n            r = n - 1\\n            while l <= r:\\n                mid = (l + r) // 2\\n                v = sum_with(mid, N)\\n\\n                if v < n:\\n                    l = mid + 1\\n                elif v > n:\\n                    r = mid - 1\\n                else:\\n                    return str(mid)\\n\\n\"\n        }\n    ]\n},\n\"zuma-game\":{\n    \"id\": \"488\",\n    \"name\": \"zuma-game\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"双指针写法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"百度\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/488.zuma-game.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/488.zuma-game.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ni = 0\\nwhile i < len(board):\\n    j = i + 1\\n    while j < len(board) and board[i] == board[j]: j += 1\\n    # 其他逻辑\\n\\n    # 更新左指针\\n    i = j\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findMinStep(self, board: str, hand: str) -> int:\\n        def backtrack(board):\\n            if not board: return 0\\n            i = 0\\n            ans = 6\\n            while i < len(board):\\n                j = i + 1\\n                while j < len(board) and board[i] == board[j]: j += 1\\n                balls = 3 - (j - i)\\n                if counter[board[i]] >= balls:\\n                    balls = max(0, balls)\\n                    counter[board[i]] -= balls\\n                    ans = min(ans, balls + backtrack(board[:i] + board[j:]))\\n                    counter[board[i]] += balls\\n                i = j\\n            return ans\\n\\n        counter = collections.Counter(hand)\\n        ans = backtrack(board)\\n        return -1 if ans > 5 else ans\\n\\n\"\n        }\n    ]\n},\n\"reverse-pairs\":{\n    \"id\": \"493\",\n    \"name\": \"reverse-pairs\",\n    \"pre\": [\n        {\n            \"text\": \"归并排序\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        },\n        {\n            \"text\": \"逆序数\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        },\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"归并排序\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"逆序数\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"识别考点，其他非重点可以使用语言内置方法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/493.reverse-pairs.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/493.reverse-pairs.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        n = len(nums)\\n        cnt = 0\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if nums[i] > 2 * nums[j]:\\n                    cnt += 1\\n        return cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nl = r = 0\\nwhile l < len(left) and r < len(right):\\n    if left[l] <= 2 * right[r]:\\n        l += 1\\n    else:\\n        self.cnt += len(left) - l\\n        r += 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def reversePairs(self, nums):\\n        self.cnt = 0\\n\\n        def mergeSort(lst):\\n            L = len(lst)\\n            if L <= 1:\\n                return lst\\n            return mergeTwo(mergeSort(lst[:L//2]), mergeSort(lst[L//2:]))\\n\\n        def mergeTwo(left, right):\\n            l = r = 0\\n            while l < len(left) and r < len(right):\\n                if left[l] <= 2 * right[r]:\\n                    l += 1\\n                else:\\n                    self.cnt += len(left) - l\\n                    r += 1\\n            return sorted(left+right)\\n\\n        mergeSort(nums)\\n        return self.cnt\\n\\n\"\n        }\n    ]\n},\n\"target-sum\":{\n    \"id\": \"494\",\n    \"name\": \"target-sum\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"对元素进行分组，分组的依据是符号，是`+`或者`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"通过数学公式推导可以简化我们的求解过程，这需要一点`数学知识和数学意识`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/494.target-sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/494.target-sum.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=494 lang=javascript\\n *\\n * [494] Target Sum\\n *\\n */\\n// 这个是我们熟悉的问题了\\n// 我们这里需要求解的是nums里面有多少种可以组成target的方式\\nvar sumCount = function (nums, target) {\\n  // 这里通过观察，我们没必要使用二维数组去存储这些计算结果\\n  // 使用一维数组可以有效节省空间\\n  const dp = Array(target + 1).fill(0);\\n  dp[0] = 1;\\n  for (let i = 0; i < nums.length; i++) {\\n    for (let j = target; j >= nums[i]; j--) {\\n      dp[j] += dp[j - nums[i]];\\n    }\\n  }\\n  return dp[target];\\n};\\nconst add = (nums) => nums.reduce((a, b) => (a += b), 0);\\n/**\\n * @param {number[]} nums\\n * @param {number} S\\n * @return {number}\\n */\\nvar findTargetSumWays = function (nums, S) {\\n  const sum = add(nums);\\n  if (sum < S) return 0;\\n  if ((S + sum) % 2 === 1) return 0;\\n  return sumCount(nums, (S + sum) >> 1);\\n};\\n\"\n        }\n    ]\n},\n\"base-7\":{\n    \"id\": \"504\",\n    \"name\": \"base-7\",\n    \"pre\": [],\n    \"keyPoints\": [\n        {\n            \"text\": \"除x取余，并逆序输出\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/504.base-7.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/504.base-7.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def convertToBase7(self, num: int) -> str:\\n        if num < 0:\\n            return \\\"-\\\" + self.convertToBase7(-num)\\n        if num < 7:\\n            return str(num)\\n        return self.convertToBase7(num // 7) + str(num % 7)\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def convertToBase7(self, num: int) -> str:\\n        if num == 0:\\n            return 0\\n        ans = []\\n        is_negative = num < 0\\n        num = abs(num)\\n        while num > 0:\\n            num, remain = num // 7, num % 7\\n            ans.append(str(remain))\\n\\n        return \\\"-\\\" + \\\"\\\".join(ans[::-1]) if is_negative else \\\"\\\".join(ans[::-1])\\n\\n\"\n        }\n    ]\n},\n\"find-bottom-left-tree-value\":{\n    \"id\": \"513\",\n    \"name\": \"find-bottom-left-tree-value\",\n    \"pre\": [],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/513.find-bottom-left-tree-value.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/513.find-bottom-left-tree-value.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    int maxLevel = 0;\\n    public int findBottomLeftValue(TreeNode root) {\\n        if (root == null) return 0;\\n        LinkedList<TreeNode> deque = new LinkedList<>();\\n        deque.add(root);\\n        int res = 0;\\n        while(!deque.isEmpty()) {\\n            int size = deque.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = deque.pollFirst();\\n                if (i == 0) {\\n                    res = node.val;\\n                }\\n                if (node.left != null)deque.addLast(node.left);\\n                if (node.right != null)deque.addLast(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    int max = 0;\\n    Map<Integer,Integer> map = new HashMap<>();\\n    public int findBottomLeftValue(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root,0);\\n        return map.get(max);\\n    }\\n\\n    void dfs (TreeNode node,int level){\\n        if (node == null){\\n            return;\\n        }\\n        int curLevel = level+1;\\n        dfs(node.left,curLevel);\\n        if (curLevel > max && !map.containsKey(curLevel)){\\n            map.put(curLevel,node.val);\\n            max = curLevel;\\n        }\\n        dfs(node.right,curLevel);\\n    }\\n\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar findBottomLeftValue = function (root) {\\n  let curLevel = [root];\\n  let res = root.val;\\n  while (curLevel.length) {\\n    let nextLevel = [];\\n    for (let i = 0; i < curLevel.length; i++) {\\n      curLevel[i].left && nextLevel.push(curLevel[i].left);\\n      curLevel[i].right && nextLevel.push(curLevel[i].right);\\n    }\\n    res = curLevel[0].val;\\n    curLevel = nextLevel;\\n  }\\n  return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction findBottomLeftValue(root) {\\n  let maxDepth = 0;\\n  let res = root.val;\\n\\n  dfs(root.left, 0);\\n  dfs(root.right, 0);\\n\\n  return res;\\n\\n  function dfs(cur, depth) {\\n    if (!cur) {\\n      return;\\n    }\\n    const curDepth = depth + 1;\\n    if (curDepth > maxDepth) {\\n      maxDepth = curDepth;\\n      res = cur.val;\\n    }\\n    dfs(cur.left, curDepth);\\n    dfs(cur.right, curDepth);\\n  }\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int findBottomLeftValue_bfs(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        TreeNode* ans = NULL;\\n        q.push(root);\\n        while (!q.empty()) {\\n            ans = q.front();\\n            int size = q.size();\\n            while (size--) {\\n                TreeNode* cur = q.front();\\n                q.pop();\\n                if (cur->left )\\n                    q.push(cur->left);\\n                if (cur->right)\\n                    q.push(cur->right);\\n            }\\n        }\\n        return ans->val;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int res;\\n    int max_depth = 0;\\n    void findBottomLeftValue_core(TreeNode* root, int depth) {\\n        if (root->left || root->right) {\\n            if (root->left)\\n                findBottomLeftValue_core(root->left, depth + 1);\\n            if (root->right)\\n                findBottomLeftValue_core(root->right, depth + 1);\\n        } else {\\n            if (depth > max_depth) {\\n                res = root->val;\\n                max_depth = depth;\\n            }\\n        }\\n    }\\n    int findBottomLeftValue(TreeNode* root) {\\n        findBottomLeftValue_core(root, 1);\\n        return res;\\n    }\\n};\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def findBottomLeftValue(self, root):\\n        queue = collections.deque()\\n        queue.append(root)\\n        while queue:\\n            length = len(queue)\\n            res = queue[0].val\\n            for _ in range(length):\\n                cur = queue.popleft()\\n                if cur.left:\\n                    queue.append(cur.left)\\n                if cur.right:\\n                    queue.append(cur.right)\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n\\n    def __init__(self):\\n        self.res = 0\\n        self.max_level = 0\\n\\n    def findBottomLeftValue(self, root):\\n        self.res = root.val\\n        def dfs(root, level):\\n            if not root:\\n                return\\n            if level > self.max_level:\\n                self.res = root.val\\n                self.max_level = level\\n            dfs(root.left, level + 1)\\n            dfs(root.right, level + 1)\\n        dfs(root, 0)\\n\\n        return self.res\\n\"\n        }\n    ]\n},\n\"longest-palindromic-subsequence\":{\n    \"id\": \"516\",\n    \"name\": \"longest-palindromic-subsequence\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"”延伸“（extend）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/516.longest-palindromic-subsequence.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/516.longest-palindromic-subsequence.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nif (s[i] === s[j]) {\\n  dp[i][j] = dp[i + 1][j - 1] + 2;\\n} else {\\n  dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=516 lang=javascript\\n *\\n * [516] Longest Palindromic Subsequence\\n */\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestPalindromeSubseq = function (s) {\\n  // bbbab 返回4\\n  // tag : dp\\n  const dp = [];\\n\\n  for (let i = s.length - 1; i >= 0; i--) {\\n    dp[i] = Array(s.length).fill(0);\\n    for (let j = i; j < s.length; j++) {\\n      if (i - j === 0) dp[i][j] = 1;\\n      else if (s[i] === s[j]) {\\n        dp[i][j] = dp[i + 1][j - 1] + 2;\\n      } else {\\n        dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);\\n      }\\n    }\\n  }\\n\\n  return dp[0][s.length - 1];\\n};\\n\"\n        }\n    ]\n},\n\"coin-change-2\":{\n    \"id\": \"518\",\n    \"name\": \"coin-change-2\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"背包问题\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/518.coin-change-2.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nif (amount === 0) return 1;\\n\\nconst dp = [Array(amount + 1).fill(1)];\\n\\nfor (let i = 1; i < amount + 1; i++) {\\n  dp[i] = Array(coins.length + 1).fill(0);\\n  for (let j = 1; j < coins.length + 1; j++) {\\n    // 从1开始可以简化运算\\n    if (i - coins[j - 1] >= 0) {\\n      // 注意这里是coins[j -1]而不是coins[j]\\n      dp[i][j] = dp[i][j - 1] + dp[i - coins[j - 1]][j]; // 由于可以重复使用硬币所以这里是j不是j-1\\n    } else {\\n      dp[i][j] = dp[i][j - 1];\\n    }\\n  }\\n}\\n\\nreturn dp[dp.length - 1][coins.length];\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 这种答案是不对的。\\n// 原因在于比如amount = 5, coins = [1,2,5]\\n// 这种算法会将[1,2,2] [2,1,2] [2, 2, 1] 算成不同的\\n\\nif (amount === 0) return 1;\\n\\nconst dp = [1].concat(Array(amount).fill(0));\\n\\nfor (let i = 1; i < amount + 1; i++) {\\n  for (let j = 0; j < coins.length; j++) {\\n    if (i - coins[j] >= 0) {\\n      dp[i] = dp[i] + dp[i - coins[j]];\\n    }\\n  }\\n}\\n\\nreturn dp[dp.length - 1];\\n\\n// 正确的写法应该是内外循环调换一下, 具体可以看下方代码区\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=518 lang=javascript\\n *\\n * [518] Coin Change 2\\n *\\n */\\n/**\\n * @param {number} amount\\n * @param {number[]} coins\\n * @return {number}\\n */\\nvar change = function (amount, coins) {\\n  if (amount === 0) return 1;\\n\\n  const dp = [1].concat(Array(amount).fill(0));\\n\\n  for (let j = 0; j < coins.length; j++) {\\n    for (let i = 1; i < amount + 1; i++) {\\n      if (i - coins[j] >= 0) {\\n        dp[i] = dp[i] + dp[i - coins[j]];\\n      }\\n    }\\n  }\\n\\n  return dp[dp.length - 1];\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def change(self, amount: int, coins: List[int]) -> int:\\n        dp = [0] * (amount + 1)\\n        dp[0] = 1\\n\\n        for j in range(len(coins)):\\n            for i in range(1, amount + 1):\\n                if i >= coins[j]:\\n                    dp[i] += dp[i - coins[j]]\\n\\n        return dp[-1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def change(self, amount: int, coins: List[int]) -> int:\\n        dp = [[0 for _ in range(len(coins) + 1)] for _ in range(amount + 1)]\\n        for j in range(len(coins) + 1):\\n            dp[0][j] = 1\\n\\n        for i in range(amount + 1):\\n            for j in range(1, len(coins) + 1):\\n                if i >= coins[j - 1]:\\n                    dp[i][j] = dp[i - coins[j - 1]][j] + dp[i][j - 1]\\n                else:\\n                    dp[i][j] = dp[i][j - 1]\\n        return dp[-1][-1]\\n\"\n        }\n    ]\n},\n\"friend-circles\":{\n    \"id\": \"547\",\n    \"name\": \"friend-circles\",\n    \"pre\": [\n        {\n            \"text\": \"并查集\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/547.friend-circles.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/547.friend-circles.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass UF:\\n    parent = {}\\n    cnt = 0\\n    def __init__(self, M):\\n        n = len(M)\\n        for i in range(n):\\n            self.parent[i] = i\\n            self.cnt += 1\\n\\n    def find(self, x):\\n        while x != self.parent[x]:\\n            x = self.parent[x]\\n        return x\\n    def union(self, p, q):\\n        if self.connected(p, q): return\\n        self.parent[self.find(p)] = self.find(q)\\n        self.cnt -= 1\\n    def connected(self, p, q):\\n        return self.find(p) == self.find(q)\\n\\nclass Solution:\\n    def findCircleNum(self, M: List[List[int]]) -> int:\\n        n = len(M)\\n        uf = UF(M)\\n        for i in range(n):\\n            for j in range(i):\\n                if M[i][j] == 1:\\n                    uf.union(i, j)\\n        return uf.cnt\\n\\n\"\n        }\n    ]\n},\n\"subarray-sum-equals-k\":{\n    \"id\": \"560\",\n    \"name\": \"subarray-sum-equals-k\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"前缀和\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"前缀和\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"可以利用hashmap记录和的累加值来避免重复计算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/560.subarray-sum-equals-k.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/560.subarray-sum-equals-k.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=560 lang=javascript\\n *\\n * [560] Subarray Sum Equals K\\n */\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar subarraySum = function (nums, k) {\\n  const hashmap = {};\\n  let acc = 0;\\n  let count = 0;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    acc += nums[i];\\n\\n    if (acc === k) count++;\\n\\n    if (hashmap[acc - k] !== void 0) {\\n      count += hashmap[acc - k];\\n    }\\n\\n    if (hashmap[acc] === void 0) {\\n      hashmap[acc] = 1;\\n    } else {\\n      hashmap[acc] += 1;\\n    }\\n  }\\n\\n  return count;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        cnt, n =  0, len(nums)\\n        for i in range(n):\\n            sum = 0\\n            for j in range(i, n):\\n                sum += nums[j]\\n                if (sum == k): cnt += 1\\n        return cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n      cnt, n =  0, len(nums)\\n      pre = [0] * (n + 1)\\n      for i in range(1, n + 1):\\n          pre[i] = pre[i - 1] + nums[i - 1]\\n      for i in range(1, n + 1):\\n          for j in range(i, n + 1):\\n              if (pre[j] - pre[i - 1] == k): cnt += 1\\n      return cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def subarraySum(self, nums: List[int], k: int) -> int:\\n        d = {}\\n        acc = count = 0\\n        for num in nums:\\n            acc += num\\n            if acc == k:\\n                count += 1\\n            if acc - k in d:\\n                count += d[acc-k]\\n            if acc in d:\\n                d[acc] += 1\\n            else:\\n                d[acc] = 1\\n        return count\\n\"\n        }\n    ]\n},\n\"distribute-candies\":{\n    \"id\": \"575\",\n    \"name\": \"distribute-candies\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"这是一道逻辑题目，因此如果逻辑分析清楚了，代码是自然而然的\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/575.distribute-candies.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/575.distribute-candies.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/*\\n * @lc app=leetcode id=575 lang=javascript\\n *\\n * [575] Distribute Candies\\n */\\n/**\\n * @param {number[]} candies\\n * @return {number}\\n */\\nvar distributeCandies = function (candies) {\\n  const count = new Set(candies);\\n  return Math.min(count.size, candies.length >> 1);\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def distributeCandies(self, candies: List[int]) -> int:\\n        return min(len(set(candies)), len(candies) >> 1)\\n\"\n        }\n    ]\n},\n\"find-duplicate-file-in-system\":{\n    \"id\": \"609\",\n    \"name\": \"find-duplicate-file-in-system\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"hashtable\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/609.find-duplicate-file-in-system.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/609.find-duplicate-file-in-system.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {string[]} paths\\n * @return {string[][]}\\n */\\nvar findDuplicate = function(paths) {\\n  const hashmap = {};\\n\\n  for (let path of paths) {\\n    const [folder, ...files] = path.split(\\\" \\\");\\n    for (let file of files) {\\n      const lpi = file.indexOf(\\\"(\\\");\\n      const rpi = file.lastIndexOf(\\\")\\\");\\n      const filename = file.slice(0, lpi);\\n      const content = file.slice(lpi, rpi);\\n      const fullname = `${folder}/${filename}`;\\n      if (!hashmap[content]) hashmap[content] = [];\\n      hashmap[content].push(fullname);\\n    }\\n  }\\n\\n  return Object.values(hashmap).filter(q => q.length >= 2);\\n};\\n\"\n        }\n    ]\n},\n\"valid-triangle-number\":{\n    \"id\": \"611\",\n    \"name\": \"valid-triangle-number\",\n    \"pre\": [\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"三角形边的关系\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"三角形边的关系\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"三层循环确定三个线段\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/611.valid-triangle-number.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/611.valid-triangle-number.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def is_triangle(self, a, b, c):\\n        if a == 0 or b == 0 or c == 0: return False\\n        if a + b > c and a + c > b and b + c > a: return True\\n        return False\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 0\\n        for i in range(n - 2):\\n            for j in range(i + 1, n - 1):\\n                for k in range(j + 1, n):\\n                    if self.is_triangle(nums[i], nums[j], nums[k]): ans += 1\\n\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n    def is_triangle(self, a, b, c):\\n        if a == 0 or b == 0 or c == 0: return False\\n        # a + c > b 和  b + c > a 是无效的判断，因为恒成立\\n        if a + b > c and a + c > b and b + c > a: return True\\n        return False\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in range(n - 2):\\n    for j in range(i + 1, n - 1):\\n        k = j + 1\\n        while k < n and num[i] + nums[j] > nums[k]:\\n            k += 1\\n        ans += k - j - 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in range(n - 2):\\n    k = i + 2\\n    for j in range(i + 1, n - 1):\\n        while k < n and nums[i] + nums[j] > nums[k]:\\n            k += 1\\n        ans += k - j - 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def triangleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 0\\n        nums.sort()\\n        for i in range(n - 2):\\n            if nums[i] == 0: continue\\n            k = i + 2\\n            for j in range(i + 1, n - 1):\\n                while k < n and nums[i] + nums[j] > nums[k]:\\n                    k += 1\\n                ans += k - j - 1\\n        return ans\\n\"\n        }\n    ]\n},\n\"non-decreasing-array\":{\n    \"id\": \"665\",\n    \"name\": \"non-decreasing-array\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"贪心\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"考虑各种边界情况，贪心改变数组的值\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/665.non-decreasing-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/665.non-decreasing-array.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def checkPossibility(self, A: List[int]) -> bool:\\n        ans = 0\\n        for i in range(1, len(A)):\\n            if A[i] < A[i - 1]:\\n                if ans == 1: return False\\n                ans += 1\\n        return True\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution(object):\\n    def checkPossibility(self, A):\\n        N = len(A)\\n        count = 0\\n        for i in range(1, N):\\n            if A[i] < A[i - 1]:\\n                count += 1\\n                if count > 1:\\n                    return False\\n                # [4,2,3]  [4,2,1]   [1,2,1,2]  [1,1,1,] []\\n                if i >= 2 and A[i] < A[i - 2]:\\n                    A[i] = A[i - 1]\\n\\n        return True\\n\\n\"\n        }\n    ]\n},\n\"number-of-longest-increasing-subsequence\":{\n    \"id\": \"673\",\n    \"name\": \"number-of-longest-increasing-subsequence\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"[最长上升子序列问题](https://lucifer.ren/blog/2020/06/20/LIS/)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"dp[j][1]=dp[i][1]容易忘记\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/673.number-of-longest-increasing-subsequence.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/673.number-of-longest-increasing-subsequence.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in range(n):\\n    for j in range(i + 1, n):\\n        if nums[j] > nums[i]:\\n            # ...\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        # dp[i][0] ->  LIS\\n        # dp[i][1] -> NumberOfLIS\\n        dp = [[1, 1] for i in range(n)]\\n        ans = [1, 1]\\n        longest = 1\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if nums[j] > nums[i]:\\n                    if dp[i][0] + 1 > dp[j][0]:\\n                        dp[j][0] = dp[i][0] + 1\\n                        # 下面这行代码容易忘记，导致出错\\n                        dp[j][1] = dp[i][1]\\n                        longest = max(longest, dp[j][0])\\n                    elif dp[i][0] + 1 == dp[j][0]:\\n                        dp[j][1] += dp[i][1]\\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)\\n\\n\"\n        }\n    ]\n},\n\"24-game\":{\n    \"id\": \"679\",\n    \"name\": \"24-game\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/backtrack.md \\\"回溯\\\"\",\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"数字精度问题\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"使用递归将问题分解成规模更小的同样问题\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"精度控制，即如果误差不超过某一个较小的数字就认为二者是相等的\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/679.24-game.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/679.24-game.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def judgePoint24(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:\\n            return math.isclose(nums[0], 24)\\n        return any(self.judgePoint24([x] + rest) for a, b, *rest in permutations(nums) \\nfor x in [a+b, a-b, a*b, b and a/b])\\n\\n\"\n        }\n    ]\n},\n\"repeated-string-match\":{\n    \"id\": \"686\",\n    \"name\": \"repeated-string-match\",\n    \"pre\": [\n        {\n            \"text\": \"set\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"答案是有限的，搞清楚解空间是关键\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/686.repeated-string-match.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/686.repeated-string-match.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ncnt = 1\\nwhile True:\\n    if b in a * cnt:\\n        return cnt\\n    cnt += 1\\nreturn -1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def repeatedStringMatch(self, a: str, b: str) -> int:\\n        if not set(b).issubset(set(a)):\\n            return -1\\n        cnt = 1\\n        while len(a * cnt) < 2 * len(a) + len(b):\\n            if b in a * cnt:\\n                return cnt\\n            cnt += 1\\n        return -1\\n\"\n        }\n    ]\n},\n\"best-time-to-buy-and-sell-stock-with-transaction-fee\":{\n    \"id\": \"714\",\n    \"name\": \"best-time-to-buy-and-sell-stock-with-transaction-fee\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"记忆化递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/714.best-time-to-buy-and-sell-stock-with-transaction-fee.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/714.best-time-to-buy-and-sell-stock-with-transaction-fee.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        def dp(i):\\n            if i == 0:\\n                return 0, -prices[0] - fee\\n            sell, buy = dp(i - 1)\\n            return max(sell, buy + prices[i]), max(buy, sell - prices[i] - fee)\\n\\n        return dp(len(prices) - 1)[0]\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        dp = [[0 for i in range(2)]] * n\\n        for i in range(n):\\n            if i == 0:\\n                dp[i][0] = 0\\n                dp[i][1] = -1 * prices[i]\\n            else:\\n                dp[i][0] = max(dp[i - 1][1] + prices[i] - fee, dp[i - 1][0])\\n                dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])\\n\\n        return dp[-1][0]\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxProfit(self, prices: List[int], fee: int) -> int:\\n        n = len(prices)\\n        # [手里没股票, 手里有股票]\\n        dp = [0, 0]\\n        for i in range(n):\\n            if i == 0:\\n                dp[0] = 0\\n                dp[1] = -1 * prices[i] - fee\\n            else:\\n                dp[0] = max(dp[0], dp[1] + prices[i])\\n                dp[1] = max(dp[1], dp[0] - prices[i] - fee)\\n\\n        return dp[0]\\n\"\n        }\n    ]\n},\n\"range-module\":{\n    \"id\": \"715\",\n    \"name\": \"range-module\",\n    \"pre\": [\n        {\n            \"text\": \"区间查找问题\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"二分查找\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/91/binary-search.md \\\"二分查找\\\"\",\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二分查找的灵活使用（最左插入和最右插入）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"将区间一维化处理\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/715.range-module.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/715.range-module.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass RangeModule(object):\\n    def __init__(self):\\n        # [(1,2),(3,6),(8,12)]\\n        self.ranges = []\\n    def overlap(self, left, right):\\n        i, j = 0, len(self.ranges) - 1\\n        while i < len(self.ranges) and self.ranges[i][1] < left:\\n            i += 1\\n        while j >= 0 and self.ranges[j][0] > right:\\n            j -= 1\\n        return i, j\\n\\n    def addRange(self, left, right):\\n        i, j = self.overlap(left, right)\\n        if i <= j:\\n            left = min(left, self.ranges[i][0])\\n            right = max(right, self.ranges[j][1])\\n        self.ranges[i:j+1] = [(left, right)]\\n    def queryRange(self, left, right):\\n        i = bisect.bisect_right(self.ranges, (left, float('inf'))) - 1\\n        return self.ranges and self.ranges[i][0] <= left and right <= self.ranges[i][1]\\n\\n    def removeRange(self, left, right):\\n        i, j = self.overlap(left, right)\\n        merge = []\\n        for k in xrange(i, j+1):\\n            if self.ranges[k][0] < left:\\n                merge.append((self.ranges[k][0], left))\\n            if right < self.ranges[k][1]:\\n                merge.append((right, self.ranges[k][1]))\\n        self.ranges[i:j+1] = merge\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass RangeModule(object):\\n    def __init__(self):\\n        # [1,2,3,5,8,12]\\n        self.ranges = []\\n\\n    def overlap(self, left, right, is_odd):\\n        i = bisect_left(self.ranges, left)\\n        j = bisect_right(self.ranges, right)\\n        merge = []\\n        if i & 1 == int(is_odd):\\n            merge.append(left)\\n        if j & 1 == int(is_odd):\\n            merge.append(right)\\n        # 修改 ranges 的 [i:j-1] 部分\\n        self.ranges[i:j] = merge\\n\\n    def addRange(self, left, right):\\n        # [1,2,3,5,8,12]， 代入 left = 3, right = 5，此时需要保持不变， 就不难知道应该用 bisect_left 还是 bisect_right\\n        return self.overlap(left, right, False)\\n\\n    def removeRange(self, left, right):\\n        # [1,2,3,5,8,12]， 代入 left = 3, right = 5，此时需要为 [1,2,8,12]， 就不难知道应该用 bisect_left 还是 bisect_right\\n        return self.overlap(left, right, True)\\n\\n    def queryRange(self, left, right):\\n        # [1,2,3,5,8,12]， 代入 left = 3, right = 5，此时需要返回 true， 就不难知道应该用 bisect_left 还是 bisect_right\\n        i = bisect_right(self.ranges, left)\\n        j = bisect_left(self.ranges, right)\\n        return i & 1 == 1 and i == j  # 都在一个区间内\\n\\n\"\n        }\n    ]\n},\n\"maximum-length-of-repeated-subarray\":{\n    \"id\": \"718\",\n    \"name\": \"maximum-length-of-repeated-subarray\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"二分查找\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"dp建模套路\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/718.maximum-length-of-repeated-subarray.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/718.maximum-length-of-repeated-subarray.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findLength(self, A, B):\\n        m, n = len(A), len(B)\\n        ans = 0\\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if A[i - 1] == B[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1] + 1\\n                    ans = max(ans, dp[i][j])\\n        return ans\\n\"\n        }\n    ]\n},\n\"accounts-merge\":{\n    \"id\": \"721\",\n    \"name\": \"accounts-merge\",\n    \"pre\": [\n        {\n            \"text\": \"并查集\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/721.accounts-merge.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/721.accounts-merge.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass UF:\\n    def __init__(self):\\n        self.parent = {}\\n\\n    def find(self, x):\\n        self.parent.setdefault(x, x)\\n        while x != self.parent[x]:\\n            x = self.parent[x]\\n        return x\\n    def union(self, p, q):\\n        self.parent[self.find(p)] = self.find(q)\\n\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        uf = UF()\\n        email_to_name = {}\\n        res = collections.defaultdict(list)\\n        for account in accounts:\\n            for i in range(1, len(account)):\\n                email_to_name[account[i]] = account[0]\\n                if i < len(account) - 1:uf.union(account[i], account[i + 1])\\n        for email in email_to_name:\\n            res[uf.find(email)].append(email)\\n\\n        return [[email_to_name[value[0]]] + sorted(value) for value in res.values()]\\n\"\n        }\n    ]\n},\n\"reach-a-number\":{\n    \"id\": \"754\",\n    \"name\": \"reach-a-number\",\n    \"pre\": [\n        {\n            \"text\": \"数学\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"对元素进行分组，分组的依据是符号，是`+`或者`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"通过数学公式推导可以简化我们的求解过程，这需要一点`数学知识和数学意识`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/754.reach-a-number.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/754.reach-a-number.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def reachNumber(self, target):\\n        target = abs(target)\\n        steps = 0\\n        while target > 0:\\n            steps += 1\\n            target -= steps\\n        if target & 1 == 0: return steps\\n        steps += 1\\n        if (target - steps) & 1 == 0: return steps\\n        return steps + 1\\n\\n\\n\"\n        }\n    ]\n},\n\"max-chunks-to-make-sorted-ii\":{\n    \"id\": \"768\",\n    \"name\": \"max-chunks-to-make-sorted-ii\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"队列\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"计数\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/768.max-chunks-to-make-sorted-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/768.max-chunks-to-make-sorted-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int maxChunksToSorted(int[] arr) {\\n        LinkedList<Integer> stack = new LinkedList<Integer>();\\n        for (int num : arr) {\\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\\n            if (!stack.isEmpty() && num < stack.getLast()) {\\n                // 我们需要将融合后的区块的最大值重新放回栈\\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\\n                int cur = stack.removeLast();\\n                // 维持栈的单调递增\\n                while (!stack.isEmpty() && num < stack.getLast()) {\\n                    stack.removeLast();\\n                }\\n                stack.addLast(cur);\\n            } else {\\n                stack.addLast(num);\\n            }\\n        }\\n        // 栈存的是块信息，因此栈的大小就是块的数量\\n        return stack.size();\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar maxChunksToSorted = function (arr) {\\n  const stack = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    a = arr[i];\\n    if (stack.length > 0 && stack[stack.length - 1] > a) {\\n      const cur = stack[stack.length - 1];\\n      while (stack && stack[stack.length - 1] > a) stack.pop();\\n      stack.push(cur);\\n    } else {\\n      stack.push(a);\\n    }\\n  }\\n  return stack.length;\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int maxChunksToSorted(vector<int>& arr) {\\n        stack<int> stack;\\n        for(int i =0;i<arr.size();i++){\\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\\n            if(!stack.empty()&&stack.top()>arr[i]){\\n                // 我们需要将融合后的区块的最大值重新放回栈\\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\\n                int cur = stack.top();\\n                // 维持栈的单调递增\\n                while(!stack.empty()&&stack.top()>arr[i]){\\n                    sstackta.pop();\\n                }\\n\\n                stack.push(cur);\\n            }else{\\n\\n                stack.push(arr[i]);\\n            }\\n        }\\n        // 栈存的是块信息，因此栈的大小就是块的数量\\n        return stack.size();\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def maxChunksToSorted(self, arr):\\n        count_a = collections.defaultdict(int)\\n        count_b = collections.defaultdict(int)\\n        ans = 0\\n\\n        for a, b in zip(arr, sorted(arr)):\\n            count_a[a] += 1\\n            count_b[b] += 1\\n            if count_a == count_b: ans += 1\\n\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    class Solution(object):\\n    def maxChunksToSorted(self, arr):\\n        count = collections.defaultdict(int)\\n        non_zero_cnt = 0\\n        ans = 0\\n\\n        for a, b in zip(arr, sorted(arr)):\\n            if count[a] == -1: non_zero_cnt -= 1\\n            if count[a] == 0: non_zero_cnt += 1\\n            count[a] += 1\\n            if count[b] == 1: non_zero_cnt -= 1\\n            if count[b] == 0: non_zero_cnt += 1\\n            count[b] -= 1\\n            if non_zero_cnt == 0: ans += 1\\n\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxChunksToSorted(self, A: [int]) -> int:\\n        stack = []\\n        for a in A:\\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\\n            if stack and stack[-1] > a:\\n                # 我们需要将融合后的区块的最大值重新放回栈\\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\\n                cur = stack[-1]\\n                # 维持栈的单调递增\\n                while stack and stack[-1] > a: stack.pop()\\n                stack.append(cur)\\n            else:\\n                stack.append(a)\\n        # 栈存的是块信息，因此栈的大小就是块的数量\\n        return len(stack)\\n\\n\\n\"\n        }\n    ]\n},\n\"is-graph-bipartite\":{\n    \"id\": \"785\",\n    \"name\": \"is-graph-bipartite\",\n    \"pre\": [\n        {\n            \"text\": \"图的遍历\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"图的建立和遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"colors数组\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/785.is-graph-bipartite.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/785.is-graph-bipartite.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def dfs(self, grid, colors, i, color, N):\\n        colors[i] = color\\n        for j in range(N):\\n            if grid[i][j] == 1:\\n                if colors[j] == color:\\n                    return False\\n                if colors[j] == 0 and not self.dfs(grid, colors, j, -1 * color, N):\\n                    return False\\n        return True\\n\\n    def isBipartite(self, graph: List[List[int]]) -> bool:\\n        N = len(graph)\\n        grid = [[0] * N for _ in range(N)]\\n        colors = [0] * N\\n        for i in range(N):\\n            for j in graph[i]:\\n                grid[i][j] = 1\\n        for i in range(N):\\n            if colors[i] == 0 and not self.dfs(grid, colors, i, 1, N):\\n                return False\\n        return True\\n\"\n        }\n    ]\n},\n\"domino-and-tromino-tiling\":{\n    \"id\": \"790\",\n    \"name\": \"domino-and-tromino-tiling\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"识别最优子结构\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"对一块瓷砖能拼成的图形进行分解，并对每一种情况进行讨论\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/790.domino-and-tromino-tiling.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/790.domino-and-tromino-tiling.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def numTilings(self, N: int) -> int:\\n        dp = [0] * (N + 3)\\n        # f(3) = 2 * f(2) + f(0) = 2 + f(0) = 1 -> f(0) = -1\\n        # f(4) = 2 * f(3) + f(1) = 2 + f(1) = 2 -> f(1) = 0\\n        dp[0] = -1\\n        dp[1] = 0\\n        dp[2] = 1\\n        # f(n) = f(n-1) + f(n-2) + 2 * T(n-1)\\n        # 2 * T(n-1) = 2 * f(n-3) + 2 * T(n-2)\\n        # f(n) = f(n-1) + 2 * f(n-3) + f(n-2) + 2T(n-2) = f(n-1) + f(n-3) + f(n-3) + f(n-2) + 2T(n-2) = f(n-1) + f(n-3) + f(n-1) = 2 * f(n-1) + f(n-3)\\n        for i in range(3, N + 3):\\n            dp[i] = 2 * dp[i-1] + dp[i-3]\\n        return dp[-1] % (10 ** 9 + 7)\\n\\n\"\n        }\n    ]\n},\n\"champagne-tower\":{\n    \"id\": \"799\",\n    \"name\": \"champagne-tower\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"杨辉三角\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"不必模拟多步，而是只模拟一次即可\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/799.champagne-tower.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/799.champagne-tower.md\",\n    \"code\": []\n},\n\"minimum-swaps-to-make-sequences-increasing\":{\n    \"id\": \"801\",\n    \"name\": \"minimum-swaps-to-make-sequences-increasing\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"一：无需考虑全部整体，而只需要考虑相邻两个数字即可这其实也是可以使用动态规划解决问题的关键条件。对于这道题来说，**最小**的子问题就是当前项和前一项组成的局部，**无法**再小了，**没有必要**再大了。为什么只关心两个数字即可？因为要使得整个数组递增，**假设**前面的i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"2项已经满足递增了，那么现在**采取某种方式**使得满足A[i]>A[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1]即可(B也是同理)。>因为A[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1]>A[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"2]已经成立，因此如果A[i]>A[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1]，那么整体就递增了。这提示我们可以使用动态规划来完成。如果上面的这些没有听懂，则很有可能对动态规划不熟悉，建议先看下基础知识。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/801.minimum-swaps-to-make-sequences-increasing.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/801.minimum-swaps-to-make-sequences-increasing.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def minSwap(self, A: List[int], B: List[int]) -> int:\\n        n = len(A)\\n        swap = [n] * n\\n        no_swap = [n] * n\\n        swap[0] = 1\\n        no_swap[0] = 0\\n\\n        for i in range(1, len(A)):\\n            q1 = A[i-1] < A[i] and B[i-1] < B[i]\\n            q2 = A[i-1] < B[i] and B[i-1] < A[i]\\n            if q1 and q2:\\n                no_swap[i] = min(swap[i-1], no_swap[i-1]) # 都不换或者换i-1\\n                swap[i] = min(swap[i-1], no_swap[i-1]) + 1 # 都换 或者 换 i\\n            if q1 and not q2:\\n                swap[i] = swap[i-1] + 1 # 都换\\n                no_swap[i] = no_swap[i-1] # 都不换\\n            if not q1 and q2:\\n                swap[i] = no_swap[i-1] + 1 # 换 i\\n                no_swap[i] = swap[i-1] # 换 i - 1\\n\\n        return min(swap[n-1], no_swap[n-1])\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nif q1:\\n    no_swap[i] = no_swap[i-1] # 都不换\\n    swap[i] = swap[i-1] + 1 # 都换\\nif q2:\\n    swap[i] = min(swap[i], no_swap[i-1] + 1) # 换 i\\n    no_swap[i] =  min(no_swap[i], swap[i-1]) # 换 i - 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minSwap(self, A: List[int], B: List[int]) -> int:\\n        n = len(A)\\n        swap = [n] * n\\n        no_swap = [n] * n\\n        swap[0] = 1\\n        no_swap[0] = 0\\n\\n        for i in range(1, len(A)):\\n            # 如果交换之前有序，则可以不交换\\n            if A[i-1] < A[i] and B[i-1] < B[i]:\\n                no_swap[i] = no_swap[i-1]\\n                swap[i] = swap[i-1] + 1\\n            # 否则至少需要交换一次（交换当前项或者前一项）\\n            if A[i-1] < B[i] and B[i-1] < A[i]:\\n                swap[i] = min(swap[i], no_swap[i-1] + 1) # i 换\\n                no_swap[i] =  min(no_swap[i], swap[i-1]) # i - 1 换\\n\\n        return min(swap[n-1], no_swap[n-1])\\n\"\n        }\n    ]\n},\n\"split-array-with-same-average\":{\n    \"id\": \"805\",\n    \"name\": \"split-array-with-same-average\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/backtrack.md\",\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯解题模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"两个剪枝\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/805.split-array-with-same-average.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/805.split-array-with-same-average.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef splitArraySameAverage(self, A: List[int]) -> bool:\\n        n = len(A)\\n        avg = sum(A) / n\\n\\n        for i in range(1, n // 2 + 1):\\n            for combination in combinations(A, i):\\n                if abs(sum(combination) - avg * i) < 1e-6:\\n                    return True\\n        return False\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef splitArraySameAverage(self, A: List[int]) -> bool:\\n        n = len(A)\\n        avg = sum(A) / n\\n\\n        for i in range(1, n // 2 + 1):\\n            for s in combinationSum(A, i):\\n                if abs(s - avg * i) < 1e-6:\\n                    return True\\n        return False\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], count: int) -> List[List[int]]:\\n        size = len(candidates)\\n        if size == 0:\\n            return []\\n \\n        # 还是先排序，主要是方便去重\\n        candidates.sort()\\n \\n        ans = []\\n        self._find_path(candidates, ans, 0, count, 0, size)\\n        return ans\\n \\n    def _find_path(self, candidates, ans, path_sum, count, begin, size):\\n        if count == 0:\\n            ans.append(path_sum)\\n            return\\n        else:\\n            for i in range(begin, size):\\n                # 剪枝一。 注意这里的 i > begin 这个条件\\n                if i > begin and candidates[i] == candidates[i - 1]:\\n                    continue\\n                self._find_path(candidates, ans, path_sum + candidates[i], count - 1, i + 1, size)\\n \\n    def splitArraySameAverage(self, A: List[int]) -> bool:\\n        n = len(A)\\n        avg = sum(A) / n\\n \\n        for i in range(1, n // 2 + 1):\\n            # 剪枝二\\n            if abs(i * avg - int(i * avg)) > 1e-6:\\n                continue\\n            for s in self.combinationSum(A, i):\\n                if abs(s - avg * i) < 1e-6:\\n                    return True\\n        return False\\n\\n\"\n        }\n    ]\n},\n\"ambiguous-coordinates\":{\n    \"id\": \"816\",\n    \"name\": \"ambiguous-coordinates\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"笛卡尔积\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"笛卡尔积优化\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/816.ambiguous-coordinates.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/816.ambiguous-coordinates.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n\\n    def subset(self, s: str):\\n        ans = []\\n        for i in range(1, len(s)):\\n            ans.append(s[:i] + \\\".\\\" + s[i:])\\n        ans.append(s)\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        ans = []\\n        s = s[1:-1]\\n        for i in range(1, len(s)):\\n            x = self.subset(s[:i])\\n            y = self.subset(s[i:])\\n            for i in x:\\n                for j in y:\\n                    ans.append('(' + i + ', ' + j + ')')\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    # \\\"123\\\" => [\\\"1.23\\\", \\\"12.3\\\", \\\"123\\\"]\\n    def subset(self, s: str):\\n        ans = []\\n\\n        #  带小数点的\\n        for i in range(1, len(s)):\\n            # 不允许 00.111， 0.0，01.1，1.0\\n            if s[0] == '0' and i > 1:\\n                continue\\n            if s[-1] == '0':\\n                continue\\n            ans.append(s[:i] + \\\".\\\" + s[i:])\\n        # 不带小数点的（不允许 001）\\n        if s == '0' or not s.startswith('0'):\\n            ans.append(s)\\n        return ans\\n\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        ans = []\\n        s = s[1:-1]\\n        for i in range(1, len(s)):\\n            x = self.subset(s[:i])\\n            y = self.subset(s[i:])\\n            for i in x:\\n                for j in y:\\n                    ans.append('(' + i + ', ' + j + ')')\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"short-encoding-of-words\":{\n    \"id\": \"820\",\n    \"name\": \"short-encoding-of-words\",\n    \"pre\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"去重\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/820.short-encoding-of-words.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/820.short-encoding-of-words.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Trie:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.Trie = {}\\n\\n    def insert(self, word):\\n        \\\"\\\"\\\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: void\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for w in word:\\n            if w not in curr:\\n                curr[w] = {}\\n            curr = curr[w]\\n        curr['#'] = 1\\n\\n    def search(self, word):\\n        \\\"\\\"\\\"\\n        Returns if the word is in the trie.\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for w in word:\\n            curr = curr[w]\\n        # len(curr) == 1 means we meet '#'\\n        # when we search 'em'(which reversed from 'me')\\n        # the result is len(curr) > 1\\n        # cause the curr look like { '#': 1, i: {...}}\\n        return len(curr) == 1\\nclass Solution:\\n    def minimumLengthEncoding(self, words: List[str]) -> int:\\n        trie = Trie()\\n        cnt = 0\\n        words = set(words)\\n        for word in words:\\n            trie.insert(word[::-1])\\n        for word in words:\\n            if trie.search(word[::-1]):\\n                cnt += len(word) + 1\\n        return cnt\\n\\n\"\n        }\n    ]\n},\n\"shortest-distance-to-a-character\":{\n    \"id\": \"821\",\n    \"name\": \"shortest-distance-to-a-character\",\n    \"pre\": [\n        {\n            \"text\": \"数组的遍历(正向遍历和反向遍历)\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/821.shortest-distance-to-a-character.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/821.shortest-distance-to-a-character.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int[] shortestToChar(String S, char C) {\\n        int N = S.length();\\n        int[] ans = new int[N];\\n        int prev = -10000;\\n\\n        for (int i = 0; i < N; ++i) {\\n            if (S.charAt(i) == C) prev = i;\\n            ans[i] = i - prev;\\n        }\\n\\n        prev = 20000;\\n        for (int i = N-1; i >= 0; --i) {\\n            if (S.charAt(i) == C) prev = i;\\n            ans[i] = Math.min(ans[i], prev - i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n   vector<int> shortestToChar(string S, char C) {\\n       vector<int> ans(S.size(), 0);\\n       int prev = -10000;\\n       for(int i = 0; i < S.size(); i ++){\\n           if(S[i] == C) prev = i;\\n           ans[i] = i - prev;\\n       }\\n       prev = 20000;\\n       for(int i = S.size() - 1; i >= 0; i --){\\n           if(S[i] == C) prev = i;\\n           ans[i] = min(ans[i], prev - i);\\n       }\\n       return ans;\\n   }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = []\\n\\n        for i in range(len(S)):\\n            # 从 i 向左向右扩展\\n            l = r = i\\n            # 向左找到第一个 C\\n            while l > -1:\\n                if S[l] == C: break\\n                l -= 1\\n            # 向左找到第一个 C\\n            while r < len(S):\\n                if S[r] == C: break\\n                r += 1\\n            # 如果至死没有找到，则赋值一个无限大的数字，由于题目的数据范围是 [1, 10000]，因此 -10000 或者  10000就够了。\\n            if l == -1: l = -10000\\n            if r == len(S): r = 10000\\n            # 选较近的即可\\n            ans.append(min(r - i, i - l))\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        ans = [10000] * len(S)\\n        stack = []\\n        for i in range(len(S)):\\n            while stack and S[i] == C:\\n                ans[stack.pop()] = i - stack[-1]\\n            if S[i] != C:stack.append(i)\\n            else: ans[i] = 0\\n        for i in range(len(S) - 1, -1, -1):\\n            while stack and S[i] == C:\\n                ans[stack.pop()] = min(ans[stack[-1]], stack[-1] - i)\\n            if S[i] != C:stack.append(i)\\n            else: ans[i] = 0\\n\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def shortestToChar(self, S: str, C: str) -> List[int]:\\n        pre = -10000\\n        ans = []\\n\\n        for i in range(len(S)):\\n            if S[i] == C: pre = i\\n            ans.append(i - pre)\\n        pre = 20000\\n        for i in range(len(S) - 1, -1, -1):\\n            if S[i] == C: pre = i\\n            ans[i] = min(ans[i], pre - i)\\n        return ans\\n\"\n        }\n    ]\n},\n\"similar-string-groups\":{\n    \"id\": \"839\",\n    \"name\": \"similar-string-groups\",\n    \"pre\": [\n        {\n            \"text\": \"并查集\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md\",\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"判断两个字符串是否相似的函数is_similar没有必须真实交换并判断，而是判断不相等字符是否等于2\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/839.similar-string-groups.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/839.similar-string-groups.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nuf = UF(n)\\nfor i in range(n):\\n      for j in range(i + 1, n):\\n           if strs[i] == strs[j] or is_similar(list(strs[i]), list(strs[j])):\\n              uf.union(i, j)\\nreturn uf.cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef is_similar(A, B):\\n    n = len(A)\\n    for i in range(n):\\n        for j in range(i + 1, n):\\n            A[i], A[j] = A[j], A[i]\\n            if A == B: return True\\n            A[i], A[j] = A[j], A[i]\\n    return False\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n\\nclass UF:\\n  def __init__(self, M):\\n      self.parent = {}\\n      self.cnt = 0\\n      # 初始化 parent，size 和 cnt\\n      for i in range(M):\\n          self.parent[i] = i\\n          self.cnt += 1\\n\\n  def find(self, x):\\n      if x != self.parent[x]:\\n          self.parent[x] = self.find(self.parent[x])\\n          return self.parent[x]\\n      return x\\n  def union(self, p, q):\\n      if self.connected(p, q): return\\n      leader_p = self.find(p)\\n      leader_q = self.find(q)\\n      self.parent[leader_p] = leader_q\\n      self.cnt -= 1\\n  def connected(self, p, q):\\n      return self.find(p) == self.find(q)\\n\\nclass Solution:\\n    def numSimilarGroups(self, strs: List[str]) -> int:\\n        n = len(strs)\\n        uf = UF(n)\\n        def is_similar(A, B):\\n            n = len(A)\\n            diff = 0\\n            for i in range(n):\\n                if A[i] != B[i]: diff += 1\\n            return diff == 2\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if strs[i] == strs[j] or is_similar(list(strs[i]), list(strs[j])):\\n                    uf.union(i, j)\\n        return uf.cnt\\n\\n\"\n        }\n    ]\n},\n\"walking-robot-simulation\":{\n    \"id\": \"874\",\n    \"name\": \"walking-robot-simulation\",\n    \"pre\": [\n        {\n            \"text\": \"hashtable\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"理解题意，这道题容易理解错题意，求解为`最终位置距离原点的距离`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"建立坐标系\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/874.walking-robot-simulation.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/874.walking-robot-simulation.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def robotSim(self, commands: List[int], obstacles: List[List[int]]) -> int:\\n        pos = [0, 0]\\n        deg = 90\\n        ans = 0\\n        obstaclesSet = set(map(tuple, obstacles))\\n\\n        for command in commands:\\n            if command == -1:\\n                deg = (deg + 270) % 360\\n            elif command == -2:\\n                deg = (deg + 90) % 360\\n            else:\\n                if deg == 0:\\n                    i = 0\\n                    while i < command and not (pos[0] + 1, pos[1]) in obstaclesSet:\\n                        pos[0] += 1\\n                        i += 1\\n                if deg == 90:\\n                    i = 0\\n                    while i < command and not (pos[0], pos[1] + 1) in obstaclesSet:\\n                        pos[1] += 1\\n                        i += 1\\n                if deg == 180:\\n                    i = 0\\n                    while i < command and not (pos[0] - 1, pos[1]) in obstaclesSet:\\n                        pos[0] -= 1\\n                        i += 1\\n                if deg == 270:\\n                    i = 0\\n                    while i < command and not (pos[0], pos[1] - 1) in obstaclesSet:\\n                        pos[1] -= 1\\n                        i += 1\\n                ans = max(ans, pos[0] ** 2 + pos[1] ** 2)\\n        return ans\\n\"\n        }\n    ]\n},\n\"koko-eating-bananas\":{\n    \"id\": \"875\",\n    \"name\": \"koko-eating-bananas\",\n    \"pre\": [\n        {\n            \"text\": \"二分查找\",\n            \"link\": \"../91/binary-search.md\",\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二分查找模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/875.koko-eating-bananas.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/875.koko-eating-bananas.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic int binarySearch(int[] nums, int target) {\\n    // 左右都闭合的区间 [l, r]\\n    int left = 0;\\n    int right = nums.length - 1;\\n\\n    while(left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if(nums[mid] == target)\\n            return mid;\\n        else if (nums[mid] < target)\\n\\t\\t\\t// 搜索区间变为 [mid+1, right]\\n            left = mid + 1;\\n        else if (nums[mid] > target)\\n            // 搜索区间变为 [left, mid - 1]\\n            right = mid - 1;\\n    }\\n    return -1;\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic int binarySearchLeft(int[] nums, int target) {\\n\\t// 搜索区间为 [left, right]\\n    int left = 0;\\n    int right = nums.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (nums[mid] < target) {\\n            // 搜索区间变为 [mid+1, right]\\n            left = mid + 1;\\n        } else if (nums[mid] > target) {\\n            // 搜索区间变为 [left, mid-1]\\n            right = mid - 1;\\n        } else if (nums[mid] == target) {\\n            // 收缩右边界\\n            right = mid - 1;\\n        }\\n    }\\n    // 检查是否越界\\n    if (left >= nums.length || nums[left] != target)\\n        return -1;\\n    return left;\\n}\\n\"\n        },\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic int binarySearchRight(int[] nums, int target) {\\n\\t// 搜索区间为 [left, right]\\n    int left = 0\\n    int right = nums.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (nums[mid] < target) {\\n\\t\\t\\t// 搜索区间变为 [mid+1, right]\\n            left = mid + 1;\\n        } else if (nums[mid] > target) {\\n\\t\\t\\t// 搜索区间变为 [left, mid-1]\\n            right = mid - 1;\\n        } else if (nums[mid] == target) {\\n            // 收缩左边界\\n            left = mid + 1;\\n        }\\n    }\\n    // 检查是否越界\\n    if (right < 0 || nums[right] != target)\\n        return -1;\\n    return right;\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction canEatAllBananas(piles, H, mid) {\\n  let h = 0;\\n  for (let pile of piles) {\\n    h += Math.ceil(pile / mid);\\n  }\\n\\n  return h <= H;\\n}\\n/**\\n * @param {number[]} piles\\n * @param {number} H\\n * @return {number}\\n */\\nvar minEatingSpeed = function (piles, H) {\\n  let lo = 1,\\n    hi = Math.max(...piles);\\n  // [l, r) ， 左闭右开的好处是如果能找到，那么返回 l 和 r 都是一样的，因为最终 l 等于 r。\\n  while (lo <= hi) {\\n    let mid = lo + ((hi - lo) >> 1);\\n    if (canEatAllBananas(piles, H, mid)) {\\n      hi = mid - 1;\\n    } else {\\n      lo = mid + 1;\\n    }\\n  }\\n\\n  return lo; //  不能选择hi\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, piles, k):\\n        def possible(mid):\\n            t = 0\\n            for pile in piles:\\n                t += (pile + mid - 1) // mid\\n            return t <= k\\n\\n        l, r = 1, max(piles)\\n\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if possible(mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n\\n\"\n        }\n    ]\n},\n\"stone-game\":{\n    \"id\": \"877\",\n    \"name\": \"stone-game\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"可以用DP（动态规划）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"可以从数学的角度去分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/877.stone-game.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/877.stone-game.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} piles\\n * @return {boolean}\\n */\\nvar stoneGame = function(piles) {\\n  return true;\\n};\\n\"\n        }\n    ]\n},\n\"possible-bipartition\":{\n    \"id\": \"886\",\n    \"name\": \"possible-bipartition\",\n    \"pre\": [\n        {\n            \"text\": \"图的遍历\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"二分图\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"染色法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"图的建立和遍历\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"colors数组\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/886.possible-bipartition.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/886.possible-bipartition.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n        graph = [[0] * N for i in range(N)]\\n        for a, b in dislikes:\\n            graph[a - 1][b - 1] = 1\\n            graph[b - 1][a - 1] = 1\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# 其中j 表示当前是第几个人，N表示总人数。 dfs的功能就是根据colors和graph分配组，true表示可以分，false表示不可以，具体代码见代码区。\\nif colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def dfs(self, graph, colors, i, color, N):\\n        colors[i] = color\\n        for j in range(N):\\n            # dislike eachother\\n            if graph[i][j] == 1:\\n                if colors[j] == color:\\n                    return False\\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\\n                    return False\\n        return True\\n\\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\\n        graph = [[0] * N for i in range(N)]\\n        colors = [0] * N\\n        for a, b in dislikes:\\n            graph[a - 1][b - 1] = 1\\n            graph[b - 1][a - 1] = 1\\n        for i in range(N):\\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\\n                return False\\n        return True\\n\\n\"\n        }\n    ]\n},\n\"super-egg-drop\":{\n    \"id\": \"887\",\n    \"name\": \"super-egg-drop\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md \\\"动态规划\\\"\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/887.super-egg-drop.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/887.super-egg-drop.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nvar superEggDrop = function (K, N) {\\n  // 不选择dp[K][M]的原因是dp[M][K]可以简化操作\\n  const dp = Array(N + 1)\\n    .fill(0)\\n    .map((_) => Array(K + 1).fill(0));\\n\\n  let m = 0;\\n  while (dp[m][K] < N) {\\n    m++;\\n    for (let k = 1; k <= K; ++k) dp[m][k] = dp[m - 1][k - 1] + 1 + dp[m - 1][k];\\n  }\\n  return m;\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef superEggDrop(K, N):\\n    ans = N\\n    # 暴力枚举从第 i 层开始扔\\n    for i in range(1, N + 1):\\n        ans = min(ans, max(self.superEggDrop(K - 1, i - 1) + 1, self.superEggDrop(K,  N - i) + 1))\\n    return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def superEggDrop(self, K: int, N: int) -> int:\\n        if K == 1: return N\\n        if N == 0 or N == 1: return N\\n        ans = N\\n        # 暴力枚举从第 i 层开始扔\\n        for i in range(1, N + 1):\\n            ans = min(ans, max(self.superEggDrop(K - 1, i - 1) + 1, self.superEggDrop(K,  N - i) + 1))\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    @lru_cache()\\n    def superEggDrop(self, K: int, N: int) -> int:\\n        if K == 1: return N\\n        if N == 0 or N == 1: return N\\n        ans = N\\n        # 暴力枚举从第 i 层开始扔\\n        for i in range(1, N + 1):\\n            ans = min(ans, max(self.superEggDrop(K - 1, i - 1) + 1, self.superEggDrop(K,  N - i) + 1))\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def superEggDrop(self, K: int, N: int) -> int:\\n        for i in range(K + 1):\\n            for j in range(N + 1):\\n                if i == 1:\\n                    dp[i][j] = j\\n                if j == 1 or j == 0:\\n                    dp[i][j] == j\\n                dp[i][j] = j\\n                for k in range(1, j + 1):\\n                    dp[i][j] = min(dp[i][j], max(dp[i - 1][k - 1] + 1, dp[i][j - k] + 1))\\n        return dp[K][N]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def superEggDrop(self, K: int, N: int) -> int:\\n        dp = [[0] * (K + 1) for _ in range(N + 1)]\\n\\n        for i in range(N + 1):\\n            for j in range( K + 1):\\n                if j == 1:\\n                    dp[i][j] = i\\n                if i == 1 or i == 0:\\n                    dp[i][j] == i\\n                dp[i][j] = i\\n                for k in range(1, i + 1):\\n                    dp[i][j] = min(dp[i][j], max(dp[k - 1][j - 1] + 1, dp[i - k][j] + 1))\\n        return dp[N][K]\\n        dp = [[0] * (N + 1) for _ in range(K + 1)]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def superEggDrop(self, K: int, N: int) -> int:\\n        def f(m, k):\\n            if k == 0 or m == 0: return 0\\n            return f(m - 1, k - 1) + 1 +  f(m - 1, k)\\n        m = 0\\n        while f(m, K) < N:\\n            m += 1\\n        return m\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def superEggDrop(self, K: int, N: int) -> int:\\n        dp = [[0] * (K + 1) for _ in range(N + 1)]\\n        m = 0\\n        while dp[m][K] < N:\\n            m += 1\\n            for i in range(1, K + 1):\\n                dp[m][i] = dp[m - 1][i - 1] + 1 + dp[m - 1][i]\\n        return m\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def superEggDrop(self, K: int, N: int) -> int:\\n        dp = [[0] * (K + 1) for _ in range(N + 1)]\\n        m = 0\\n        while dp[m][K] < N:\\n            m += 1\\n            for i in range(1, K + 1):\\n                dp[m][i] = dp[m - 1][i - 1] + 1 + dp[m - 1][i]\\n        return m\\n\"\n        }\n    ]\n},\n\"maximum-frequency-stack\":{\n    \"id\": \"895\",\n    \"name\": \"maximum-frequency-stack\",\n    \"pre\": [\n        {\n            \"text\": \"设计题\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"栈的基本性质\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"hashtable的基本性质\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"fraq_stack的设计。fraq_stack中当前频率的栈要保存所有大于等于其频率的数字\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"push和pop的时候同时更新fraq，max_fraq和fraq_stack。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/895.maximum-frequency-stack.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/895.maximum-frequency-stack.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass FreqStack:\\n\\n    def __init__(self):\\n        self.fraq = collections.defaultdict(lambda: 0)\\n        self.fraq_stack = collections.defaultdict(list)\\n        self.max_fraq = 0\\n\\n    def push(self, x: int) -> None:\\n        self.fraq[x] += 1\\n        if self.fraq[x] > self.max_fraq:\\n            self.max_fraq = self.fraq[x]\\n        self.fraq_stack[self.fraq[x]].append(x)\\n\\n    def pop(self) -> int:\\n        ans = self.fraq_stack[self.max_fraq].pop()\\n        self.fraq[ans] -= 1\\n        if not self.fraq_stack[self.max_fraq]:\\n            self.max_fraq -= 1\\n        return ans\\n\\n# Your FreqStack object will be instantiated and called as such:\\n# obj = FreqStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n\"\n        }\n    ]\n},\n\"bitwise-ors-of-subarrays\":{\n    \"id\": \"898\",\n    \"name\": \"bitwise-ors-of-subarrays\",\n    \"pre\": [\n        {\n            \"text\": \"【西法带你学算法】一次搞定前缀和\",\n            \"link\": \"https://lucifer.ren/blog/2020/09/27/atMostK/\",\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"子数组是连续的，有很多性质可以利用\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/898.bitwise-ors-of-subarrays.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/898.bitwise-ors-of-subarrays.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution(object):\\n    def subarrayBitwiseORs(self, A):\\n        pres = set([0])\\n        ans = set()\\n        for a in A:\\n            nxt = set()\\n            for pre in pres:\\n                nxt.add(a | pre)\\n                nxt.add(a)\\n            pres = nxt\\n            ans |= nxt\\n        return len(ans)\\n\\n\\n\"\n        }\n    ]\n},\n\"rle-iterator\":{\n    \"id\": \"900\",\n    \"name\": \"rle-iterator\",\n    \"pre\": [\n        {\n            \"text\": \"哈夫曼编码和游程编码\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/900.rle-iterator.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/900.rle-iterator.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} A\\n */\\nvar RLEIterator = function(A) {\\n    this.A = A;\\n    this.current = 0;\\n};\\n\\n\\n/** \\n * @param {number} n\\n * @return {number}\\n */\\nRLEIterator.prototype.next = function(n) {\\n    const A = this.A;\\n    while(this.current < A.length && A[this.current] < n){\\n        n = n - A[this.current];\\n        this.current += 2;\\n    }\\n    \\n    if(this.current >= A.length){\\n        return -1;\\n    }\\n    \\n    A[this.current] = A[this.current] - n; // 更新Count\\n    return A[this.current + 1]; // 返回element\\n};\\n\\n/** \\n * Your RLEIterator object will be instantiated and called as such:\\n * var obj = new RLEIterator(A)\\n * var param_1 = obj.next(n)\\n */\\n\"\n        }\n    ]\n},\n\"online-election\":{\n    \"id\": \"911\",\n    \"name\": \"online-election\",\n    \"pre\": [\n        {\n            \"text\": \"二分查找\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/91/binary-search.md \\\"二分查找\\\"\",\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"使用哈希表记录times中每一个时刻的优胜信息\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"最左插入模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/911.online-election.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/911.online-election.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        vote_count = collections.defaultdict(int) # 哈希表统计每个人的票数信息\\n        max_voted_person = -1\\n        max_voted_count = 0\\n        winner = []\\n        # zip([1,2,3], [4,5,6]) 会返回 [[1,4], [2,5], [3,6]]\\n        for p, t in zip(persons, times):\\n            vote_count[p] += 1\\n            if vote_count[p] >= max_voted_count:\\n                max_voted_count = vote_count[p]\\n                max_voted_person = p\\n            # 更新 winner\\n            winner.append(max_voted_person)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nq(int t) -> int\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ntimes =  [2,4,5,6]\\nwinner = [1,2,1,1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        vote_count = collections.defaultdict(int)\\n        max_voted_person = -1\\n        max_voted_count = 0\\n        winner = []\\n        for p, t in zip(persons, times):\\n            vote_count[p] += 1\\n            if vote_count[p] >= max_voted_count:\\n                max_voted_count = vote_count[p]\\n                max_voted_person = p\\n            winner.append(max_voted_person)\\n        self.winner = winner\\n        self.times = times\\n\\n    def q(self, t: int) -> int:\\n        winner = self.winner\\n        # times 是不重复的，也就是严格递增的，类似 [2,4,5,6]，这是关键\\n        # eg:\\n        # times  [2,4,5,6]\\n        # winner [1,2,1,1]\\n        i = bisect.bisect_left(self.times, t)\\n        if i != len(self.times) and self.times[i] == t:\\n            return winner[i]\\n        return winner[i - 1]\\n\"\n        }\n    ]\n},\n\"sort-an-array\":{\n    \"id\": \"912\",\n    \"name\": \"sort-an-array\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"排序算法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"注意题目的限制条件从而选择合适的算法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"百度\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/912.sort-an-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/912.sort-an-array.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    const counts = Array(50000 * 2 + 1).fill(0);\\n    const res = [];\\n    for(const num of nums) counts[50000 + num] += 1;\\n    for(let i in counts)  {\\n        while(counts[i]--) {\\n            res.push(i - 50000)\\n        }\\n    }\\n    return res;\\n};\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nfunction swap(nums, a, b) {\\n    const temp = nums[a];\\n    nums[a] = nums[b];\\n    nums[b] = temp;\\n}\\n\\nfunction helper(nums, start, end) {\\n    if (start >= end) return;\\n    const pivotIndex = start + ((end - start) >>> 1)\\n    const pivot = nums[pivotIndex]\\n    let i = start;\\n    let j = end;\\n    while (i <= j) {\\n        while (nums[i] < pivot) i++;\\n        while (nums[j] > pivot) j--;\\n        if (i <= j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    helper(nums, start, j);\\n    helper(nums, i, end);\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArray = function(nums) {\\n    helper(nums, 0, nums.length - 1);\\n    return nums;\\n};\\n\"\n        }\n    ]\n},\n\"beautiful-array\":{\n    \"id\": \"932\",\n    \"name\": \"beautiful-array\",\n    \"pre\": [\n        {\n            \"text\": \"分治\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"利用性质**奇数+偶数=奇数**\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"对问题进行分解\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/932.beautiful-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/932.beautiful-array.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        @lru_cache(None)\\n        def dp(n):\\n            if n == 1:\\n                return [1]\\n            ans = []\\n            # [1,n] 中奇数比偶数多1或一样\\n            for a in dp(n - n // 2):\\n                ans += [a * 2 - 1]\\n            for b in dp(n // 2):\\n                ans += [b * 2]\\n            return ans\\n\\n        return dp(N)\\n\\n\"\n        }\n    ]\n},\n\"knight-dialer\":{\n    \"id\": \"935\",\n    \"name\": \"knight-dialer\",\n    \"pre\": [\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"记忆化搜索\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/935.knight-dialer.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/935.knight-dialer.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        cnt = 0\\n        jump = [[4, 6], [6, 8], [7, 9], [4, 8], [\\n            0, 3, 9], [], [0, 1, 7], [2, 6], [1, 3], [2, 4]]\\n        visited = dict()\\n\\n        def helper(i, n):\\n            if (i, n) in visited: return visited[(i, n)]\\n            if n == 1:\\n                return 1\\n            cnt = 0\\n            for j in jump[i]:\\n                cnt += helper(j, n - 1)\\n            visited[(i, n)] = cnt\\n            return cnt\\n        for i in range(10):\\n            cnt += helper(i, N)\\n        return cnt % (10**9 + 7)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def knightDialer(self, N: int) -> int:\\n        a0 = a1 = a2 = a3 = a4 = a5 = a6 = a7 = a8 = a9 = 1\\n        for _ in range(N - 1):\\n            a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 = a4 + a6, a6 + a8, a7 + \\\\\\n                a9, a4 + a8, a0 + a3 + a9, 0, a0 + a1 + a7, a2 + a6, a1 + a3, a2 + a4\\n        return (a0 + a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9) % (10**9 + 7)\\n\"\n        }\n    ]\n},\n\"most-stones-removed-with-same-row-or-column\":{\n    \"id\": \"947\",\n    \"name\": \"most-stones-removed-with-same-row-or-column\",\n    \"pre\": [\n        {\n            \"text\": \"并查集\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md\",\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/947.most-stones-removed-with-same-row-or-column.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/947.most-stones-removed-with-same-row-or-column.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\npublic int removeStones(int[][] stones) {\\n        Set visit = new HashSet();\\n        int count = 0;\\n        int offset = 10000;\\n        HashMap <Integer,List<int []>>map = new HashMap();\\n\\n        // 构造图 每一项是一个节点\\n        for (int i = 0; i < stones.length; i++) {\\n            int [] node = stones[i];\\n            List<int []> list =   map.getOrDefault(node[0]-offset,new ArrayList<>());\\n            list.add(node);\\n            map.put(node[0]-offset,list);\\n\\n            List<int []> list1 = map.getOrDefault(node[1],new ArrayList<>());\\n            list1.add(node);\\n            map.put(node[1],list1);\\n        }\\n        // 寻找联通分量\\n        for (int i = 0; i < stones.length; i++) {\\n            int [] node = stones[i];\\n            if (!visit.contains((node))){\\n                visit.add((node));\\n                dfs(node,visit,map);\\n                count++;\\n            }\\n        }\\n        return stones.length-count;\\n    }\\n\\n    // 遍历节点\\n    public void dfs(int[]node, Set set,HashMap <Integer,List<int []>>map){\\n        int offset = 10000;\\n        List<int []> list =   map.getOrDefault(node[0]-offset,new ArrayList<>());\\n        for (int i = 0; i < list.size(); i++) {\\n            int[] item = list.get(i);\\n            if (!set.contains((item))){\\n                set.add((item));\\n                dfs(item,set,map);\\n            }\\n        }\\n        List<int []> list2 =   map.getOrDefault(node[1],new ArrayList<>());\\n        for (int i = 0; i < list2.size(); i++) {\\n            int[] item = list2.get(i);\\n            if (!set.contains((item))){\\n                set.add((item));\\n                dfs(item,set,map);\\n            }\\n        }\\n    }\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nn = len(stones)\\n# 标准并查集模板\\nuf = UF(n)\\n# 两个 for 循环作用是将所有石子两两合并\\nfor i in range(n):\\n    for j in range(i + 1, n):\\n        # 如果行或者列相同，将其联通成一个子图\\n        if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]: uf.union(i, j)\\nreturn n - uf.cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nn = len(stones)\\nuf = UF(0)\\nfor i in range(n):\\n    uf.union(stones[i][0] + 10001, stones[i][1])\\nreturn n - uf.cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass UF:\\n    def __init__(self, M):\\n        self.parent = {}\\n        self.cnt = 0\\n        # 初始化 parent，size 和 cnt\\n        for i in range(M):\\n            self.parent[i] = i\\n            self.cnt += 1\\n\\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n        return x\\n    def union(self, p, q):\\n        if self.connected(p, q): return\\n        leader_p = self.find(p)\\n        leader_q = self.find(q)\\n        self.parent[leader_p] = leader_q\\n        self.cnt -= 1\\n    def connected(self, p, q):\\n        return self.find(p) == self.find(q)\\n\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        uf = UF(n)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]: uf.union(i, j)\\n        return n - uf.cnt\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass UF:\\n    def __init__(self, M):\\n        self.parent = {}\\n        self.cnt = 0\\n\\n    def find(self, x):\\n        if x not in self.parent:\\n            self.cnt += 1\\n            self.parent[x] = x\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n        return x\\n    def union(self, p, q):\\n        if self.connected(p, q): return\\n        leader_p = self.find(p)\\n        leader_q = self.find(q)\\n        self.parent[leader_p] = leader_q\\n        self.cnt -= 1\\n    def connected(self, p, q):\\n        return self.find(p) == self.find(q)\\n\\nclass Solution:\\n    def removeStones(self, stones: List[List[int]]) -> int:\\n        n = len(stones)\\n        uf = UF(0)\\n        for i in range(n):\\n            uf.union(stones[i][0] + 10001, stones[i][1])\\n        return n - uf.cnt\\n\"\n        }\n    ]\n},\n\"regions-cut-by-slashes\":{\n    \"id\": \"959\",\n    \"name\": \"regions-cut-by-slashes\",\n    \"pre\": [\n        {\n            \"text\": \"BFS\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"DFS\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md \\\"DFS\\\"\",\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"并查集\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md \\\"并查集\\\"\",\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/959.regions-cut-by-slashes.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/959.regions-cut-by-slashes.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\ndef get_pos(row, col):\\n    return row * n + col\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\ndef get_pos(row, col, i):\\n    return row * n + col + i\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n\\nclass UF:\\n  def __init__(self, M):\\n      self.parent = {}\\n      self.cnt = 0\\n      # 初始化 parent，size 和 cnt\\n      for i in range(M):\\n          self.parent[i] = i\\n          self.cnt += 1\\n\\n  def find(self, x):\\n      if x != self.parent[x]:\\n          self.parent[x] = self.find(self.parent[x])\\n          return self.parent[x]\\n      return x\\n  def union(self, p, q):\\n      if self.connected(p, q): return\\n      leader_p = self.find(p)\\n      leader_q = self.find(q)\\n      self.parent[leader_p] = leader_q\\n      self.cnt -= 1\\n  def connected(self, p, q):\\n      return self.find(p) == self.find(q)\\n\\nclass Solution:\\n    def regionsBySlashes(self, grid):\\n        n = len(grid)\\n        N = n * n * 4\\n        uf = UF(N)\\n        def get_pos(row, col, i):\\n            return (row * n + col) * 4 + i\\n        for row in range(n):\\n            for col in range(n):\\n                v = grid[row][col]\\n                if row > 0:\\n                    uf.union(get_pos(row - 1, col, 2), get_pos(row, col, 1))\\n                if col > 0:\\n                    uf.union(get_pos(row, col - 1, 3), get_pos(row, col, 0))\\n                if v == '/':\\n                    uf.union(get_pos(row, col, 0), get_pos(row, col, 1))\\n                    uf.union(get_pos(row, col, 2), get_pos(row, col, 3))\\n                if v == '\\\\\\\\':\\n                    uf.union(get_pos(row, col, 1), get_pos(row, col, 3))\\n                    uf.union(get_pos(row, col, 0), get_pos(row, col, 2))\\n                if v == ' ':\\n                    uf.union(get_pos(row, col, 0), get_pos(row, col, 1))\\n                    uf.union(get_pos(row, col, 1), get_pos(row, col, 2))\\n                    uf.union(get_pos(row, col, 2), get_pos(row, col, 3))\\n\\n        return uf.cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def regionsBySlashes(self, grid: List[str]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        new_grid = [[0 for _ in range(3 * n)] for _ in range(3 * m)]\\n        ans = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == '/':\\n                    new_grid[3 * i][3 * j + 2] = 1\\n                    new_grid[3 * i + 1][3 * j + 1] = 1\\n                    new_grid[3 * i + 2][3 * j] = 1\\n                if grid[i][j] == '\\\\\\\\':\\n                    new_grid[3 * i][3 * j] = 1\\n                    new_grid[3 * i + 1][3 * j + 1] = 1\\n                    new_grid[3 * i + 2][3 * j + 2] = 1\\n        def dfs(i, j):\\n            if 0 <= i < 3 * m and 0 <= j < 3 * n and new_grid[i][j] == 0:\\n                new_grid[i][j] = 1\\n                dfs(i + 1, j)\\n                dfs(i - 1, j)\\n                dfs(i, j + 1)\\n                dfs(i, j - 1)\\n        for i in range(3 * m):\\n            for j in range(3 * n):\\n                if new_grid[i][j] == 0:\\n                    ans += 1\\n                    dfs(i, j)\\n        return ans\\n\"\n        }\n    ]\n},\n\"odd-even-jump\":{\n    \"id\": \"975\",\n    \"name\": \"odd-even-jump\",\n    \"pre\": [\n        {\n            \"text\": \"单调栈\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/monotone-stack.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/975.odd-even-jump.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/975.odd-even-jump.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nn = len(A)\\nnext_higher, next_lower = [-1] * n, [-1] * n\\n\\nstack = []\\nfor i, a in enumerate(A):\\n    while stack and A[stack[-1]] <= A[i]:\\n        next_higher[stack.pop()] = i\\n    stack.append(i)\\nstack = []\\nfor i, a in enumerate(A):\\n    while stack and A[stack[-1]] >= A[i]:\\n        next_lower[stack.pop()] = i\\n    stack.append(i)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nA = sorted([a, i] for i, a in enumerate(A))\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def oddEvenJumps(self, A):\\n        n = len(A)\\n        next_higher, next_lower = [0] * n, [0] * n\\n        A = sorted([a, i] for i, a in enumerate(A))\\n\\n        stack = []\\n        for _, i in A:\\n            # it means stack[-1]'s next bigger(or equal) is i\\n            while stack and stack[-1] < i:\\n                next_higher[stack.pop()] = i\\n            stack.append(i)\\n\\n        stack = []\\n        for _, i in A[::-1]:\\n            # it means stack[-1]'s next smaller(or equal) is i\\n            while stack and stack[-1] < i:\\n                next_lower[stack.pop()] = i\\n            stack.append(i)\\n\\n        # ...\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def oddEvenJumps(self, A):\\n        n = len(A)\\n        next_higher, next_lower = [0] * n, [0] * n\\n\\n        stack = []\\n        for _, i in sorted([a, i] for i, a in enumerate(A)):\\n            # it means stack[-1]'s next bigger(or equal) is i\\n            while stack and stack[-1] < i:\\n                next_higher[stack.pop()] = i\\n            stack.append(i)\\n\\n        stack = []\\n        for _, i in sorted([-a, i] for i, a in enumerate(A)):\\n            # it means stack[-1]'s next smaller(or equal) is i\\n            while stack and stack[-1] < i:\\n                next_lower[stack.pop()] = i\\n            stack.append(i)\\n\\n        higher, lower = [False] * n, [False] * n\\n        higher[-1] = lower[-1] = True\\n        ans = 1\\n        for i in range(n - 2, -1, -1):\\n            higher[i] = lower[next_higher[i]]\\n            lower[i] = higher[next_lower[i]]\\n            ans += higher[i]\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nans = 1\\nfor i in range(n - 2, -1, -1):\\n    higher[i] = lower[next_higher[i]]\\n    lower[i] = higher[next_lower[i]]\\n    ans += higher[i] or lower[i]\\nreturn ans\\n\"\n        }\n    ]\n},\n\"longest-turbulent-subarray\":{\n    \"id\": \"978\",\n    \"name\": \"longest-turbulent-subarray\",\n    \"pre\": [\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/978.longest-turbulent-subarray.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/978.longest-turbulent-subarray.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        ans = 1\\n        i = 0\\n        for j in range(2, len(A)):\\n            if (A[j] == A[j - 1]):\\n                i = j\\n            elif (A[j] - A[j - 1]) ^ (A[j - 1] - A[j - 2]) >= 0:\\n                i = j - 1\\n            ans = max(ans, j - i + 1)\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"vertical-order-traversal-of-a-binary-tree\":{\n    \"id\": \"987\",\n    \"name\": \"vertical-order-traversal-of-a-binary-tree\",\n    \"pre\": [\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/987.vertical-order-traversal-of-a-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/987.vertical-order-traversal-of-a-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n{\\n    1: [1,3,4]\\n    -1: [5]\\n}\\n\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n{\\n    1: {\\n        -2,[1,3,4]\\n        -3,[5]\\n\\n    },\\n    -1: {\\n        -3: [6]\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[][]}\\n */\\nvar verticalTraversal = function (root) {\\n  if (!root) return [];\\n\\n  // 坐标集合以 x 坐标分组\\n  const pos = {};\\n  // dfs 遍历节点并记录每个节点的坐标\\n  dfs(root, 0, 0);\\n\\n  // 得到所有节点坐标后，先按 x 坐标升序排序\\n  let sorted = Object.keys(pos)\\n    .sort((a, b) => +a - +b)\\n    .map((key) => pos[key]);\\n\\n  // 再给 x 坐标相同的每组节点坐标分别排序\\n  sorted = sorted.map((g) => {\\n    g.sort((a, b) => {\\n      // y 坐标相同的，按节点值升序排\\n      if (a[0] === b[0]) return a[1] - b[1];\\n      // 否则，按 y 坐标降序排\\n      else return b[0] - a[0];\\n    });\\n    // 把 y 坐标去掉，返回节点值\\n    return g.map((el) => el[1]);\\n  });\\n\\n  return sorted;\\n\\n  // *********************************\\n  function dfs(root, x, y) {\\n    if (!root) return;\\n\\n    x in pos || (pos[x] = []);\\n    // 保存坐标数据，格式是: [y, val]\\n    pos[x].push([y, root.val]);\\n\\n    dfs(root.left, x - 1, y - 1);\\n    dfs(root.right, x + 1, y - 1);\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    struct node\\n    {\\n        int val;\\n        int x;\\n        int y;\\n        node(int v,int X,int Y):val(v),x(X),y(Y){};\\n    };\\n    static bool cmp(node a,node b)\\n    {\\n        if(a.x^b.x)\\n            return a.x<b.x;\\n        if(a.y^b.y)\\n            return a.y<b.y;\\n        return a.val<b.val;\\n    }\\n    vector<node> a;\\n    int minx=1000,maxx=-1000;\\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\\n        dfs(root,0,0);\\n        sort(a.begin(),a.end(),cmp);\\n        vector<vector<int>>ans(maxx-minx+1);\\n        for(auto xx:a)\\n        {\\n            ans[xx.x-minx].push_back(xx.val);\\n        }\\n        return ans;\\n    }\\n    void dfs(TreeNode* root,int x,int y)\\n    {\\n        if(root==nullptr)\\n            return;\\n        if(x<minx)\\n            minx=x;\\n        if(x>maxx)\\n            maxx=x;\\n        a.push_back(node(root->val,x,y));\\n        dfs(root->left,x-1,y+1);\\n        dfs(root->right,x+1,y+1);\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution(object):\\n    def verticalTraversal(self, root):\\n        seen = collections.defaultdict(\\n            lambda: collections.defaultdict(list))\\n\\n        def dfs(root, x=0, y=0):\\n            if not root:\\n                return\\n            seen[x][y].append(root.val)\\n            dfs(root.left, x-1, y+1)\\n            dfs(root.right, x+1, y+1)\\n\\n        dfs(root)\\n        ans = []\\n        # x 排序、\\n        for x in sorted(seen):\\n            level = []\\n            # y 排序\\n            for y in sorted(seen[x]):\\n                # 值排序\\n                level += sorted(v for v in seen[x][y])\\n            ans.append(level)\\n\\n        return ans\\n\"\n        }\n    ]\n},\n\"minimum-number-of-k-consecutive-bit-flips\":{\n    \"id\": \"995\",\n    \"name\": \"minimum-number-of-k-consecutive-bit-flips\",\n    \"pre\": [\n        {\n            \"text\": \"连续子数组优化\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"连续子数组优化技巧\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/995.minimum-number-of-k-consecutive-bit-flips.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/995.minimum-number-of-k-consecutive-bit-flips.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minKBitFlips(self, A, K):\\n        N = len(A)\\n        ans = 0\\n        for i in range(N - K + 1):\\n            if A[i] == 1:\\n                continue\\n            for j in range(K):\\n                A[i + j] ^= 1\\n            ans += 1\\n        for i in range(N):\\n            if A[i] == 0:\\n                return -1\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def minKBitFlips(self, A: List[int], K: int) -> int:\\n        n = len(A)\\n        diff = [0] * (n + 1)\\n        ans, cur = 0, 0\\n        for i in range(n):\\n            cur += diff[i]\\n            if cur % 2 == A[i]:\\n                if i + K > n:\\n                    return -1\\n                ans += 1\\n                cur += 1\\n                diff[i + K] -= 1\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minKBitFlips(self, A, K):\\n        N = len(A)\\n        q = collections.deque()\\n        ans = 0\\n        for i in range(N):\\n            if q and i >= q[0] + K:\\n                q.popleft()\\n            if len(q) % 2 == A[i]:\\n                if i + K > N:\\n                    return -1\\n                q.append(i)\\n                ans += 1\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def minKBitFlips(self, A, K):\\n        flips = ans = 0\\n        for i in range(len(A)):\\n            if i >= K and A[i - K] - 2 == 0:\\n                flips -= 1\\n            if (flips % 2) == A[i]:\\n                if i + K > len(A):\\n                    return -1\\n                A[i] = 2\\n                flips += 1\\n                ans += 1\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"max-consecutive-ones-iii\":{\n    \"id\": \"1004\",\n    \"name\": \"max-consecutive-ones-iii\",\n    \"pre\": [],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1004.max-consecutive-ones-iii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1004.max-consecutive-ones-iii.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def longestOnes(self, A: List[int], K: int) -> int:\\n        i = ans = 0\\n\\n        for j in range(len(A)):\\n            K -= A[j] == 0\\n            while K < 0:\\n                K += A[i] == 0\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def longestOnes(self, A: List[int], K: int) -> int:\\n        i = 0\\n\\n        for j in range(len(A)):\\n            K -= 1 - A[j]\\n            if K < 0:\\n                K += 1 - A[i]\\n                i += 1\\n        return j - i + 1\\n\"\n        }\n    ]\n},\n\"capacity-to-ship-packages-within-d-days-cn\":{\n    \"id\": \"1011\",\n    \"name\": \"capacity-to-ship-packages-within-d-days-cn\",\n    \"pre\": [\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"能够识别出是给定的有限序列查找一个数字（二分查找），要求你对二分查找以及变体十分熟悉\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1011.capacity-to-ship-packages-within-d-days-cn.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1011.capacity-to-ship-packages-within-d-days-cn.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} weights\\n * @param {number} D\\n * @return {number}\\n */\\nvar shipWithinDays = function(weights, D) {\\n  let high = weights.reduce((acc, cur) => acc + cur)\\n  let low = 0\\n\\n  while(low < high) {\\n    let mid = Math.floor((high + low) / 2)\\n    if (canShip(mid)) {\\n      high = mid\\n    } else {\\n      low = mid + 1\\n    }\\n  }\\n\\n  return low\\n\\n  function canShip(opacity) {\\n    let remain = opacity\\n    let count = 1\\n    for (let weight of weights) {\\n      if (weight > opacity) {\\n        return false\\n      }\\n      remain -= weight\\n      if (remain < 0) {\\n        count++\\n        remain = opacity - weight\\n      }\\n      if (count > D) {\\n        return false\\n      }\\n    }\\n    return count <= D\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef canShip(opacity):\\n    # 指定船的容量是否可以在D天运完\\n    lo = 0\\n    hi = total\\n    while lo < hi:\\n        mid = (lo + hi) // 2\\n        if canShip(mid):\\n            hi = mid\\n        else:\\n            lo = mid + 1\\n\\n    return lo\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\\n        lo = 0\\n        hi = 0\\n\\n        def canShip(opacity):\\n            days = 1\\n            remain = opacity\\n            for weight in weights:\\n                if weight > opacity:\\n                    return False\\n                remain -= weight\\n                if remain < 0:\\n                    days += 1\\n                    remain = opacity - weight\\n            return days <= D\\n\\n        for weight in weights:\\n            hi += weight\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if canShip(mid):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n\\n        return lo\\n\"\n        }\n    ]\n},\n\"capacity-to-ship-packages-within-d-days\":{\n    \"id\": \"1011\",\n    \"name\": \"capacity-to-ship-packages-within-d-days\",\n    \"pre\": [\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"能够识别出是给定的有限序列查找一个数字（二分查找），要求你对二分查找以及变体十分熟悉\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1011.capacity-to-ship-packages-within-d-days.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1011.capacity-to-ship-packages-within-d-days.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n/**\\n * @param {number[]} weights\\n * @param {number} D\\n * @return {number}\\n */\\nvar shipWithinDays = function (weights, D) {\\n  let high = weights.reduce((acc, cur) => acc + cur);\\n  let low = 0;\\n\\n  while (low < high) {\\n    let mid = Math.floor((high + low) / 2);\\n    if (canShip(mid)) {\\n      high = mid;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n\\n  return low;\\n\\n  function canShip(opacity) {\\n    let remain = opacity;\\n    let count = 1;\\n    for (let weight of weights) {\\n      if (weight > opacity) {\\n        return false;\\n      }\\n      remain -= weight;\\n      if (remain < 0) {\\n        count++;\\n        remain = opacity - weight;\\n      }\\n      if (count > D) {\\n        return false;\\n      }\\n    }\\n    return count <= D;\\n  }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef canShip(opacity):\\n    # 指定船的容量是否可以在D天运完\\n    lo = 0\\n    hi = total\\n    while lo < hi:\\n        mid = (lo + hi) // 2\\n        if canShip(mid):\\n            hi = mid\\n        else:\\n            lo = mid + 1\\n\\n    return lo\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def shipWithinDays(self, weights: List[int], D: int) -> int:\\n        lo = 0\\n        hi = 0\\n\\n        def canShip(opacity):\\n            days = 1\\n            remain = opacity\\n            for weight in weights:\\n                if weight > opacity:\\n                    return False\\n                remain -= weight\\n                if remain < 0:\\n                    days += 1\\n                    remain = opacity - weight\\n            return days <= D\\n\\n        for weight in weights:\\n            hi += weight\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if canShip(mid):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n\\n        return lo\\n\"\n        }\n    ]\n},\n\"best-sightseeing-pair\":{\n    \"id\": \"1014\",\n    \"name\": \"best-sightseeing-pair\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"dp空间优化\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1014.best-sightseeing-pair.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1014.best-sightseeing-pair.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = 0\\n        for i in range(n - 1):\\n            for j in range(i + 1, n):\\n                res = max(res, A[i] + A[j] + i - j)\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        n = len(A)\\n        dp = [float('-inf')] * (n + 1)\\n        res = 0\\n        for i in range(n):\\n            dp[i + 1] = max(dp[i], A[i] + i)\\n            res = max(res, dp[i] + A[i] - i)\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        n = len(A)\\n        pre = A[0] + 0\\n        res = 0\\n        for i in range(1, n):\\n            res = max(res, pre + A[i] - i)\\n            pre = max(pre, A[i] + i)\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxScoreSightseeingPair(self, A: List[int]) -> int:\\n        n = len(A)\\n        pre = A[0] + 0\\n        res = 0\\n        for i in range(1, n):\\n            # res = max(res, pre + A[i] - i)\\n            # pre = max(pre, A[i] + i)\\n            res = res if res > pre + A[i] - i else pre + A[i] - i\\n            pre = pre if pre > A[i] + i else A[i] + i\\n        return res\\n\"\n        }\n    ]\n},\n\"smallest-integer-divisible-by-k\":{\n    \"id\": \"1015\",\n    \"name\": \"smallest-integer-divisible-by-k\",\n    \"pre\": [\n        {\n            \"text\": \"循环节\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"数学（无限循环与循环节）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1015.smallest-integer-divisible-by-k.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1015.smallest-integer-divisible-by-k.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n#\\n# @lc app=leetcode.cn id=1015 lang=python3\\n#\\n# [1015] 可被 K 整除的最小整数\\n#\\n\\n# @lc code=start\\n\\n\\nclass Solution:\\n    def smallestRepunitDivByK(self, K: int) -> int:\\n        if K % 10 in [2, 4, 5, 6, 8]:\\n            return - 1\\n        seen = set()\\n        mod = 0\\n        for i in range(1, K + 1):\\n            mod = (mod * 10 + 1) % K\\n            if mod in seen:\\n                return -1\\n            if mod == 0:\\n                return ix\\n            seen.add(mod)\\n\"\n        }\n    ]\n},\n\"next-greater-node-in-linked-list\":{\n    \"id\": \"1019\",\n    \"name\": \"next-greater-node-in-linked-list\",\n    \"pre\": [\n        {\n            \"text\": \"链表\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"单调栈（单调递减栈）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"单调栈的代码模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1019.next-greater-node-in-linked-list.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1019.next-greater-node-in-linked-list.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef monoStack(list):\\n    st = []\\n    for v in list:\\n        while len(st) > 0 and v > st[-1]:\\n            st.pop()\\n        st.append(v)\\n    return st\\nmonoStack([5, 4, 2, 1, 3]) # output: [5, 4, 3]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n     def nextLargerNodes(self, head):\\n        res, st = [], []\\n        while head:\\n            while len(st) > 0 and head.val > st[-1][1]:\\n                res[st.pop()[0]] = head.val\\n            st.append((len(res), head.val))\\n            res.append(0)\\n            head = head.next\\n        return res\\n\"\n        }\n    ]\n},\n\"number-of-enclaves\":{\n    \"id\": \"1020\",\n    \"name\": \"number-of-enclaves\",\n    \"pre\": [\n        {\n            \"text\": \"DFS\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"hashset\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"visited记录访问过的节点，防止无限循环。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1020.number-of-enclaves.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1020.number-of-enclaves.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    temp = 0\\n    meetEdge = False\\n\\n    def numEnclaves(self, A: List[List[int]]) -> int:\\n        cnt = 0\\n        m = len(A)\\n        n = len(A[0])\\n        visited = set()\\n\\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n or (i, j) in visited:\\n                return\\n            visited.add((i, j))\\n            if A[i][j] == 1:\\n                self.temp += 1\\n            else:\\n                return\\n            if i == 0 or i == m - 1 or j == 0 or j == n - 1:\\n                self.meetEdge = True\\n            dfs(i + 1, j)\\n            dfs(i - 1, j)\\n            dfs(i, j + 1)\\n            dfs(i, j - 1)\\n        for i in range(m):\\n            for j in range(n):\\n                dfs(i, j)\\n                if not self.meetEdge:\\n                    cnt += self.temp\\n                self.meetEdge = False\\n                self.temp = 0\\n        return cnt\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n#\\n# @lc app=leetcode.cn id=1020 lang=python3\\n#\\n# [1020] 飞地的数量\\n#\\n\\n# @lc code=start\\n\\n\\nclass Solution:\\n\\n    def numEnclaves(self, A: List[List[int]]) -> int:\\n        cnt = 0\\n        m = len(A)\\n        n = len(A[0])\\n\\n        def dfs(i, j):\\n            if i < 0 or i >= m or j < 0 or j >= n or A[i][j] == 0:\\n                return\\n            A[i][j] = 0\\n\\n            dfs(i + 1, j)\\n            dfs(i - 1, j)\\n            dfs(i, j + 1)\\n            dfs(i, j - 1)\\n        for i in range(m):\\n            dfs(i, 0)\\n            dfs(i, n - 1)\\n        for j in range(1, n - 1):\\n            dfs(0, j)\\n            dfs(m - 1, j)\\n        for i in range(m):\\n            for j in range(n):\\n                if A[i][j] == 1:\\n                    cnt += 1\\n        return cnt\\n\\n        # @lc code=end\\n\\n\"\n        }\n    ]\n},\n\"camelcase-matching\":{\n    \"id\": \"1023\",\n    \"name\": \"camelcase-matching\",\n    \"pre\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"字符串匹配\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"子序列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"子串\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1023.camelcase-matching.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1023.camelcase-matching.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def isSubsequence(self, s: str, t: str) -> bool:\\n        i = 0\\n        j = 0\\n        while j < len(t):\\n            if i < len(s) and s[i] == t[j]:\\n                i += 1\\n                j += 1\\n            else:\\n                j += 1\\n            if i >= len (s):\\n                return True\\n        return i == len(s)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\\n        res = []\\n        for query in queries:\\n            i = 0\\n            j = 0\\n            while i < len(query):\\n                if j < len(pattern) and query[i] == pattern[j]:\\n                    i += 1\\n                    j += 1\\n                elif query[i].islower():\\n                    i += 1\\n                else:\\n                    break\\n            if i == len(query) and j == len(pattern):\\n                res.append(True)\\n            else:\\n                res.append(False)\\n        return res\\n\"\n        }\n    ]\n},\n\"maximum-sum-of-two-non-overlapping-subarrays\":{\n    \"id\": \"1031\",\n    \"name\": \"maximum-sum-of-two-non-overlapping-subarrays\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"解析1.注意图中描述的都是A[i\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1],而不是A[i],因为basecase为空数组,而不是A[0];2.求解图中ASUM数组的时候,注意定义的是ASUM[i]=sum(A[0:i]),因此当i等于0时,A[0:0]为空数组,即:ASUM[0]为0,而ASUM[1]才等于A[0];3.求解图中MAXL数组时,注意i<L时,没有意义,因为长度不够,所以从i=L时才开始求解;4.求解图中MAXM数组时,也一样,要从i=M时才开始求解;5.求解图中SUMM数组时,因为我们需要一个L子数组和一个M子数组,因此长度要大于等于L+M才有意义,所以要从i=L+M时开始求解.\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1031.maximum-sum-of-two-non-overlapping-subarrays.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1031.maximum-sum-of-two-non-overlapping-subarrays.md\",\n    \"code\": [\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\nprivate:\\n    int get(vector<int> &v, int i) {\\n        return (i >= 0 && i < v.size()) ? v[i] : 0;\\n    }\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int N = A.size(), ans = 0;\\n        partial_sum(A.begin(), A.end(), A.begin());\\n        vector<int> maxLeft(N, 0), maxRight(N, 0);\\n        for (int i = L - 1; i < N; ++i) maxLeft[i] = max(get(maxLeft, i - 1), A[i] - get(A, i - L));\\n        for (int i = N - L; i >= 0; --i) maxRight[i] = max(get(maxRight, i + 1), A[i + L - 1] - get(A, i - 1));\\n        for (int i = M - 1; i < N; ++i) {\\n            int sum = A[i] - get(A, i - M)\\n                + max(get(maxLeft, i - M), get(maxRight, i + 1));\\n            ans = max(ans, sum);\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, a: List[int], l: int, m: int) -> int:\\n        \\\"\\\"\\\"\\n\\n        define asum[i] as the sum of subarray, a[0:i]\\n        define maxl[i] as the maximum sum of l-length subarray in a[0:i]\\n        define maxm[i] as the maximum sum of m-length subarray in a[0:i]\\n        define msum[i] as the maximum sum of non-overlap l-length subarray and m-length subarray\\n\\n        case 1: a[i] is both not in l-length subarray and m-length subarray, then msum[i] = msum[i - 1]\\n        case 2: a[i] is in l-length subarray, then msum[i] = asum[i] - asum[i-l] + maxm[i-l]\\n        case 3: a[i] is in m-length subarray, then msum[i] = asum[i] - asum[i-m] + maxl[i-m]\\n\\n        so, msum[i] = max(msum[i - 1], asum[i] - asum[i-l] + maxl[i-l], asum[i] - asum[i-m] + maxm[i-m])\\n        \\\"\\\"\\\"\\n\\n        alen, tlen = len(a), l + m\\n        asum = [0] * (alen + 1)\\n        maxl = [0] * (alen + 1)\\n        maxm = [0] * (alen + 1)\\n        msum = [0] * (alen + 1)\\n\\n        for i in range(tlen):\\n            if i == 1:\\n                asum[i] = a[i - 1]\\n            elif i > 1:\\n                asum[i] = asum[i - 1] + a[i - 1]\\n            if i >= l:\\n                maxl[i] = max(maxl[i - 1], asum[i] - asum[i - l])\\n            if i >= m:\\n                maxm[i] = max(maxm[i - 1], asum[i] - asum[i - m])\\n\\n        for i in range(tlen, alen + 1):\\n            asum[i] = asum[i - 1] + a[i - 1]\\n            suml = asum[i] - asum[i - l]\\n            summ = asum[i] - asum[i - m]\\n            maxl[i] = max(maxl[i - 1], suml)\\n            maxm[i] = max(maxm[i - 1], summ)\\n            msum[i] = max(msum[i - 1], suml + maxm[i - l], summ + maxl[i - m])\\n\\n        return msum[-1]\\n\"\n        }\n    ]\n},\n\"stream-of-characters\":{\n    \"id\": \"1032\",\n    \"name\": \"stream-of-characters\",\n    \"pre\": [\n        {\n            \"text\": \"前缀树\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"前缀树模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"倒序插入\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1032.stream-of-characters.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1032.stream-of-characters.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nstreamChecker.query(\\\"a\\\"); // stream： a\\nstreamChecker.query(\\\"b\\\"); // stream：ba\\nstreamChecker.query(\\\"c\\\"); // stream：cba\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.stream = deque([])\\n\\n        for word in set(words):\\n            self.trie.insert(word[::-1])\\n\\n    def query(self, letter: str) -> bool:\\n        self.stream.appendleft(letter)\\n        return self.trie.search(self.stream)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Trie:\\n\\n    def __init__(self):\\n        \\\"\\\"\\\"\\n        Initialize your data structure here.\\n        \\\"\\\"\\\"\\n        self.Trie = {}\\n\\n    def insert(self, word):\\n        \\\"\\\"\\\"\\n        Inserts a word into the trie.\\n        :type word: str\\n        :rtype: void\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for w in word:\\n            if w not in curr:\\n                curr[w] = {}\\n            curr = curr[w]\\n        curr['#'] = 1\\n\\n    def search(self, word):\\n        \\\"\\\"\\\"\\n        Returns if the word is in the trie.\\n        :type word: str\\n        :rtype: bool\\n        \\\"\\\"\\\"\\n        curr = self.Trie\\n        for w in word:\\n            if w not in curr:\\n                return False\\n            if \\\"#\\\" in curr[w]:\\n                return True\\n            curr = curr[w]\\n        return False\\n\\n\\nclass StreamChecker:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        self.stream = deque([])\\n\\n        for word in set(words):\\n            self.trie.insert(word[::-1])\\n\\n    def query(self, letter: str) -> bool:\\n        self.stream.appendleft(letter)\\n        return self.trie.search(self.stream)\\n\\n\\n\"\n        }\n    ]\n},\n\"partition-array-for-maximum-sum\":{\n    \"id\": \"1043\",\n    \"name\": \"partition-array-for-maximum-sum\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"记忆化递归\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1043.partition-array-for-maximum-sum.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1043.partition-array-for-maximum-sum.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\\n        @lru_cache(None)\\n        def dp(i):\\n            if i >= len(arr): return 0\\n            ans = 0\\n            max_value = -1\\n            for steps in range(1, k + 1):\\n                if i + steps - 1 < len(arr): max_value = max(max_value, arr[i + steps - 1])\\n                else: break\\n                ans = max(ans, max_value * steps +  dp(i + steps))\\n            return ans\\n        return dp(0)\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def maxSumAfterPartitioning(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        dp = [0] * (n+1)\\n\\n        for i in range(1, n+1):\\n            max_ele = 0\\n            for j in range(i, min(n+1, i+k)):\\n                max_ele = max(max_ele, nums[j-1])\\n                # range: [i,j]\\n                dp[j] = max(dp[j], (j-i+1) * max_ele + dp[i-1])\\n        return max(dp)\\n\\n\"\n        }\n    ]\n},\n\"path-in-zigzag-labelled-binary-tree\":{\n    \"id\": \"1104\",\n    \"name\": \"path-in-zigzag-labelled-binary-tree\",\n    \"pre\": [\n        {\n            \"text\": \"二叉树\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"满二叉树的性质：1.最小值是`2**(level\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1)`，最大值是`2**level\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1`，其中level是树的深度。2.假如父节点的索引为i，那么左子节点就是2\\\\*i，右边子节点就是2\\\\*i+1。3.假如子节点的索引是i，那么父节点的索引就是i//2。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"先思考一般情况（不是之字形），然后通过观察找出规律\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1104.path-in-zigzag-labelled-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1104.path-in-zigzag-labelled-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def pathInZigZagTree(self, label: int) -> List[int]:\\n        level = 0\\n        res = []\\n        while 2 ** level - 1 < label:\\n            level += 1\\n\\n        while level > 0:\\n            res.insert(0, label)\\n            label = 2 ** (level - 1) + 2 ** level - 1 - label\\n            label //= 2\\n            level -= 1\\n        return res\\n\"\n        }\n    ]\n},\n\"number-of-equivalent-domino-pairs\":{\n    \"id\": \"1128\",\n    \"name\": \"number-of-equivalent-domino-pairs\",\n    \"pre\": [\n        {\n            \"text\": \"组合计数\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1128.number-of-equivalent-domino-pairs.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1128.number-of-equivalent-domino-pairs.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        n = len(dominoes)\\n        cnt = 0\\n        cntMapper = dict()\\n\\n        for a, b in dominoes:\\n            k = str(a) + str(b) if a > b else str(b) + str(a)\\n            cntMapper[k] = cntMapper.get(k, 0) + 1\\n        for k in cntMapper:\\n            v = cntMapper[k]\\n            if v > 1:\\n                cnt += (v * (v - 1)) // 2\\n        return cnt\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n       counts = [0] * 1024\\n        ans = 0\\n        for a, b in dominoes:\\n            if a >= b: v = a <<5 | b\\n            else: v = b << 5 | a\\n            ans += counts[v]\\n            counts[v] += 1\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counts = [0] * 9 * 9\\n        ans = 0\\n        for a, b in dominoes:\\n            v = min((a - 1) * 9 + (b - 1), (b - 1) * 9 + (a - 1))\\n            ans += counts[v]\\n            counts[v] += 1\\n        return ans\\n\"\n        }\n    ]\n},\n\"maximum-of-absolute-value-expression\":{\n    \"id\": \"1131\",\n    \"name\": \"maximum-of-absolute-value-expression\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"数学分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"阿里巴巴\"\n        },\n        {\n            \"name\": \"腾讯\"\n        },\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1131.maximum-of-absolute-value-expression.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1131.maximum-of-absolute-value-expression.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        A = []\\n        B = []\\n        C = []\\n        D = []\\n        for i in range(len(arr1)):\\n            a, b, c, d = arr1[i] + arr2[i] + i, arr1[i] - arr2[i] + \\\\\\n                i, arr2[i] - arr1[i] + i, -1 * arr2[i] - arr1[i] + i\\n            A.append(a)\\n            B.append(b)\\n            C.append(c)\\n            D.append(d)\\n        return max(max(A) - min(A), max(B) - min(B), max(C) - min(C), max(D) - min(D))\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        # 曼哈顿距离模板代码\\n        sign = [1, -1]\\n        n = len(arr1)\\n        dists = []\\n        # 三维模板\\n        for a in sign:\\n            for b in sign:\\n                for c in sign:\\n                    maxDist = float('-inf')\\n                    minDist = float('inf')\\n                    # 分别计算所有点的曼哈顿距离\\n                    for i in range(n):\\n                        dist = arr1[i] * a + arr2[i] * b + i * c\\n                        maxDist = max(maxDist, dist)\\n                        minDist = min(minDist, dist)\\n                    # 将所有的点的曼哈顿距离放到dists中\\n                    dists.append(maxDist - minDist)\\n        return max(dists)\\n\"\n        }\n    ]\n},\n\"optimize-water-distribution-in-a-village-cn\":{\n    \"id\": \"1168\",\n    \"name\": \"optimize-water-distribution-in-a-village-cn\",\n    \"pre\": [\n        {\n            \"text\": \"图\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"最小生成树\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析1.构建图，得出所有边2.对所有边排序3.遍历所有的边（从小到大）4.对于每条边，检查是否已经连通，若没有连通，加上边上的值，连通两个节点。若已连通，跳过。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1168.optimize-water-distribution-in-a-village-cn.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1168.optimize-water-distribution-in-a-village-cn.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n  class OptimizeWaterDistribution {\\n    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {\\n      List<EdgeCost> costs = new ArrayList<>();\\n      for (int i = 1; i <= n; i++) {\\n        costs.add(new EdgeCost(0, i, wells[i - 1]));\\n      }\\n      for (int[] p : pipes) {\\n        costs.add(new EdgeCost(p[0], p[1], p[2]));\\n      }\\n      Collections.sort(costs);\\n      int minCosts = 0;\\n      UnionFind uf = new UnionFind(n);\\n      for (EdgeCost edge : costs) {\\n        int rootX = uf.find(edge.node1);\\n        int rootY = uf.find(edge.node2);\\n        if (rootX == rootY) continue;\\n        minCosts += edge.cost;\\n        uf.union(edge.node1, edge.node2);\\n        // for each union, we connnect one node\\n        n--;\\n        // if all nodes already connected, terminate early\\n        if (n == 0) {\\n          return minCosts;\\n        }\\n      }\\n      return minCosts;\\n    }\\n  \\n    class EdgeCost implements Comparable<EdgeCost> {\\n      int node1;\\n      int node2;\\n      int cost;\\n      public EdgeCost(int node1, int node2, int cost) {\\n        this.node1 = node1;\\n        this.node2 = node2;\\n        this.cost = cost;\\n      }\\n  \\n      @Override\\n      public int compareTo(EdgeCost o) {\\n        return this.cost - o.cost;\\n      }\\n    }\\n    \\n    class UnionFind {\\n      int[] parent;\\n      int[] rank;\\n      public UnionFind(int n) {\\n        parent = new int[n + 1];\\n        for (int i = 0; i <= n; i++) {\\n          parent[i] = i;\\n        }\\n        rank = new int[n + 1];\\n      }\\n      public int find(int x) {\\n        return x == parent[x] ? x : find(parent[x]);\\n      }\\n      public void union(int x, int y) {\\n        int px = find(x);\\n        int py = find(y);\\n        if (px == py) return;\\n        if (rank[px] >= rank[py]) {\\n          parent[py] = px;\\n          rank[px] += rank[py];\\n        } else {\\n          parent[px] = py;\\n          rank[py] += rank[px];\\n        }\\n      }\\n    }\\n  }\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minCostToSupplyWater(self, n: int, wells: List[int], pipes: List[List[int]]) -> int:\\n        union_find = {i: i for i in range(n + 1)}\\n        \\n        def find(x):\\n            return x if x == union_find[x] else find(union_find[x])\\n        \\n        def union(x, y):\\n            px = find(x)\\n            py = find(y)\\n            union_find[px] = py\\n            \\n        graph_wells = [[cost, 0, i] for i, cost in enumerate(wells, 1)]\\n        graph_pipes = [[cost, i, j] for i, j, cost in pipes]\\n        min_costs = 0\\n        for cost, x, y in sorted(graph_wells + graph_pipes):\\n            if find(x) == find(y):\\n                continue\\n            union(x, y)\\n            min_costs += cost\\n            n -= 1\\n            if n == 0:\\n                return min_costs\\n\"\n        }\n    ]\n},\n\"optimize-water-distribution-in-a-village\":{\n    \"id\": \"1168\",\n    \"name\": \"optimize-water-distribution-in-a-village\",\n    \"pre\": [\n        {\n            \"text\": \"图\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"最小生成树\",\n            \"link\": null,\n            \"color\": \"gold\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"分析1.构建图，得出所有边2.对所有边排序3.遍历所有的边（从小到大）4.对于每条边，检查是否已经连通，若没有连通，加上边上的值，连通两个节点。若已连通，跳过。\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1168.optimize-water-distribution-in-a-village.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1168.optimize-water-distribution-in-a-village.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n  class OptimizeWaterDistribution {\\n    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {\\n      List<EdgeCost> costs = new ArrayList<>();\\n      for (int i = 1; i <= n; i++) {\\n        costs.add(new EdgeCost(0, i, wells[i - 1]));\\n      }\\n      for (int[] p : pipes) {\\n        costs.add(new EdgeCost(p[0], p[1], p[2]));\\n      }\\n      Collections.sort(costs);\\n      int minCosts = 0;\\n      UnionFind uf = new UnionFind(n);\\n      for (EdgeCost edge : costs) {\\n        int rootX = uf.find(edge.node1);\\n        int rootY = uf.find(edge.node2);\\n        if (rootX == rootY) continue;\\n        minCosts += edge.cost;\\n        uf.union(edge.node1, edge.node2);\\n        // for each union, we connnect one node\\n        n--;\\n        // if all nodes already connected, terminate early\\n        if (n == 0) {\\n          return minCosts;\\n        }\\n      }\\n      return minCosts;\\n    }\\n  \\n    class EdgeCost implements Comparable<EdgeCost> {\\n      int node1;\\n      int node2;\\n      int cost;\\n      public EdgeCost(int node1, int node2, int cost) {\\n        this.node1 = node1;\\n        this.node2 = node2;\\n        this.cost = cost;\\n      }\\n  \\n      @Override\\n      public int compareTo(EdgeCost o) {\\n        return this.cost - o.cost;\\n      }\\n    }\\n    \\n    class UnionFind {\\n      int[] parent;\\n      int[] rank;\\n      public UnionFind(int n) {\\n        parent = new int[n + 1];\\n        for (int i = 0; i <= n; i++) {\\n          parent[i] = i;\\n        }\\n        rank = new int[n + 1];\\n      }\\n      public int find(int x) {\\n        return x == parent[x] ? x : find(parent[x]);\\n      }\\n      public void union(int x, int y) {\\n        int px = find(x);\\n        int py = find(y);\\n        if (px == py) return;\\n        if (rank[px] >= rank[py]) {\\n          parent[py] = px;\\n          rank[px] += rank[py];\\n        } else {\\n          parent[px] = py;\\n          rank[py] += rank[px];\\n        }\\n      }\\n    }\\n  }\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minCostToSupplyWater(self, n: int, wells: List[int], pipes: List[List[int]]) -> int:\\n        union_find = {i: i for i in range(n + 1)}\\n        \\n        def find(x):\\n            return x if x == union_find[x] else find(union_find[x])\\n        \\n        def union(x, y):\\n            px = find(x)\\n            py = find(y)\\n            union_find[px] = py\\n            \\n        graph_wells = [[cost, 0, i] for i, cost in enumerate(wells, 1)]\\n        graph_pipes = [[cost, i, j] for i, j, cost in pipes]\\n        min_costs = 0\\n        for cost, x, y in sorted(graph_wells + graph_pipes):\\n            if find(x) == find(y):\\n                continue\\n            union(x, y)\\n            min_costs += cost\\n            n -= 1\\n            if n == 0:\\n                return min_costs\\n\"\n        }\n    ]\n},\n\"number-of-valid-words-for-each-puzzle\":{\n    \"id\": \"1178\",\n    \"name\": \"number-of-valid-words-for-each-puzzle\",\n    \"pre\": [\n        {\n            \"text\": \"枚举子集\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        },\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"前缀树\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"枚举子集算法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1178.number-of-valid-words-for-each-puzzle.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1178.number-of-valid-words-for-each-puzzle.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        s_word = [set(word) for word in words]\\n        ans = []\\n        for puzzle in puzzles:\\n            cnt = 0\\n            for word in s_word:\\n                if puzzle[0] not in word:\\n                    continue\\n                flag = False\\n                for c in word:\\n                    if c not in puzzle:\\n                        flag = True\\n                        break\\n                if not flag:\\n                    cnt += 1\\n            ans.append(cnt)\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        counts = collections.defaultdict(int)\\n        ans = [0] * len(puzzles)\\n        for word in words:\\n            bit = 0 # bit 是 word 的二进制表示\\n            for c in word:\\n                bit |= 1 << ord(c) - ord(\\\"a\\\")\\n            counts[bit] += 1\\n        for i, puzzle in enumerate(puzzles):\\n            bit = 0 # bit 是 puzzle 的二进制表示\\n            for c in puzzle:\\n                bit |= 1 << ord(c) - ord(\\\"a\\\")\\n            j = bit # j 是 bit 的子集\\n            # 倒序枚举 bit 的子集 j\\n            while j:\\n                # 单词 word 需要包含谜面的第一个字母\\n                if 1 << ord(puzzle[0]) - ord(\\\"a\\\") & j:\\n                    ans[i] += counts[j]\\n                j = bit & (j - 1)\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n{\\n    \\\"abc\\\": 3\\n}\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef get_subset(puzzle, pos):\\n  # ...\\n  get_subset(next_with_puzzle_pos , pos + 1) # 选 pos\\n  get_subset(next_without_puzzle_pos, pos + 1) # 不选 pos\\n  # ...\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\n class TrieNode:\\n    def __init__(self):\\n        self.count = 0\\n        self.children = {}\\n\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.count += 1\\n\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        trie = Trie()\\n        for word in words:\\n            trie.insert(sorted(set(word)))\\n\\n        def get_count(first_letter, cur, i, puzzle):\\n            if i == len(puzzle):\\n                return cur.count\\n            if not cur:\\n                return 0\\n            ans = 0\\n            # 这个判断成立的条件是 puzzle 中不存在重复的字符， 这恰好就是题目的限制条件\\n            if puzzle[i] != first_letter:\\n                ans += get_count(first_letter, cur, i + 1, puzzle)\\n            if puzzle[i] in cur.children:\\n                ans += get_count(first_letter, cur.children[puzzle[i]], i + 1, puzzle)\\n            return ans\\n\\n\"\n        }\n    ]\n},\n\"maximum-subarray-sum-with-one-deletion\":{\n    \"id\": \"1186\",\n    \"name\": \"maximum-subarray-sum-with-one-deletion\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"空间换时间\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"头尾双数组\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1186.maximum-subarray-sum-with-one-deletion.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1186.maximum-subarray-sum-with-one-deletion.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n  class Solution:\\n    def maximumSum(self, arr: List[int]) -> int:\\n        res = arr[0]\\n        def maxSubSum(arr, skip):\\n            res = maxSub = float(\\\"-inf\\\")\\n\\n            for i in range(len(arr)):\\n                if i == skip:\\n                    continue\\n                maxSub = max(arr[i], maxSub + arr[i])\\n                res = max(res, maxSub)\\n            return res\\n\\t\\t# 这里循环到了len(arr)项，表示的是一个都不删除的情况\\n        for i in range(len(arr) + 1):\\n            res = max(res, maxSubSum(arr, i))\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maximumSum(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        l = [arr[0]] * n\\n        r = [arr[n - 1]] * n\\n        if n == 1:\\n            return arr[0]\\n        res = arr[0]\\n        for i in range(1, n):\\n            l[i] = max(l[i - 1] + arr[i], arr[i])\\n            res = max(res, l[i])\\n        for i in range(n - 2, -1, -1):\\n            r[i] = max(r[i + 1] + arr[i], arr[i])\\n            res = max(res, r[i])\\n        for i in range(1, n - 1):\\n            res = max(res, l[i - 1] + r[i + 1])\\n\\n        return res\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n#\\n# @lc app=leetcode.cn id=1186 lang=python3\\n#\\n# [1186] 删除一次得到子数组最大和\\n#\\n\\n# @lc code=start\\n\\n\\nclass Solution:\\n    def maximumSum(self, arr: List[int]) -> int:\\n        # DP\\n        max0 = arr[0]\\n        max1 = arr[0]\\n        res = arr[0]\\n        n = len(arr)\\n        if n == 1:\\n            return max0\\n\\n        for i in range(1, n):\\n            # 先更新max1，再更新max0，因为max1用到了上一个max0\\n            max1 = max(max1 + arr[i], max0)\\n            max0 = max(max0 + arr[i], arr[i])\\n            res = max(res, max0, max1)\\n        return res\\n\"\n        }\n    ]\n},\n\"sort-items-by-groups-respecting-dependencies\":{\n    \"id\": \"1203\",\n    \"name\": \"sort-items-by-groups-respecting-dependencies\",\n    \"pre\": [\n        {\n            \"text\": \"图论 - 拓扑排序\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        },\n        {\n            \"text\": \"BFS & DFS\",\n            \"link\": null,\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1203.sort-items-by-groups-respecting-dependencies.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1203.sort-items-by-groups-respecting-dependencies.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n    def tp_sort(self, items, indegree, neighbors):\\n        q = collections.deque([])\\n        ans = []\\n        for item in items:\\n            if not indegree[item]:\\n                q.append(item)\\n        while q:\\n            cur = q.popleft()\\n            ans.append(cur)\\n\\n            for neighbor in neighbors[cur]:\\n                indegree[neighbor] -= 1\\n                if not indegree[neighbor]:\\n                    q.append(neighbor)\\n\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def tp_sort(self, items: int, pres: List[List[int]]) -> List[int]:\\n        res = []\\n        visited = [0] * items\\n        adjacent = [[] for _ in range(items)]\\n\\n        def dfs(i):\\n            if visited[i] == 1:\\n                return False\\n            if visited[i] == 2:\\n                return True\\n            visited[i] = 1\\n            for j in adjacent[i]:\\n                if not dfs(j):\\n                    return False\\n\\n            visited[i] = 2\\n            res.append(i)\\n            return True\\n        for cur, pre in pres:\\n            adjacent[cur].append(pre)\\n        for i in range(items):\\n            if not dfs(i):\\n                return []\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nfor pre in pres[project]:\\n    if group[pre] != group[project]:\\n        # 小组关系图\\n        group_indegree[group[project]] += 1\\n        group_neighbors[group[pre]].append(group[project])\\n    else:\\n        # 项目关系图\\n        # ...\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def tp_sort(self, items, indegree, neighbors):\\n        q = collections.deque([])\\n        ans = []\\n        for item in items:\\n            if not indegree[item]:\\n                q.append(item)\\n        while q:\\n            cur = q.popleft()\\n            ans.append(cur)\\n\\n            for neighbor in neighbors[cur]:\\n                indegree[neighbor] -= 1\\n                if not indegree[neighbor]:\\n                    q.append(neighbor)\\n\\n        return ans\\n\\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\\n        max_group_id = m\\n        for project in range(n):\\n            if group[project] == -1:\\n                group[project] = max_group_id\\n                max_group_id += 1\\n\\n        project_indegree = collections.defaultdict(int)\\n        group_indegree = collections.defaultdict(int)\\n        project_neighbors = collections.defaultdict(list)\\n        group_neighbors = collections.defaultdict(list)\\n        group_projects = collections.defaultdict(list)\\n\\n        for project in range(n):\\n            group_projects[group[project]].append(project)\\n\\n            for pre in pres[project]:\\n                if group[pre] != group[project]:\\n                    # 小组关系图\\n                    group_indegree[group[project]] += 1\\n                    group_neighbors[group[pre]].append(group[project])\\n                else:\\n                    # 项目关系图\\n                    project_indegree[project] += 1\\n                    project_neighbors[pre].append(project)\\n\\n        ans = []\\n\\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\\n\\n        if len(group_queue) != max_group_id:\\n            return []\\n\\n        for group_id in group_queue:\\n\\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\\n\\n            if len(project_queue) != len(group_projects[group_id]):\\n                return []\\n            ans += project_queue\\n\\n        return ans\\n\"\n        }\n    ]\n},\n\"longest-arithmetic-subsequence-of-given-difference\":{\n    \"id\": \"1218\",\n    \"name\": \"longest-arithmetic-subsequence-of-given-difference\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"将`以每一个元素结尾的最长等差子序列的长度`统统存起来\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"腾讯\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1218.longest-arithmetic-subsequence-of-given-difference.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1218.longest-arithmetic-subsequence-of-given-difference.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n  def longestSubsequence(self, arr: List[int], difference: int) -> int:\\n        n = len(arr)\\n        res = 1\\n        for i in range(n):\\n            count = 1\\n            for j in range(i + 1, n):\\n                if arr[i] + difference * count == arr[j]:\\n                    count += 1\\n\\n                if count > res:\\n                    res = count\\n\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n#\\n# @lc app=leetcode.cn id=1218 lang=python3\\n#\\n# [1218] 最长定差子序列\\n#\\n\\n# @lc code=start\\n\\n\\nclass Solution:\\n\\n    # 动态规划\\n    def longestSubsequence(self, arr: List[int], difference: int) -> int:\\n        n = len(arr)\\n        res = 1\\n        dp = {}\\n        for num in arr:\\n            dp[num] = 1\\n            if num - difference in dp:\\n                dp[num] = dp[num - difference] + 1\\n\\n        return max(dp.values())\\n\\n# @lc code=end\\n\"\n        }\n    ]\n},\n\"airplane-seat-assignment-probability\":{\n    \"id\": \"1227\",\n    \"name\": \"airplane-seat-assignment-probability\",\n    \"pre\": [\n        {\n            \"text\": \"记忆化搜索\",\n            \"link\": null,\n            \"color\": \"lime\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1227.airplane-seat-assignment-probability.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1227.airplane-seat-assignment-probability.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def nthPersonGetsNthSeat(self, n: int) -> float:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 0.5\\n        res = 1 / n\\n        for i in range(2, n):\\n            res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    seen = {}\\n\\n    def nthPersonGetsNthSeat(self, n: int) -> float:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 0.5\\n        if n in self.seen:\\n            return self.seen[n]\\n        res = 1 / n\\n        for i in range(2, n):\\n            res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n\\n        self.seen[n] = res\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def nthPersonGetsNthSeat(self, n: int) -> float:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 0.5\\n\\n        dp = [1, .5] * n\\n\\n        for i in range(2, n):\\n            dp[i] = 1 / n\\n            for j in range(2, i):\\n                dp[i] += dp[i - j + 1] * 1 / n\\n        return dp[-1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def nthPersonGetsNthSeat(self, n: int) -> float:\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 0.5\\n\\n        dp = [1, .5] * n\\n\\n        for i in range(2, n):\\n            dp[i] = 1/n+(n-2)/n * dp[n-1]\\n        return dp[-1]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def nthPersonGetsNthSeat(self, n: int) -> float:\\n        return 1 if n == 1 else .5\\n\\n\"\n        }\n    ]\n},\n\"maximum-score-words-formed-by-letters\":{\n    \"id\": \"1255\",\n    \"name\": \"maximum-score-words-formed-by-letters\",\n    \"pre\": [\n        {\n            \"text\": \"回溯\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"回溯模板\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"计数\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1255.maximum-score-words-formed-by-letters.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1255.maximum-score-words-formed-by-letters.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxScoreWords(self, words, letters, score):\\n        ans = 0\\n\\n        def dfs(start, 当前的分数, counter):\\n            if start > len(words): return\\n            ans = max(ans, cur)\\n            for j in 循环start之后的单词:\\n                if 如果当前单词加进去还满足游戏规则:\\n                    dfs(j + 1, 新的分数, 新的counter)\\n\\n        dfs(0, 0, collections.Counter(letters))\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxScoreWords(self, words, letters, score):\\n        self.ans = 0\\n        words_score = [sum(score[ord(c)-ord('a')] for c in word) for word in words]\\n        words_counter = [collections.Counter(word) for word in words]\\n\\n        def backtrack(start, cur, counter):\\n            if start > len(words):\\n                return\\n            self.ans = max(self.ans, cur)\\n            for j, w_counter in enumerate(words_counter[start:], start):\\n                if all(n <= counter.get(c,0) for c,n in w_counter.items()):\\n                    backtrack(j+1, cur+words_score[j], counter-w_counter)\\n\\n        backtrack(0, 0, collections.Counter(letters))\\n        return self.ans\\n\"\n        }\n    ]\n},\n\"shift-2d-grid\":{\n    \"id\": \"1260\",\n    \"name\": \"shift-2d-grid\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md\",\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"数学\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1260.shift-2d-grid.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1260.shift-2d-grid.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfrom copy import deepcopy\\n\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        for _ in range(k):\\n            old = deepcopy(grid)\\n            for i in range(n):\\n                for j in range(m):\\n                    if j == m - 1:\\n                            grid[(i + 1) % n][0] = old[i][j]\\n                    elif i == n - 1 and j == m - 1:\\n                        grid[0][0] = old[i][j]\\n                    else:\\n                        grid[i][j + 1] = old[i][j]\\n        return grid\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n#\\n# @lc app=leetcode.cn id=1260 lang=python3\\n#\\n# [1260] 二维网格迁移\\n#\\n\\n# @lc code=start\\n\\n\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        # 二维到一维\\n        arr = [grid[i][j] for i in range(n) for j in range(m)]\\n        # 取模，缩小k的范围，避免无意义的运算\\n        k %= m * n\\n        res = []\\n        # 首尾交换法\\n\\n        def reverse(l, r):\\n            while l < r:\\n                t = arr[l]\\n                arr[l] = arr[r]\\n                arr[r] = t\\n                l += 1\\n                r -= 1\\n        # 三次旋转\\n        reverse(0, m * n - k - 1)\\n        reverse(m * n - k, m * n - 1)\\n        reverse(0, m * n - 1)\\n        # 一维到二维\\n        row = []\\n        for i in range(m * n):\\n            if i > 0 and i % m == 0:\\n                res.append(row)\\n                row = []\\n            row.append(arr[i])\\n        res.append(row)\\n\\n        return res\\n\\n# @lc code=end\\n\\n\"\n        }\n    ]\n},\n\"find-elements-in-a-contaminated-binary-tree\":{\n    \"id\": \"1261\",\n    \"name\": \"find-elements-in-a-contaminated-binary-tree\",\n    \"pre\": [\n        {\n            \"text\": \"二进制\",\n            \"link\": null,\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1261.find-elements-in-a-contaminated-binary-tree.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1261.find-elements-in-a-contaminated-binary-tree.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n    node = None\\n    def __init__(self, root: TreeNode):\\n        def recover(node):\\n            if not node:\\n                return node;\\n            if node.left:\\n                node.left.val =  2 * node.val + 1\\n            if node.right:\\n                 node.right.val = 2 * node.val + 2\\n            recover(node.left)\\n            recover(node.right)\\n            return node\\n        root.val = 0\\n        self.node = recover(root)\\n\\n\\n    def find(self, target: int) -> bool:\\n        def findInTree(node, target):\\n            if not node:\\n                return False\\n            if node.val == target:\\n                return True\\n            return findInTree(node.left, target) or findInTree(node.right, target)\\n        return findInTree(self.node, target)\\n\\n\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        # set 不能放在init外侧。 因为测试用例之间不会销毁FindElements的变量\\n        self.seen = set()\\n        def recover(node):\\n            if not node:\\n                return node;\\n            if node.left:\\n                node.left.val =  2 * node.val + 1\\n                self.seen.add(node.left.val)\\n            if node.right:\\n                 node.right.val = 2 * node.val + 2\\n                 self.seen.add(node.right.val)\\n            recover(node.left)\\n            recover(node.right)\\n            return node\\n        root.val = 0\\n        self.seen.add(0)\\n        self.node = recover(root)\\n\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.seen\\n\\n\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n    node = None\\n    def __init__(self, root: TreeNode):\\n        def recover(node):\\n            if not node:\\n                return node;\\n            if node.left:\\n                node.left.val =  2 * node.val + 1\\n            if node.right:\\n                 node.right.val = 2 * node.val + 2\\n            recover(node.left)\\n            recover(node.right)\\n            return node\\n        root.val = 0\\n        self.node = recover(root)\\n\\n\\n    def find(self, target: int) -> bool:\\n        node = self.node\\n        for bit in bin(target+1)[3:]:\\n            node = node and (node.left, node.right)[int(bit)]\\n        return bool(node)\\n\\n\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n\"\n        }\n    ]\n},\n\"greatest-sum-divisible-by-three\":{\n    \"id\": \"1262\",\n    \"name\": \"greatest-sum-divisible-by-three\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"回溯法\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"贪婪法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"状态机\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"数学分析\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        },\n        {\n            \"name\": \"网易有道\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1262.greatest-sum-divisible-by-three.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1262.greatest-sum-divisible-by-three.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        self.res = 0\\n        def backtrack(temp, start):\\n            total = sum(temp)\\n            if total % 3 == 0:\\n                self.res = max(self.res, total)\\n            for i in range(start, len(nums)):\\n                temp.append(nums[i])\\n                backtrack(temp, i + 1)\\n                temp.pop(-1)\\n\\n\\n        backtrack([], 0)\\n\\n        return self.res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        one = []\\n        two = []\\n        total = 0\\n\\n        for num in nums:\\n            total += num\\n            if num % 3 == 1:\\n                one.append(num)\\n            if num % 3 == 2:\\n                two.append(num)\\n        one.sort()\\n        two.sort()\\n        if total % 3 == 0:\\n            return total\\n        elif total % 3 == 1 and one:\\n            if len(two) >= 2 and one[0] > two[0] + two[1]:\\n                return total - two[0] - two[1]\\n            return total - one[0]\\n        elif total % 3 == 2 and two:\\n            if len(one) >= 2 and two[0] > one[0] + one[1]:\\n                return total - one[0] - one[1]\\n            return total - two[0]\\n        return 0\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        one = [float('inf')] * 2\\n        two = [float('inf')] * 2\\n        total = 0\\n\\n        for num in nums:\\n            total += num\\n            if num % 3 == 1:\\n                if num < one[0]:\\n                    t = one[0]\\n                    one[0] = num\\n                    one[1] = t\\n                elif num < one[1]:\\n                    one[1] = num\\n            if num % 3 == 2:\\n                if num < two[0]:\\n                    t = two[0]\\n                    two[0] = num\\n                    two[1] = t\\n                elif num < two[1]:\\n                    two[1] = num\\n        if total % 3 == 0:\\n            return total\\n        elif total % 3 == 1 and one:\\n            if len(two) >= 2 and one[0] > two[0] + two[1]:\\n                return total - two[0] - two[1]\\n            return total - one[0]\\n        elif total % 3 == 2 and two:\\n            if len(one) >= 2 and two[0] > one[0] + one[1]:\\n                return total - one[0] - one[1]\\n            return total - two[0]\\n        return 0\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        state = [0, float('-inf'), float('-inf')]\\n\\n        for num in nums:\\n            if num % 3 == 0:\\n                state = [state[0] + num, state[1] + num, state[2] + num]\\n            if num % 3 == 1:\\n                a = max(state[2] + num, state[0])\\n                b = max(state[0] + num, state[1])\\n                c = max(state[1] + num, state[2])\\n                state = [a, b, c]\\n            if num % 3 == 2:\\n                a = max(state[1] + num, state[0])\\n                b = max(state[2] + num, state[1])\\n                c = max(state[0] + num, state[2])\\n                state = [a, b, c]\\n        return state[0]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxSumDivThree(self, nums: List[int]) -> int:\\n        state = [0, float('-inf'), float('-inf')]\\n\\n        for num in nums:\\n            temp = [0] * 3\\n            for i in range(3):\\n                temp[(i + num) % 3] = max(state[(i + num) % 3], state[i] + num)\\n            state = temp\\n\\n        return state[0]\\n\"\n        }\n    ]\n},\n\"maximum-number-of-occurrences-of-a-substring\":{\n    \"id\": \"1297\",\n    \"name\": \"maximum-number-of-occurrences-of-a-substring\",\n    \"pre\": [\n        {\n            \"text\": \"字符串\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"识别题目干扰信息\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"看题目限制条件，对于本题有用的信息是`1<=maxLetters<=26`\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [\n        {\n            \"name\": \"字节跳动\"\n        }\n    ],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1297.maximum-number-of-occurrences-of-a-substring.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1297.maximum-number-of-occurrences-of-a-substring.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {\\n    Map<String, Integer> counter = new HashMap<>();\\n    int res = 0;\\n    for (int i = 0; i < s.length() - minSize + 1; i++) {\\n        String substr = s.substring(i, i + minSize);\\n        if (checkNum(substr, maxLetters)) {\\n            int newVal = counter.getOrDefault(substr, 0) + 1;\\n            counter.put(substr, newVal);\\n            res = Math.max(res, newVal);\\n        }\\n    }\\n    return res;\\n}\\npublic boolean checkNum(String substr, int maxLetters) {\\n    Set<Character> set = new HashSet<>();\\n    for (int i = 0; i < substr.length(); i++)\\n        set.add(substr.charAt(i));\\n    return set.size() <= maxLetters;\\n}\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        n = len(s)\\n        letters = set()\\n        cnts = dict()\\n        res = 0\\n        for i in range(n - minSize + 1):\\n            length = minSize\\n            while i + length <= n and length <= maxSize:\\n                t = s[i:i + length]\\n                for c in t:\\n                    if len(letters) > maxLetters:\\n                        break\\n                    letters.add(c)\\n                if len(letters) <= maxLetters:\\n                    cnts[t] = cnts.get(t, 0) + 1\\n                    res = max(res, cnts[t])\\n                letters.clear()\\n                length += 1\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n        counter, res = {}, 0\\n        for i in range(0, len(s) - minSize + 1):\\n            sub = s[i : i + minSize]\\n            if len(set(sub)) <= maxLetters:\\n                counter[sub] = counter.get(sub, 0) + 1\\n                res = max(res, counter[sub])\\n        return res;\\n\\n# @lc code=end\\n\"\n        }\n    ]\n},\n\"xor-queries-of-a-subarray\":{\n    \"id\": \"1310\",\n    \"name\": \"xor-queries-of-a-subarray\",\n    \"pre\": [\n        {\n            \"text\": \"前缀和\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/prefix.md\",\n            \"color\": \"cyan\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"异或的性质x^y^x=y\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"前缀表达式\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1310.xor-queries-of-a-subarray.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1310.xor-queries-of-a-subarray.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\n  public int[] xorQueries(int[] arr, int[][] queries) {\\n\\n        int[] preXor = new int[arr.length];\\n        preXor[0] = 0;\\n\\n        for (int i = 1; i < arr.length; i++)\\n            preXor[i] = preXor[i - 1] ^ arr[i - 1];\\n\\n        int[] res = new int[queries.length];\\n\\n        for (int i = 0; i < queries.length; i++) {\\n\\n            int left = queries[i][0], right = queries[i][1];\\n            res[i] = arr[right] ^ preXor[right] ^ preXor[left];\\n        }\\n\\n        return res;\\n    }\\n\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {\\n        vector<int>res;\\n        for(int i=1; i<arr.size(); ++i){\\n            arr[i]^=arr[i-1];\\n        }\\n        for(vector<int>temp :queries){\\n            if(temp[0]==0){\\n                res.push_back(arr[temp[1]]);\\n            }\\n            else{\\n                res.push_back(arr[temp[0]-1]^arr[temp[1]]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\\n \\t\\tres = []\\n        for (L, R) in queries:\\n            i = L\\n            xor = 0\\n            while i <= R:\\n                xor ^= arr[i]\\n                i += 1\\n            res.append(xor)\\n        return res\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n#\\n# @lc app=leetcode.cn id=1218 lang=python3\\n#\\n# [1218] 最长定差子序列\\n#\\n\\n# @lc code=start\\n\\n\\nclass Solution:\\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\\n\\t\\tpre = [0]\\n        res = []\\n        for i in range(len(arr)):\\n            pre.append(pre[i] ^ arr[i])\\n        for (L, R) in queries:\\n            res.append(pre[L] ^ pre[R + 1])\\n        return res\\n\\n# @lc code=end\\n\"\n        }\n    ]\n},\n\"remove-palindromic-subsequences\":{\n    \"id\": \"1332\",\n    \"name\": \"remove-palindromic-subsequences\",\n    \"pre\": [\n        {\n            \"text\": \"回文\",\n            \"link\": null,\n            \"color\": \"lime\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"注意审题目，一定要利用题目条件“只含有a和b两个字符”否则容易做的很麻烦\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1332.remove-palindromic-subsequences.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1332.remove-palindromic-subsequences.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int removePalindromeSub(String s) {\\n        if (\\\"\\\".equals(s)) {\\n            return 0;\\n        }\\n        if (s.equals(new StringBuilder(s).reverse().toString())) {\\n            return 1;\\n        }\\n        return 2;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def removePalindromeSub(self, s: str) -> int:\\n        if s == '':\\n            return 0\\n        def isPalindrome(s):\\n            l = 0\\n            r = len(s) - 1\\n            while l < r:\\n                if s[l] != s[r]:\\n                    return False\\n                l += 1\\n                r -= 1\\n            return True\\n        return 1 if isPalindrome(s) else 2\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def removePalindromeSub(self, s: str) -> int:\\n        if s == '':\\n            return 0\\n        return 1 if s == s[::-1] else 2\\n\\n\"\n        }\n    ]\n},\n\"find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance\":{\n    \"id\": \"1334\",\n    \"name\": \"find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"Floyd-Warshall\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\\n        # 构建dist矩阵\\n        dist = [[float('inf')] * n for _ in  range(n)]\\n        for i, j, w in edges:\\n            dist[i][j] = w\\n            dist[j][i] = w\\n        for i in range(n):\\n            dist[i][i] = 0\\n        for k in range(n):\\n            for i in range(n):\\n                for j in range(n):\\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\\n\\n        # 过滤\\n        res = 0\\n        minCnt = float('inf')\\n        for i in range(n):\\n            cnt = 0\\n            for d in dist[i]:\\n                if d <= distanceThreshold:\\n                    cnt += 1\\n            if cnt <= minCnt:\\n                minCnt = cnt\\n                res = i\\n        return res\\n\\n\\n\"\n        }\n    ]\n},\n\"find-the-longest-substring-containing-vowels-in-even-counts\":{\n    \"id\": \"1371\",\n    \"name\": \"find-the-longest-substring-containing-vowels-in-even-counts\",\n    \"pre\": [\n        {\n            \"text\": \"前缀和\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/prefix.md\",\n            \"color\": \"cyan\"\n        },\n        {\n            \"text\": \"状态压缩\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"前缀和\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"状态压缩\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int findTheLongestSubstring(String s) {\\n\\n        int len = s.length();\\n\\n        if (len == 0)\\n            return 0;\\n\\n        int[][] preSum = new int[len][5];\\n        int start = getIndex(s.charAt(0));\\n        if (start != -1)\\n            preSum[0][start]++;\\n\\n        // preSum\\n        for (int i = 1; i < len; i++) {\\n\\n            int idx = getIndex(s.charAt(i));\\n\\n            for (int j = 0; j < 5; j++) {\\n\\n                if (idx == j)\\n                    preSum[i][j] = preSum[i - 1][j] + 1;\\n                else\\n                    preSum[i][j] = preSum[i - 1][j];\\n            }\\n        }\\n\\n        for (int i = len - 1; i >= 0; i--) {\\n\\n            for (int j = 0; j < len - i; j++) {\\n                if (checkValid(preSum, s, j, i + j))\\n                    return i + 1;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n\\n    public boolean checkValid(int[][] preSum, String s, int left, int right) {\\n\\n        int idx = getIndex(s.charAt(left));\\n\\n        for (int i = 0; i < 5; i++)\\n            if (((preSum[right][i] - preSum[left][i] + (idx == i ? 1 : 0)) & 1) == 1)\\n                return false;\\n\\n        return true;\\n    }\\n    public int getIndex(char ch) {\\n\\n        if (ch == 'a')\\n            return 0;\\n        else if (ch == 'e')\\n            return 1;\\n        else if (ch == 'i')\\n            return 2;\\n        else if (ch == 'o')\\n            return 3;\\n        else if (ch == 'u')\\n            return 4;\\n        else\\n            return -1;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        for i in range(len(s), 0, -1):\\n            for j in range(len(s) - i + 1):\\n                sub = s[j:j + i]\\n                has_odd_vowel = False\\n                for vowel in ['a', 'e', 'i', 'o', 'u']:\\n                    if sub.count(vowel) % 2 != 0:\\n                        has_odd_vowel = True\\n                        break\\n                if not has_odd_vowel: return  i\\n        return 0\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    i_mapper = {\\n        \\\"a\\\": 0,\\n        \\\"e\\\": 1,\\n        \\\"i\\\": 2,\\n        \\\"o\\\": 3,\\n        \\\"u\\\": 4\\n    }\\n    def check(self, s, pre, l, r):\\n        for i in range(5):\\n            if s[l] in self.i_mapper and i == self.i_mapper[s[l]]: cnt = 1\\n            else: cnt = 0\\n            if (pre[r][i] - pre[l][i] + cnt) % 2 != 0: return False\\n        return True\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        n = len(s)\\n\\n        pre = [[0] * 5 for _ in range(n)]\\n\\n        # pre\\n        for i in range(n):\\n            for j in range(5):\\n                if s[i] in self.i_mapper and self.i_mapper[s[i]] == j:\\n                    pre[i][j] = pre[i - 1][j] + 1\\n                else:\\n                    pre[i][j] = pre[i - 1][j]\\n        for i in range(n - 1, -1, -1):\\n            for j in range(n - i):\\n                if self.check(s, pre, j, i + j):\\n                    return i + 1\\n        return 0\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def findTheLongestSubstring(self, s: str) -> int:\\n        mapper = {\\n            \\\"a\\\": 1,\\n            \\\"e\\\": 2,\\n            \\\"i\\\": 4,\\n            \\\"o\\\": 8,\\n            \\\"u\\\": 16\\n        }\\n        seen = {0: -1}\\n        res = cur = 0\\n\\n        for i in range(len(s)):\\n            if s[i] in mapper:\\n                cur ^= mapper.get(s[i])\\n            # 全部奇偶性都相同，相减一定都是偶数\\n            if cur in seen:\\n                res = max(res, i - seen.get(cur))\\n            else:\\n                seen[cur] = i\\n        return res\\n\\n\"\n        }\n    ]\n},\n\"design-a-stack-with-increment-operation\":{\n    \"id\": \"1381\",\n    \"name\": \"design-a-stack-with-increment-operation\",\n    \"pre\": [\n        {\n            \"text\": \"栈\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"前缀和\",\n            \"link\": null,\n            \"color\": \"cyan\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1381.design-a-stack-with-increment-operation.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1381.design-a-stack-with-increment-operation.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass CustomStack:\\n\\n    def __init__(self, size: int):\\n        self.st = []\\n        self.cnt = 0\\n        self.size = size\\n\\n    def push(self, x: int) -> None:\\n        if self.cnt < self.size:\\n            self.st.append(x)\\n            self.cnt += 1\\n\\n\\n    def pop(self) -> int:\\n        if self.cnt == 0: return -1\\n        self.cnt -= 1\\n        return self.st.pop()\\n\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(0, min(self.cnt, k)):\\n            self.st[i] += val\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass CustomStack:\\n\\n    def __init__(self, size: int):\\n        self.st = []\\n        self.cnt = 0\\n        self.size = size\\n        self.incrementals = [0] * size\\n\\n    def push(self, x: int) -> None:\\n        if self.cnt < self.size:\\n            self.st.append(x)\\n            self.cnt += 1\\n\\n\\n    def pop(self) -> int:\\n        if self.cnt == 0: return -1\\n        if self.cnt >= 2:\\n            self.incrementals[self.cnt - 2] += self.incrementals[self.cnt - 1]\\n        ans = self.st.pop() + self.incrementals[self.cnt - 1]\\n        self.incrementals[self.cnt - 1] = 0\\n        self.cnt -= 1\\n        return ans\\n\\n\\n    def increment(self, k: int, val: int) -> None:\\n            if self.cnt:\\n                self.incrementals[min(self.cnt, k) - 1] += val\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass CustomStack:\\n\\n    def __init__(self, size: int):\\n        self.st = []\\n        self.cnt = 0\\n        self.size = size\\n        self.incrementals = []\\n\\n    def push(self, x: int) -> None:\\n        if self.cnt < self.size:\\n            self.st.append(x)\\n            self.incrementals.append(0)\\n            self.cnt += 1\\n\\n\\n    def pop(self) -> int:\\n        if self.cnt == 0: return -1\\n        self.cnt -= 1\\n        if self.cnt >= 1:\\n            self.incrementals[-2] += self.incrementals[-1]\\n        return self.st.pop() + self.incrementals.pop()\\n\\n\\n    def increment(self, k: int, val: int) -> None:\\n        if self.incrementals:\\n            self.incrementals[min(self.cnt, k) - 1] += val\\n\"\n        }\n    ]\n},\n\"jump-game-iv\":{\n    \"id\": \"1435\",\n    \"name\": \"jump-game-iv\",\n    \"pre\": [\n        {\n            \"text\": \"BFS\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1435.jump-game-iv.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1435.jump-game-iv.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minJumps(self, A: List[int]) -> int:\\n        dic = collections.defaultdict(list)\\n        n = len(A)\\n\\n        for i, a in enumerate(A):\\n            dic[a].append(i)\\n        visited = set([0])\\n        q = collections.deque([0])\\n        steps = 0\\n\\n        while q:\\n            for _ in range(len(q)):\\n                i = q.popleft()\\n                visited.add(i)\\n                if i == n - 1: return steps\\n                for neibor in dic[A[i]] + [i - 1, i + 1]:\\n                    if 0 <= neibor < n and neibor not in visited:\\n                        q.append(neibor)\\n                # 剪枝\\n                dic[A[i]] = []\\n            steps += 1\\n        return -1\\n\"\n        }\n    ]\n},\n\"longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit\":{\n    \"id\": \"1438\",\n    \"name\": \"longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit\",\n    \"pre\": [\n        {\n            \"text\": \"有序集合\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"单调栈\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"维护一个有序数组，并通过二分法找到插入位置\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1438.longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1438.longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def longestSubarray(self, A: List[int], limit: int) -> int:\\n        d = []\\n        ans = 1\\n\\n        for i, a in enumerate(A):\\n            bisect.insort(d, a)\\n            if len(d) > 1:\\n                while d[-1] - d[0] > limit:\\n                    d.remove(A[i - len(d)+1])\\n                ans = max(ans, len(d))\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def longestSubarray(self, A: List[int], limit: int) -> int:\\n        d = SortedList()\\n        ans = 1\\n\\n        for i, a in enumerate(A):\\n            d.add(a)\\n            if len(d) > 1:\\n                while d[-1] - d[0] > limit:\\n                    d.remove(A[i - len(d)+1])\\n                ans = max(ans, len(d))\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def longestSubarray(self, A: List[int], limit: int) -> int:\\n        q1, q2 = collections.deque(), collections.deque()\\n        ans = 1\\n        i = 0\\n        for j, a in enumerate(A):\\n            while q1 and q1[-1] < a:\\n                q1.pop()\\n            q1.append(a)\\n            while q2 and q2[-1] > a:\\n                q2.pop()\\n            q2.append(a)\\n            while i < j and q1 and q2 and q1[0] - q2[0] > limit:\\n                if A[i] == q1[0]: q1.popleft()\\n                elif A[i] == q2[0]: q2.popleft()\\n                i += 1\\n            ans = max(ans, j - i + 1)\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"form-largest-integer-with-digits-that-add-up-to-target\":{\n    \"id\": \"1449\",\n    \"name\": \"form-largest-integer-with-digits-that-add-up-to-target\",\n    \"pre\": [\n        {\n            \"text\": \"数组\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        },\n        {\n            \"text\": \"背包问题\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1449.form-largest-integer-with-digits-that-add-up-to-target.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1449.form-largest-integer-with-digits-that-add-up-to-target.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in 0 to N:\\n    for j in 1 to V + 1:\\n        dp[j] = max(dp[j], dp[j - cost[i])\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in 1 to N + 1:\\n    # 这里是倒序的，原因在于这里是01背包。\\n    for j in V to 0:\\n        dp[j] = max(dp[j], dp[j - cost[i - 1])\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in 1 to N + 1:\\n    # 这里不是倒序，原因是我们这里是完全背包问题\\n    for j in 1 to V + 1:\\n        dp[j] = max(dp[j], dp[j - cost[i - 1])\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in 1 to N + 1:\\n    for j in V to 0:\\n        dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i - 1])\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in 1 to N + 1:\\n   for j in 1 to V + 1:\\n       dp[i][j] = max(dp[i - 1][j], dp[i][j - cost[i - 1])\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def largestNumber(self, cost: List[int], target: int) -> str:\\n        dp = [0] + [float('-inf')] * target\\n        for i in range(9, 0, -1):\\n            for j in range(1, target+1):\\n                if j >= cost[i - 1]:\\n                    dp[j] = max(dp[j], (dp[j-cost[i - 1]] * 10) + i)\\n        return str(dp[target]) if dp[target] > 0 else '0'\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in 1 to N + 1:\\n    for j in V to 0:\\n        ...\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor j in V to 0:\\n    for i in 1 to N + 1:\\n        ...\\n\\n\"\n        }\n    ]\n},\n\"parallel-courses-ii\":{\n    \"id\": \"1494\",\n    \"name\": \"parallel-courses-ii\",\n    \"pre\": [\n        {\n            \"text\": \"拓扑排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"枚举\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"位运算的枚举子集优化\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1494.parallel-courses-ii.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1494.parallel-courses-ii.md\",\n    \"code\": [\n        {\n            \"language\": \"js\",\n            \"text\": \"\\n// 外层枚举所有小于等于 x 的数\\nans = [];\\nfor (i = 1; i < 1 << n; i++) {\\n  if ((x | i) === x) ans.push(i);\\n}\\n// ans 就是所有非空子集\\n\"\n        },\n        {\n            \"language\": \"js\",\n            \"text\": \"\\nans = [];\\n// 外层枚举所有小于等于 x 的数\\nfor (i = x; i != 0; i = (i - 1) & x) {\\n  ans.push(i);\\n}\\n// ans 就是所有非空子集\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndp[i | sub] = min(dp[i | sub], dp[i] + 1)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:\\n        neighbors = collections.defaultdict(int)\\n        dp = [n] * (1 << n)\\n\\n        for fr, to in dependencies:\\n            neighbors[to - 1] |= 1 << (fr - 1)\\n        dp[0] = 0  # 启动 dp\\n        for i in range(1 << n):\\n            can = 0\\n            for j in range(n):\\n                if (i & neighbors[j]) == neighbors[j]:\\n                    can |= 1 << j\\n            # 已经学过的不能学\\n            can &= ~i\\n            sub = can\\n            while sub:\\n                if bin(sub).count(\\\"1\\\") <= k:\\n                    dp[i | sub] = min(dp[i | sub], dp[i] + 1)\\n                sub = (sub - 1) & can\\n        return dp[(1 << n) - 1]\\n\\n\\n\"\n        }\n    ]\n},\n\"find-a-value-of-a-mysterious-function-closest-to-target\":{\n    \"id\": \"1521\",\n    \"name\": \"find-a-value-of-a-mysterious-function-closest-to-target\",\n    \"pre\": [\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"识别出函数func满足某种单调性\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"采用合适的枚举方法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1521.find-a-value-of-a-mysterious-function-closest-to-target.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1521.find-a-value-of-a-mysterious-function-closest-to-target.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def closestToTarget(self, A: List[int], target: int) -> int:\\n        seen = set()\\n        ans = float('inf')\\n        for a in A:\\n            seen.add(a)\\n            t = set()\\n            # 类似滚动数组 此时的 seen 相当于 sub[i-1]\\n            for b in seen:\\n                yu = a & b\\n                ans = min(ans, abs(yu - target))\\n                t.add(yu)\\n            # 此时的 t 就是 sub[i]，我们需要更新回 seen\\n            seen = t\\n        return ans\\n\"\n        }\n    ]\n},\n\"minimum-number-of-increments-on-subarrays-to-form-a-target-array\":{\n    \"id\": \"1526\",\n    \"name\": \"minimum-number-of-increments-on-subarrays-to-form-a-target-array\",\n    \"pre\": [\n        {\n            \"text\": \"差分与前缀和\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"逆向思考\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"使用差分减少时间复杂度\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1526.minimum-number-of-increments-on-subarrays-to-form-a-target-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1526.minimum-number-of-increments-on-subarrays-to-form-a-target-array.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minNumberOperations(self, A: List[int]) -> int:\\n        d = [A[0]]\\n        ans = 0\\n\\n        for i in range(1, len(A)):\\n            d.append(A[i] - A[i-1])\\n        for a in d:\\n            ans += max(0, a)\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minNumberOperations(self, A: List[int]) -> int:\\n        ans = A[0]\\n        for i in range(1, len(A)):\\n            ans += max(0, A[i] - A[i-1])\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, A, size, K):\\n        N = len(A)\\n\\n        def possible(target):\\n            # 差分数组 d\\n            d = [0] * N\\n            moves = a = 0\\n            for i in range(N):\\n                # a 相当于差分数组 d 的前缀和\\n                a += d[i]\\n                # 当前值和 target 的差距\\n                delta = target - (A[i] + a)\\n                # 大于 0 表示不到 target，我们必须需要进行 +1 操作\\n                if delta > 0:\\n                    moves += delta\\n                    # 更新前缀和\\n                    a += delta\\n                    # 如果 i + size >= N 对应我上面提到的只修改左端点，不修改右端点的情况\\n                    if i + size < N:\\n                        d[i + size] -= delta\\n            # 执行的+1操作小于等于K 说明可行\\n            return moves <= K\\n        # 定义解空间\\n        lo, hi = min(A), max(A) + K\\n        # 最右二分模板\\n        while lo <= hi:\\n            mi = (lo + hi) // 2\\n            if possible(mi):\\n                lo = mi + 1\\n            else:\\n                hi = mi - 1\\n        return hi\\n\"\n        }\n    ]\n},\n\"minimum-numbers-of-function-calls-to-make-target-array\":{\n    \"id\": \"1558\",\n    \"name\": \"minimum-numbers-of-function-calls-to-make-target-array\",\n    \"pre\": [\n        {\n            \"text\": \"模拟\",\n            \"link\": null,\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"逆向思考\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"使用两个变量分别记录add和multi的次数\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"multi取决于整个数组最大的数，add取决于数组出现奇数的次数\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1558.minimum-numbers-of-function-calls-to-make-target-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1558.minimum-numbers-of-function-calls-to-make-target-array.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        max_multi = add = 0\\n\\n        for num in nums:\\n            # your code here\\n        return max_multi + add\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        max_multi = add = 0\\n\\n        for num in nums:\\n            multi = 0\\n            while num > 0:\\n                if num & 1 == 1:\\n                    add += 1\\n                    num -= 1\\n                if num >= 2:\\n                    multi += 1\\n                    num //= 2\\n\\n            max_multi = max(max_multi, multi)\\n        return max_multi + add\\n\\n\"\n        }\n    ]\n},\n\"shortest-subarray-to-be-removed-to-make-array-sorted\":{\n    \"id\": \"1574\",\n    \"name\": \"shortest-subarray-to-be-removed-to-make-array-sorted\",\n    \"pre\": [\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md \\\"滑动窗口\\\"\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"画图\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"边界条件的考察（比如+1\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"1等号）\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1574.shortest-subarray-to-be-removed-to-make-array-sorted.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1574.shortest-subarray-to-be-removed-to-make-array-sorted.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nans = cnt = 1\\nfor(int i = 1; i < A.length; i++ ) {\\n    if (A[i] >= A[i - 1]) {\\n        cnt++\\n    }\\n    else {\\n        ans = max(ans, cnt)\\n        cnt = 1\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"cpp\",\n            \"text\": \"\\nclass Solution {\\npublic:\\n    int findLengthOfShortestSubarray(vector<int>& A) {\\n        int N = A.size(), left = 0, right = N - 1;\\n        while (left + 1 < N && A[left] <= A[left + 1]) ++left;\\n        if (left == A.size() - 1) return 0;\\n        while (right > left && A[right - 1] <= A[right]) --right;\\n        int ans = min(N - left - 1, right), i = 0, j = right;\\n        while (i <= left && j < N) {\\n            if (A[j] >= A[i]) {\\n                ans = min(ans, j - i - 1);\\n                ++i;\\n            } else ++j;\\n        }\\n        return ans;\\n    }\\n};\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findLengthOfShortestSubarray(self, A: List[int]) -> int:\\n        n = len(A)\\n        l, r = 0, n - 1\\n\\n        while l < n - 1 and A[l] <= A[l + 1]:\\n            l += 1\\n        if l == n - 1:\\n            return 0\\n        while r > 0 and A[r] >= A[r - 1]:\\n            r -= 1\\n        ans = min(r, n - l - 1)\\n        i = 0\\n        while i <= l and r < n:\\n            if A[i] <= A[r]:\\n                # delete i + 1 ~ r - 1\\n                ans = min(ans, r - i - 1)\\n                i += 1\\n            else:\\n                # extend the sliding window\\n                r += 1\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"path-with-minimum-effort\":{\n    \"id\": \"1631\",\n    \"name\": \"path-with-minimum-effort\",\n    \"pre\": [\n        {\n            \"text\": \"二维矩阵\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"深度优先遍历\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/DFS.md\",\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"二分查找\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/91/binary-search.md\",\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1631.path-with-minimum-effort.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1631.path-with-minimum-effort.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nreturn dfs(i + 1, j, heights[i][j], target) or dfs(i - 1, j, heights[i][j], target) or dfs(i, j + 1, heights[i][j], target) or dfs(i, j - 1, heights[i][j], target)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ntop = dfs(i + 1, j, heights[i][j], target)\\nbottom = dfs(i - 1, j, heights[i][j], target)\\nright = dfs(i, j + 1, heights[i][j], target)\\nleft = dfs(i, j - 1, heights[i][j], target)\\nreturn top or bottom or right or left\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\\n        lo, hi = 0, 10**6 - 1\\n        m, n = len(heights), len(heights[0])\\n        def dfs(i, j, pre, target):\\n            if (i, j) in visited: return False\\n            if i < 0 or i >= m or j < 0 or j >= n or abs(heights[i][j] - pre) > target: return False\\n            if i == m - 1 and j == n - 1: return True\\n            visited.add((i, j))\\n            return dfs(i + 1, j, heights[i][j], target) or dfs(i - 1, j, heights[i][j], target) or dfs(i, j + 1, heights[i][j], target) or dfs(i, j - 1, heights[i][j], target)\\n        # 查找最右侧满足条件的值\\n        while lo <= hi:\\n            visited = set()\\n            mid = (lo + hi) >> 1\\n            if dfs(0, 0, heights[0][0], mid): hi = mid - 1\\n            else: lo = mid + 1\\n        return lo\\n\\n\"\n        }\n    ]\n},\n\"create-sorted-array-through-instructions\":{\n    \"id\": \"1649\",\n    \"name\": \"create-sorted-array-through-instructions\",\n    \"pre\": [\n        {\n            \"text\": \"二分法\",\n            \"link\": \"../91/binary-search.md\",\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"线段树\",\n            \"link\": \"https://oi-wiki.org/ds/seg/\",\n            \"color\": \"orange\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1649.create-sorted-array-through-instructions.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1649.create-sorted-array-through-instructions.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def createSortedArray(self, instructions: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        nums = []\\n        ans = 0\\n        # eg: 1 2 2 3\\n        for instruction in instructions:\\n            l = bisect.bisect_left(nums, instruction)\\n            r = bisect.bisect_right(nums, instruction)\\n            nums[l:l] = [instruction]\\n            ans = (ans + min(l, len(nums) - r - 1)) % mod\\n        return ans\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nnums.insert(l, instruction)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nnums[l:l] = [instruction]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n    upper = max(instructions)\\n    # 初始化线段树\\n    seg = SegmentTree(upper, 1)\\n    for instruction in instructions:\\n        # 进行两次查询\\n        l = seg.queryCount(1, instruction - 1)\\n        r = seg.queryCount(instruction + 1, upper)\\n        ans = (ans + min(l, r)) % mod\\n        # 进行一次更新\\n        seg.updateCount(instruction)\\n    return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass SegmentTree:\\n    def __init__(self, upper, lower):\\n        \\\"\\\"\\\"\\n        data:传入的数组\\n        \\\"\\\"\\\"\\n        self.lower = lower\\n        self.upper = upper\\n        #  申请4倍data长度的空间来存线段树节点\\n        self.tree = [0] * (4 * (upper - lower + 1))  # 索引i的左孩子索引为2i+1，右孩子为2i+2\\n\\n    # 本质就是一个自底向上的更新过程\\n    # 因此可以使用后序遍历，即在函数返回的时候更新父节点。\\n    def update(self, tree_index, l, r, index):\\n        \\\"\\\"\\\"\\n        tree_index:某个根节点索引\\n        l, r : 此根节点代表区间的左右边界\\n        index : 更新的值的索引\\n        \\\"\\\"\\\"\\n        if l > index or r < index:\\n            return\\n        self.tree[tree_index] += 1\\n        if l == r:\\n            return\\n        mid = (l + r) // 2\\n        left, right = tree_index * 2 + 1, tree_index * 2 + 2\\n        self.update(left, l, mid, index)\\n        self.update(right, mid + 1, r, index)\\n\\n    def updateCount(self, index: int):\\n        self.update(0, self.lower, self.upper, index)\\n\\n    def query(self, tree_index: int, l: int, r: int, ql: int, qr: int) -> int:\\n        \\\"\\\"\\\"\\n        递归查询区间[ql,..,qr]的值\\n        tree_index : 某个根节点的索引\\n        l, r : 该节点表示的区间的左右边界\\n        ql, qr: 待查询区间的左右边界\\n        \\\"\\\"\\\"\\n        if qr < l or ql > r:\\n            return 0\\n        # l 和 r 在 [ql, qr] 内\\n        if ql <= l and qr >= r:\\n            return self.tree[tree_index]\\n        mid = (l + r) // 2\\n        left, right = tree_index * 2 + 1, tree_index * 2 + 2\\n        return self.query(left, l, mid, ql, qr) + self.query(right, mid + 1, r, ql, qr)\\n\\n    def queryCount(self, ql: int, qr: int) -> int:\\n        \\\"\\\"\\\"\\n        返回区间[ql,..,qr]的计数信息\\n        \\\"\\\"\\\"\\n        return self.query(0, self.lower, self.upper, ql, qr)\\n\\n\\nclass Solution:\\n    def createSortedArray(self, instructions: List[int]) -> int:\\n        mod = 10 ** 9 + 7\\n        ans = 0\\n        # eg: 1 2 2 3\\n        upper = max(instructions)\\n        seg = SegmentTree(upper, 1)\\n        for instruction in instructions:\\n            l = seg.queryCount(1, instruction - 1)\\n            r = seg.queryCount(instruction + 1, upper)\\n            ans = (ans + min(l, r)) % mod\\n            seg.updateCount(instruction)\\n        return ans\\n\"\n        }\n    ]\n},\n\"minimum-operations-to-reduce-x-to-zero\":{\n    \"id\": \"1658\",\n    \"name\": \"minimum-operations-to-reduce-x-to-zero\",\n    \"pre\": [\n        {\n            \"text\": \"堆\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"滑动窗口\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md\",\n            \"color\": \"purple\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1658.minimum-operations-to-reduce-x-to-zero.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1658.minimum-operations-to-reduce-x-to-zero.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        # 看数据范围，这种方法铁定超时（指数复杂度）\\n        h = [(0, 0, len(nums) - 1, x)]\\n        while h:\\n            moves,l,r,remain = heapq.heappop(h)\\n            if remain == 0: return moves\\n            if l + 1 < len(nums): heapq.heappush(h, (moves + 1, l + 1,r, remain-nums[l]))\\n            if r > 0: heapq.heappush(h, (moves + 1, l,r-1, remain-nums[r]))\\n        return -1\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        n = len(nums)\\n\\n        @lru_cache(None)\\n        def dp(l, r, x):\\n            if x == 0:\\n                return 0\\n            if x < 0 or r < 0 or l > len(nums) - 1:\\n                return n + 1\\n            return 1 + min(dp(l + 1, r, x - nums[l]), dp(l, r - 1, x - nums[r]))\\n\\n        ans = dp(0, len(nums) - 1, x)\\n        return -1 if ans > n else ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minOperations(self, nums: List[int], x: int) -> int:\\n        # 逆向求解，滑动窗口\\n        i = 0\\n        target = sum(nums) - x\\n        win = 0\\n        ans = len(nums)\\n        if target == 0: return ans\\n        for j in range(len(nums)):\\n            win += nums[j]\\n            while i < j and win > target:\\n                win -= nums[i]\\n                i += 1\\n            if win == target:\\n                ans = min(ans, len(nums) - (j - i + 1))\\n        return -1 if ans == len(nums) else ans\\n\\n\"\n        }\n    ]\n},\n\"minimum-number-of-removals-to-make-mountain-array\":{\n    \"id\": \"1671\",\n    \"name\": \"minimum-number-of-removals-to-make-mountain-array\",\n    \"pre\": [\n        {\n            \"text\": \"最长上升子序列\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1671.minimum-number-of-removals-to-make-mountain-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1671.minimum-number-of-removals-to-make-mountain-array.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minimumMountainRemovals(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = n\\n        def LIS(A):\\n            d = []\\n            for a in A:\\n                i = bisect.bisect_left(d, a)\\n                if i < len(d):\\n                    d[i] = a\\n                elif not d or d[-1] < a:\\n                    d.append(a)\\n            return d.index(A[-1])\\n\\n        for i in range(1, n-1):\\n            l, r = LIS(nums[:i+1]), LIS(nums[i:][::-1])\\n            if not l or not r: continue\\n            ans = min(ans, n - 1 - l - r)\\n        return ans\\n\"\n        }\n    ]\n},\n\"checking-existence-of-edge-length-limited-paths\":{\n    \"id\": \"1697\",\n    \"name\": \"checking-existence-of-edge-length-limited-paths\",\n    \"pre\": [\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"并查集\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md\",\n            \"color\": \"volcano\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"离线查询优化\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1697.checking-existence-of-edge-length-limited-paths.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1697.checking-existence-of-edge-length-limited-paths.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass UF:\\n    parent = {}\\n    size = {}\\n    cnt = 0\\n    def __init__(self, M):\\n        # 初始化 parent，size 和 cnt\\n        for i in range(M):\\n            self.parent[i] = i\\n            self.size[i] = 1\\n\\n    def find(self, x):\\n        while x != self.parent[x]:\\n            x = self.parent[x]\\n            # 路径压缩\\n            self.parent[x] = self.parent[self.parent[x]];\\n        return x\\n    def union(self, p, q):\\n        if self.connected(p, q): return\\n        # 小的树挂到大的树上， 使树尽量平衡\\n        leader_p = self.find(p)\\n        leader_q = self.find(q)\\n        if self.size[leader_p] < self.size[leader_q]:\\n            self.parent[leader_p] = leader_q\\n            self.size[leader_p] += self.size[leader_q]\\n        else:\\n            self.parent[leader_q] = leader_p\\n            self.size[leader_q] += self.size[leader_p]\\n        self.cnt -= 1\\n    def connected(self, p, q):\\n        return self.find(p) == self.find(q)\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        m = len(queries)\\n        edgeList.sort(key=lambda a:a[2])\\n        queries = [(fr, to, w, i) for i, [fr, to, w] in enumerate(queries)]\\n        queries.sort(key=lambda a:a[2])\\n        ans = [False] * m\\n        uf = UF(n)\\n        j = 0\\n        for fr, to, w, i in queries:\\n            while j < len(edgeList) and edgeList[j][2] < w:\\n                uf.union(edgeList[j][0], edgeList[j][1])\\n                j += 1\\n            if uf.connected(fr, to): ans[i] = True\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"change-minimum-characters-to-satisfy-one-of-three-conditions\":{\n    \"id\": \"1737\",\n    \"name\": \"change-minimum-characters-to-satisfy-one-of-three-conditions\",\n    \"pre\": [\n        {\n            \"text\": \"计数\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"枚举\",\n            \"link\": null,\n            \"color\": \"magenta\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"使用一个长度为26的数组计数不仅性能比哈希表好，并且在这里代码书写会更简单\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/1737.change-minimum-characters-to-satisfy-one-of-three-conditions.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/1737.change-minimum-characters-to-satisfy-one-of-three-conditions.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n        # 枚举 A 的最大字母\\n        for i in range(1, 26):\\n            t = 0\\n            # 大于等于 i 的所有字符都需要进行一次操作\\n            for j in range(i, 26):\\n                t += counter_A[j]\\n            # 小于 i 的所有字符都需要进行一次操作\\n            for j in range(i):\\n                t += counter_B[j]\\n            # 枚举的所有情况中取最小的\\n            ans = min(ans, t)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfor i in range(26):\\n     ans = min(ans, len(A) + len(B) - counter_A[i] - counter_B[i])\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def minCharacters(self, A: str, B: str) -> int:\\n        counter_A = [0] * 26\\n        counter_B = [0] * 26\\n        for a in A:\\n            counter_A[ord(a) - ord('a')] += 1\\n        for b in B:\\n            counter_B[ord(b) - ord('a')] += 1\\n        ans = len(A) + len(B)\\n        for i in range(26):\\n            ans = min(ans, len(A) + len(B) - counter_A[i] - counter_B[i])\\n        for i in range(1, 26):\\n            t = 0\\n            for j in range(i, 26):\\n                t += counter_A[j]\\n            for j in range(i):\\n                t += counter_B[j]\\n            ans = min(ans, t)\\n        for i in range(1, 26):\\n            t = 0\\n            for j in range(i, 26):\\n                t += counter_B[j]\\n            for j in range(i):\\n                t += counter_A[j]\\n            ans = min(ans, t)\\n        return ans\\n\\n\\n\"\n        }\n    ]\n},\n\"maximum-xor-with-an-element-from-array\":{\n    \"id\": \"5640\",\n    \"name\": \"maximum-xor-with-an-element-from-array\",\n    \"pre\": [\n        {\n            \"text\": \"异或\",\n            \"link\": null,\n            \"color\": \"geekblue\"\n        },\n        {\n            \"text\": \"位运算\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"剪枝\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"双指针\",\n            \"link\": null,\n            \"color\": \"green\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/5640.maximum-xor-with-an-element-from-array.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/5640.maximum-xor-with-an-element-from-array.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        def solve(x, m, s, e):\\n            if nums[0] > m: return -1\\n            max_v = 0\\n            for i in range(31, -1, -1):\\n                if nums[s] & (1<<i) == nums[e] & (1<<i):\\n                    max_v += nums[s] & (1<<i)\\n                elif nums[dp[i][e]] <= m and x ^ nums[s] < x ^ nums[e]:\\n                    max_v += nums[e] & (1<<i)\\n                    # 直接移动较小指针（s）到 dp[i][e]，其他不可能是答案\\n                    s = dp[i][e]\\n                else:\\n                    max_v += nums[s] & (1<<i)\\n                    # 直接移动较小指针（e）到 dp[i][e] - 1，其他不可能是答案\\n                    e = dp[i][e] - 1\\n\\n            return max_v ^ x\\n\\n        nums.sort()\\n        n = len(nums)\\n        #  dp[i][j] 是和 nums[j] 第 i 位相等的最小的数组下标\\n        dp = [[0 for _ in range(n)] for _ in range(32)]\\n        for i in range(32):\\n            for j in range(n):\\n                if j == 0 or (nums[j] & (1<<i)) != (nums[j-1] & (1<<i)): dp[i][j] = j\\n                else: dp[i][j] = dp[i][j-1]\\n        return [solve(x, m, 0, n-1) for x,m in queries]\\n\"\n        }\n    ]\n},\n\"md\":{\n    \"id\": \"Kth-Pair-Distance\",\n    \"name\": \"md\",\n    \"pre\": [\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/Kth-Pair-Distance.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/Kth-Pair-Distance.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, A, k):\\n        A.sort()\\n        h = [(A[i] - A[i-1], i-1,i) for i in range(1, len(A))]\\n        heapq.heapify(h)\\n\\n        while True:\\n            top, i, j = heapq.heappop(h)\\n            if not k: return top\\n            k -= 1\\n            if j + 1 < len(A): heapq.heappush(h, (A[j+1] - A[i], i, j + 1))\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, A, k):\\n        A.sort()\\n        def count_not_greater(diff):\\n            i = ans = 0\\n            for j in range(1, len(A)):\\n                while A[j] - A[i] > diff:\\n                    i += 1\\n                ans += j - i\\n            return ans\\n        l, r = 0, A[-1] - A[0]\\n\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if count_not_greater(mid) > k:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n\"\n        }\n    ]\n},\n\"md\":{\n    \"id\": \"Minimum-Light-Radius\",\n    \"name\": \"md\",\n    \"pre\": [\n        {\n            \"text\": \"排序\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/Minimum-Light-Radius.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/Minimum-Light-Radius.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ndef possible(diameter):\\n    start = nums[0]\\n    end = start + diameter\\n    for i in range(LIGHTS):\\n        idx = bisect_right(nums, end)\\n        if idx >= N:\\n            return True\\n        start = nums[idx]\\n        end = start + diameter\\n    return False\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, nums):\\n        nums.sort()\\n        N = len(nums)\\n        if N <= 3:\\n            return 0\\n        LIGHTS = 3\\n        # 这里使用的是直径，因此最终返回需要除以 2\\n        def possible(diameter):\\n            start = nums[0]\\n            end = start + diameter\\n            for i in range(LIGHTS):\\n                idx = bisect_right(nums, end)\\n                if idx >= N:\\n                    return True\\n                start = nums[idx]\\n                end = start + diameter\\n            return False\\n\\n        l, r = 0, nums[-1] - nums[0]\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if possible(mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l / 2\\n\"\n        }\n    ]\n},\n\"md\":{\n    \"id\": \"Number-Stream-to-Intervals\",\n    \"name\": \"md\",\n    \"pre\": [\n        {\n            \"text\": \"哈希表\",\n            \"link\": null,\n            \"color\": \"gold\"\n        },\n        {\n            \"text\": \"有序哈希表\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/Number-Stream-to-Intervals.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/Number-Stream-to-Intervals.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ns.add(1)\\ns.add(3)\\ns.add(2)\\ns.add(9)\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ns.add(1) # [ [1,1] ]\\ns.add(3) # [ [1,1], [3,3] ]\\ns.add(2) # [ [1,1], [2,2], [3,3] ] 可合并为 [ [1,3] ]\\ns.add(9) # [ [1,3], [9,9] ]\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfrom sortedcontainers import SortedDict\\n\\n\\nclass StreamSummary:\\n    def __init__(self):\\n        self.start = SortedDict()\\n        self.end = SortedDict()\\n\\n    def add(self, val):\\n        if val - 1 in self.end and val + 1 in self.start:\\n            # [a, val-1] + [val,val] + [val+1, b] -> [a, b]\\n            self.end[self.start[val + 1]] = self.end[val - 1]\\n            self.start[self.end[val - 1]] = self.start[val + 1]\\n            del self.start[val + 1]\\n            del self.end[val - 1]\\n        elif val - 1 in self.end:\\n            # [a, val -1] + [val, val] -> [a, val]\\n            self.end[val] = self.end[val - 1]\\n            self.start[self.end[val]] = val\\n            del self.end[val - 1]\\n        elif val + 1 in self.start:\\n            # [val,val] + [val+1, b] -> [val, b]\\n            self.start[val] = self.start[val + 1]\\n            self.end[self.start[val]] = val\\n            del self.start[val + 1]\\n        else:\\n            self.start[val] = val\\n            self.end[val] = val\\n\\n    def get(self):\\n        # iterate start or end get same correct answer\\n        ans = []\\n        for s, e in self.start.items():\\n            ans.append([s, e])\\n        return ans\\n\\n\"\n        }\n    ]\n},\n\"md\":{\n    \"id\": \"Triple-Inversion\",\n    \"name\": \"md\",\n    \"pre\": [\n        {\n            \"text\": \"二分法\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/Triple-Inversion.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/Triple-Inversion.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, A):\\n        ans = 0\\n        for i in range(len(A)):\\n            for j in range(i+1,len(A)):\\n                if A[i] > A[j] * 3: ans += 1\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nd = []\\nfor a in A:\\n    bisect.insort(d, a)\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, A):\\n        d = []\\n        ans = 0\\n\\n        for a in A:\\n            i = bisect.bisect_right(d, a * 3)\\n            ans += len(d) - i\\n            bisect.insort(d, a)\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def solve(self, A):\\n        d = SortedList()\\n        ans = 0\\n\\n        for a in A:\\n            i = d.bisect_right(a * 3)\\n            ans += len(d) - i\\n            d.add(a)\\n        return ans\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\ndef mergeTwo(nums1, nums2):\\n    res = []\\n    i = j = 0\\n    while i < len(nums1) and j < len(nums2):\\n        if nums1[i] < nums[j]:\\n            res.append(nums[i])\\n            i += 1\\n        else:\\n            res.append(nums[j])\\n            j += 1\\n    while i < len(nums1) :\\n        res.append(num[i])\\n        i += 1\\n    while j < len(nums1) :\\n        res.append(num[j])\\n        j += 1\\n    return res\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, nums: List[int]) -> int:\\n        self.cnt = 0\\n        def merge(nums, start, mid, end):\\n            i, j, temp = start, mid + 1, []\\n            while i <= mid and j <= end:\\n                if nums[i] <= nums[j]:\\n                    temp.append(nums[i])\\n                    i += 1\\n                else:\\n                    self.cnt += mid - i + 1\\n                    temp.append(nums[j])\\n                    j += 1\\n            while i <= mid:\\n                temp.append(nums[i])\\n                i += 1\\n            while j <= end:\\n                temp.append(nums[j])\\n                j += 1\\n\\n            for i in range(len(temp)):\\n                nums[start + i] = temp[i]\\n\\n\\n        def mergeSort(nums, start, end):\\n            if start >= end: return\\n            mid = (start + end) >> 1\\n            mergeSort(nums, start, mid)\\n            mergeSort(nums, mid + 1, end)\\n            merge(nums, start, mid,  end)\\n        mergeSort(nums, 0, len(nums) - 1)\\n        return self.cnt\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def solve(self, nums) -> int:\\n        self.cnt = 0\\n        def merge(nums, start, mid, end, temp):\\n            i, j = start, mid + 1\\n            while i <= mid and j <= end:\\n                if nums[i] <=  nums[j]:\\n                    temp.append(nums[i])\\n                    i += 1\\n                else:\\n                    temp.append(nums[j])\\n                    j += 1\\n            # 防住\\n            # 这里代码开始\\n            ti, tj = start, mid + 1\\n            while ti <= mid and tj <= end:\\n                if nums[ti] <=  3 * nums[tj]:\\n                    ti += 1\\n                else:\\n                    self.cnt += mid - ti + 1\\n                    tj += 1\\n            # 这里代码结束\\n            while i <= mid:\\n                temp.append(nums[i])\\n                i += 1\\n            while j <= end:\\n                temp.append(nums[j])\\n                j += 1\\n            for i in range(len(temp)):\\n                nums[start + i] = temp[i]\\n            temp.clear()\\n\\n\\n        def mergeSort(nums, start, end, temp):\\n            if start >= end: return\\n            mid = (start + end) >> 1\\n            mergeSort(nums, start, mid, temp)\\n            mergeSort(nums, mid + 1, end, temp)\\n            merge(nums, start, mid,  end, temp)\\n        mergeSort(nums, 0, len(nums) - 1, [])\\n        return self.cnt\\n\"\n        }\n    ]\n},\n\"md\":{\n    \"id\": \"binode-lcci\",\n    \"name\": \"md\",\n    \"pre\": [\n        {\n            \"text\": \"二叉查找树\",\n            \"link\": null,\n            \"color\": \"purple\"\n        },\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"二叉树的遍历\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/binary-tree-traversal.md\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"指针操作\",\n            \"link\": null,\n            \"color\": \"blue\"\n        },\n        {\n            \"text\": \"返回值的处理\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/binode-lcci.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/binode-lcci.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\ncur.left = None\\npre.right = cur\\npre = cur\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nself.pre = None\\ndef dfs(root):\\n    dfs(root.left)\\n    # 上面的指针改变逻辑写到这里\\n    self.pre = root\\n    dfs(root.right)\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nself.pre = self.ans = TreeNode(-1)\\ndef dfs(root):\\n   if not root: return\\n   dfs(root.left)\\n   root.left = None\\n   self.pre.right = root\\n   # 当第一次执行到下面这一行代码，恰好是在最左下角， 这个时候 self.pre = root 就切断了 self.pre 和 self.ans 的联系\\n   # 之后 self.pre 的变化都不会体现到 self.ans 上。\\n   # 直观上来说就是 self.ans 在遍历到最左下角的时候下车了，而 self.pre 还在车上\\n   # 因此最后返回 self.ans.right 即可\\n   self.pre = root\\n   dfs(root.right)\\ndfs(root)\\nreturn self.ans.right\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def convertBiNode(self, root):\\n        self.pre = self.ans = TreeNode(-1)\\n        def dfs(root):\\n            if not root: return\\n            dfs(root.left)\\n            root.left = None\\n            self.pre.right = root\\n            self.pre = root\\n            dfs(root.right)\\n        dfs(root)\\n        return self.ans.right\\n\\n\"\n        }\n    ]\n},\n\"md\":{\n    \"id\": \"get-kth-magic-number-lcci\",\n    \"name\": \"md\",\n    \"pre\": [\n        {\n            \"text\": \"堆\",\n            \"link\": null,\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"状态机\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"去重\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/get-kth-magic-number-lcci.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/get-kth-magic-number-lcci.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nfrom heapq import heappop, heappush\\nclass Solution:\\n    def getKthMagicNumber(self, k: int) -> int:\\n        heap = [1]\\n        numbers = set()\\n        # 每次从小顶堆取一个， 取 k 次即可\\n        while k:\\n            cur = heappop(heap)\\n            if cur not in numbers:\\n                k -= 1\\n                heappush(heap, cur * 3)\\n                heappush(heap, cur * 5)\\n                heappush(heap, cur * 7)\\n            numbers.add(cur)\\n        return cur\\n\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def getKthMagicNumber(self, k: int) -> int:\\n        p3 = p5 = p7 = 0\\n        state = [1] + [0] * (k - 1)\\n\\n        for i in range(1, k):\\n            state[i] = min(state[p3] * 3, state[p5] * 5, state[p7] * 7)\\n            if 3 * state[p3] == state[i]: p3 += 1\\n            if 5 * state[p5] == state[i]: p5 += 1\\n            if 7 * state[p7] == state[i]: p7 += 1\\n        return state[-1]\\n\"\n        }\n    ]\n},\n\"meChtZ\":{\n    \"id\": \"lcp20\",\n    \"name\": \"meChtZ\",\n    \"pre\": [\n        {\n            \"text\": \"递归\",\n            \"link\": null,\n            \"color\": \"orange\"\n        },\n        {\n            \"text\": \"回溯\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/backtrack.md\",\n            \"color\": \"green\"\n        },\n        {\n            \"text\": \"动态规划\",\n            \"link\": null,\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [\n        {\n            \"text\": \"逆向思维\",\n            \"link\": null,\n            \"color\": \"blue\"\n        }\n    ],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/lcp20.meChtZ.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/lcp20.meChtZ.md\",\n    \"code\": [\n        {\n            \"language\": \"py\",\n            \"text\": \"\\n\\nclass Solution:\\n    def busRapidTransit(self, target: int, inc: int, dec: int, jumps: List[int], cost: List[int]) -> int:\\n        @lru_cache(None)\\n        def dfs(pos):\\n            if pos == 0: return 0\\n            if pos == 1: return inc\\n            ans = pos * inc\\n            for i, jump in enumerate(jumps):\\n                pre_pos, left = pos // jump, pos % jump\\n                if left == 0: ans = min(ans, cost[i] + dfs(pre_pos))\\n                else: ans = min(ans, cost[i] + dfs(pre_pos) + inc * left, cost[i] + dfs(pre_pos + 1) + dec * (jump - left))\\n            return ans\\n        return dfs(target) % 1000000007\\n\\n\"\n        }\n    ]\n},\n\"md\":{\n    \"id\": \"max-black-square-lcci\",\n    \"name\": \"md\",\n    \"pre\": [\n        {\n            \"text\": \"动态规划\",\n            \"link\": \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md \\\"动态规划\\\"\",\n            \"color\": \"red\"\n        }\n    ],\n    \"keyPoints\": [],\n    \"companies\": [],\n    \"giteeSolution\": \"https://gitee.com/golong/leetcode/blob/master/problems/max-black-square-lcci.md\",\n    \"solution\": \"https://github.com/azl397985856/leetcode/blob/master/problems/max-black-square-lcci.md\",\n    \"code\": [\n        {\n            \"language\": \"java\",\n            \"text\": \"\\nclass Solution {\\n    public int[] findSquare(int[][] matrix) {\\n        int [] res = new int [0];\\n        int [][][] dp = new int [2][matrix.length+1][matrix[0].length+1];\\n        int max = 0\\n        for(int i=1;i<=matrix.length;i++){\\n            for(int j=1;j<=matrix[0].length;j++){\\n                if(matrix[i-1][j-1]==0){\\n                    dp[0][i][j] = dp[0][i-1][j]+1;\\n                    dp[1][i][j] = dp[1][i][j-1]+1;\\n                    int bound = Math.min(dp[0][i][j], dp[1][i][j]);\\n                    for(int k=0;k<bound;k++){\\n                        if(dp[1][i-k][j]>=k+1&&dp[0][i][j-k]>=k+1){\\n                            if(k+1>max){\\n                                res = new int [3];\\n                                max = k+1;\\n                                res[0] = i-k-1;\\n                                res[1] = j-k-1;\\n                                res[2] = max;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\"\n        },\n        {\n            \"language\": \"py\",\n            \"text\": \"\\nclass Solution:\\n    def findSquare(self, matrix: List[List[int]]) -> List[int]:\\n        n = len(matrix)\\n        dp = [[[0, 0] for _ in range(n + 1)] for _ in range(n + 1)]\\n        ans = []\\n        for i in range(1, n + 1):\\n            for j in range(1, n + 1):\\n                if matrix[i - 1][j - 1] == 0:\\n                    dp[i][j][0] = dp[i-1][j][0] + 1\\n                    dp[i][j][1] = dp[i][j-1][1] + 1\\n                    upper = min(dp[i][j][0], dp[i][j][1])\\n                    for k in range(upper):\\n                        if min(dp[i-k][j][1], dp[i][j-k][0]) >= k + 1:\\n                            if not ans or k + 1 > ans[2]:\\n                                ans = [i-k-1, j-k-1, k + 1]\\n\\n        return ans\\n\"\n        }\n    ]\n},\n\n     }\n   ","/* eslint-disable */\nimport { db_collection } from \"./root.db\";\n\n// const tags = {\n//   dp: {\n//     id: \"dp\",\n//     text: \"动态规划\",\n//     color: \"cyan\",\n//     link:\n//       \"https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md\",\n//   },\n//   recursion: {\n//     id: \"recursion\",\n//     text: \"递归\",\n//     color: \"#f50\",\n//     link: null,\n//   },\n//   queue: {\n//     id: \"queue\",\n//     text: \"队列\",\n//     color: \"#108ee9\",\n//     link: null,\n//   },\n\n//   stack: {\n//     id: \"stack\",\n//     color: \"#87d068\",\n//     text: \"栈\",\n//     link: null,\n//   },\n//   design: {\n//     id: \"design\",\n//     color: \"#2db7f5\",\n//     text: \"设计题\",\n//     link: null,\n//   },\n// };\n\nconst company = {};\nconst selected = {\n  \"remove-duplicate-letters\": {\n    id: 316,\n    name: \"remove-duplicate-letters\",\n    title: \"一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/a-deleted.md\",\n  },\n  \"create-maximum-number\": {\n    id: 321,\n    name: \"create-maximum-number\",\n    title: \"一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/a-deleted.md\",\n  },\n  \"remove-k-digits\": {\n    id: 402,\n    name: \"remove-k-digits\",\n    title: \"一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/a-deleted.md\",\n  },\n  \"smallest-subsequence-of-distinct-characters\": {\n    id: 1081,\n    name: \"smallest-subsequence-of-distinct-characters\",\n    title: \"一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/a-deleted.md\",\n  },\n  \"unique-substrings-in-wraparound-string\": {\n    id: 467,\n    name: \"unique-substrings-in-wraparound-string\",\n    title: \"【西法的刷题秘籍】一次搞定前缀和\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/atMostK.md\",\n  },\n  \"number-of-subarrays-with-bounded-maximum\": {\n    id: 795,\n    name: \"number-of-subarrays-with-bounded-maximum\",\n    title: \"【西法的刷题秘籍】一次搞定前缀和\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/atMostK.md\",\n  },\n  \"fruit-into-baskets\": {\n    id: 904,\n    name: \"fruit-into-baskets\",\n    title: \"【西法的刷题秘籍】一次搞定前缀和\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/atMostK.md\",\n  },\n  \"subarrays-with-k-different-integers\": {\n    id: 992,\n    name: \"subarrays-with-k-different-integers\",\n    title: \"【西法的刷题秘籍】一次搞定前缀和\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/atMostK.md\",\n  },\n  \"corporate-flight-bookings\": {\n    id: 1109,\n    name: \"corporate-flight-bookings\",\n    title: \"【西法的刷题秘籍】一次搞定前缀和\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/atMostK.md\",\n  },\n  \"serialize-and-deserialize-bst\": {\n    id: 449,\n    name: \"serialize-and-deserialize-bst\",\n    title: \"一文带你看懂二叉树的序列化\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/serialize.md\",\n  },\n  \"serialize-and-deserialize-binary-tree\": {\n    id: 297,\n    name: \"serialize-and-deserialize-binary-tree\",\n    title: \"一文带你看懂二叉树的序列化\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/serialize.md\",\n  },\n\n  \"longest-increasing-subsequence\": {\n    id: 300,\n    name: \"longest-increasing-subsequence\",\n    title: \"穿上衣服我就不认识你了？来聊聊最长上升子序列\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/serialize.md\",\n  },\n  \"non-overlapping-intervals\": {\n    id: 435,\n    name: \"non-overlapping-intervals\",\n    title: \"穿上衣服我就不认识你了？来聊聊最长上升子序列\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/serialize.md\",\n  },\n  \"maximum-length-of-pair-chain\": {\n    id: 646,\n    name: \"maximum-length-of-pair-chain\",\n    title: \"穿上衣服我就不认识你了？来聊聊最长上升子序列\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/serialize.md\",\n  },\n  \"minimum-number-of-arrows-to-burst-balloons\": {\n    id: 452,\n    name: \"minimum-number-of-arrows-to-burst-balloons\",\n    title: \"穿上衣服我就不认识你了？来聊聊最长上升子序列\",\n    url:\n      \"https://github.com/azl397985856/leetcode/blob/master/selected/serialize.md\",\n  },\n\n  \"maximum-length-of-repeated-subarray\": {\n    id: 718,\n    name: \"maximum-length-of-repeated-subarray\",\n    title: \"你的衣服我扒了 - 《最长公共子序列》\",\n    url: \"https://github.com/azl397985856/leetcode/blob/master/selected/LCS.md\",\n  },\n  \"longest-common-subsequence\": {\n    id: 1143,\n    name: \"longest-common-subsequence\",\n    title: \"你的衣服我扒了 - 《最长公共子序列》\",\n    url: \"https://github.com/azl397985856/leetcode/blob/master/selected/LCS.md\",\n  },\n  \"uncrossed-lines\": {\n    id: 1035,\n    name: \"uncrossed-lines\",\n    title: \"你的衣服我扒了 - 《最长公共子序列》\",\n    url: \"https://github.com/azl397985856/leetcode/blob/master/selected/LCS.md\",\n  },\n  \"maximum-subarray\": {\n    id: 53,\n    name: \"maximum-subarray\",\n    title: \"一文看懂《最大子序列和问题》\",\n    url: \"https://github.com/azl397985856/leetcode/blob/master/selected/LSS.md\",\n  },\n};\n\nconst in91 = {};\nObject.values(db_collection).forEach((problem) => {\n  problem.companies.forEach((c) => {\n    if (company[c.name] === void 0) company[c.name] = [];\n    company[c.name].push(problem.name);\n  });\n});\n\nexport default {\n  problems: db_collection,\n  // tags,\n  company,\n  selected,\n};\n","import React, { PureComponent } from \"react\";\nimport PropTypes from \"prop-types\";\nimport SyntaxHighlighter from \"react-syntax-highlighter\";\nimport { coy } from \"react-syntax-highlighter/dist/esm/styles/prism\";\n\nclass CodeBlock extends PureComponent {\n  static propTypes = {\n    value: PropTypes.string.isRequired,\n    language: PropTypes.string,\n  };\n\n  static defaultProps = {\n    language: null,\n  };\n\n  render() {\n    let { language = \"\", value = \"\" } = this.props;\n    if (!language) language = \"\";\n    if (language.toLowerCase() === \"py\" || language.toLowerCase() === \"python3\")\n      language = \"python\";\n    if (language.toLowerCase() === \"js\") language = \"javascript\";\n    console.log(language);\n\n    return (\n      <SyntaxHighlighter language={language} style={coy}>\n        {value}\n      </SyntaxHighlighter>\n    );\n  }\n}\n\nexport default CodeBlock;\n","import React from \"react\";\nimport { Button, message, Collapse } from \"antd\";\n\nimport CodeBlock from \"./CodeBlock\";\n\nimport { copy } from \"../utils\";\n\nconst { Panel } = Collapse;\n\nexport default function Codes({ codes, renderHeader }) {\n  return (\n    <Collapse>\n      {codes.map((c) => (\n        <Panel\n          key={c.text}\n          header={\n            <div className=\"row\">\n              <span className=\"language language-js\">{c.language}</span>\n              <Button\n                type=\"primary\"\n                size=\"small\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  copy(c.text, () => {\n                    message.success(\"复制成功～\");\n                  });\n                }}\n              >\n                复制\n              </Button>\n\n              {renderHeader && renderHeader()}\n            </div>\n          }\n        >\n          <CodeBlock value={c.text} language={c.language}></CodeBlock>\n        </Panel>\n      ))}\n    </Collapse>\n  );\n}\n","import React from \"react\";\nimport { Button, Tag } from \"antd\";\n\nexport default function TagOrLink({ link, text, style, color }) {\n  return link !== null ? (\n    <Button type=\"link\" href={link} target=\"_blank\">\n      {text}\n    </Button>\n  ) : (\n    <div style={{ display: \"inline-block\", ...style }}>\n      <Tag color={color}>{text}</Tag>\n    </div>\n  );\n}\n","import React, { Fragment } from \"react\";\nimport { Button, Tabs, Collapse } from \"antd\";\n\nimport \"highlight.js/styles/github.css\";\n\nimport {\n  LEETCODE_CN_URL,\n  ISSUES_URL,\n  CONTRIBUTE_COMPANY_URL,\n} from \"./constant/index\";\nimport db from \"./db/db\";\n\nimport Codes from \"./components/codes\";\nimport TagOrLink from \"./components/TagOrLink\";\n\nconst { TabPane } = Tabs;\nconst { Panel } = Collapse;\n\nconst { problems, company } = db;\n\nexport default function Detail({ problemId }) {\n  return (\n    <Tabs defaultActiveKey=\"0\">\n      <TabPane tab=\"前置知识\" key=\"pre\">\n        {problems[problemId].pre.map(({ link, text, color }) => (\n          <TagOrLink key={text} text={text} link={link} color={color} />\n        ))}\n      </TabPane>\n      <TabPane tab=\"关键点\" key=\"key\">\n        {problems[problemId].keyPoints.length === 0 && (\n          <Fragment>\n            暂无关键点，\n            <a href={ISSUES_URL} target=\"_blank\" rel=\"noopener noreferrer\">\n              点击反馈\n            </a>\n          </Fragment>\n        )}\n        <ul>\n          {problems[problemId].keyPoints.map(({ link, text }) => (\n            <li key={text}>{link ? <a href={link}>text</a> : text}</li>\n          ))}\n        </ul>\n      </TabPane>\n      <TabPane tab=\"公司\" key=\"company\">\n        {problems[problemId].companies.length === 0 && (\n          <Fragment>\n            暂无公司资料，\n            <a\n              href={CONTRIBUTE_COMPANY_URL}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              点击反馈\n            </a>\n          </Fragment>\n        )}\n        <Collapse>\n          {problems[problemId].companies.map(({ name }) => (\n            <Panel header={name} key={name}>\n              <ul>\n                {company[name].map((id) => (\n                  <li key={name}>\n                    <Button\n                      type=\"link\"\n                      href={`${LEETCODE_CN_URL}/problems/${id}`}\n                      target=\"_blank\"\n                    >\n                      {id}\n                    </Button>\n                  </li>\n                ))}\n              </ul>\n            </Panel>\n          ))}\n        </Collapse>\n      </TabPane>\n      <TabPane tab=\"题解\" key=\"solution\">\n        <Button\n          type=\"link\"\n          href={problems[problemId].solution}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          前往 github 题解（国外）\n        </Button>\n\n        <Button\n          type=\"link\"\n          href={problems[problemId].giteeSolution}\n          target=\"_blank\"\n        >\n          前往 gitee 题解（国内）\n        </Button>\n      </TabPane>\n      <TabPane tab=\"代码\" key=\"code\">\n        <div className=\"code-block\">\n          <Collapse>\n            <Codes codes={problems[problemId].code}></Codes>\n          </Collapse>\n        </div>\n      </TabPane>\n\n      <TabPane\n        tab=\"可视化调试（敬请期待）\"\n        key=\"debug\"\n        disabled={true}\n      ></TabPane>\n\n      <TabPane tab=\"我要反馈\" key=\"feedback\">\n        <a\n          href={ISSUES_URL}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          style={{ marginRight: \"20px\" }}\n        >\n          我想反馈问题\n        </a>\n        <a\n          href={CONTRIBUTE_COMPANY_URL}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          style={{ marginRight: \"20px\" }}\n        >\n          我想贡献公司和岗位信息（免费获得题目咨询服务）\n        </a>\n        <a\n          href=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          关注更新\n        </a>\n      </TabPane>\n    </Tabs>\n  );\n}\n","import React, { useState } from \"react\";\nimport { Radio, Image } from \"antd\";\n\nimport Codes from \"../components/codes\";\nimport TagOrLink from \"../components/TagOrLink\";\n\nconst dpSingleCode = `\n  dp = [0] * (n + 1)\n  for i in range(1, n + 1):\n    for j in range(i + 1, n + 1):\n      if 一定条件:dp[j] = 选择(dp[i], dp[j])\n      else: dp[i] = dp[i - 1]\n`;\nconst dpDoubleCode = `\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if 一定条件:\n                  dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                  dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n`;\n\nconst dpRangeCode = `\nclass Solution:\n    def solve(self, s):\n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        # 右边界倒序遍历\n        for i in range(n - 1, -1, -1):\n            # 左边界正序遍历\n            for j in range(i + 1, n):\n                # do something\n        return  dp[0][m-1] # 一般都是使用这个区间作为答案\n`;\nconst dpRangeCodeRecur = `\nclass Solution:\n    def solve(self, s):\n        @lru_cache(None)\n        def helper(l, r):\n            if l >= r:\n                return 0\n            if s[l] == s[r]:\n                return helper(l + 1, r - 1)\n            return 1 + min(helper(l + 1, r), helper(l, r - 1))\n        return helper(0, len(s) - 1)\n`;\n\nconst roadmaps = {\n  \"binary-search\": {\n    desc: `\n    如果让我用一句话总结二分法，我会说**二分法是一种让未知世界无机可乘的算法**。即二分法无论如何我们都可以舍弃一半解，也就是无论如何都可以将解空间砍半。\n    难点就是两点：**什么条件** 和 **舍弃哪部分**。这是二分法核心要解决的问题。\n    \n    从战术上有两种基本类型，分别是最左插入二分和最右插入二分。\n    \n    从战略上有四种基本类型，能力检测二分，前缀和二分，插入排序二分和计数二分。\n    \n    两种类型（最左和最右插入）主要解决的的是：**解空间已经明确出来了，如何用代码找出具体的解**。而四大应用主要解决的是：**如何构造解空间**。更多的情况则是如何构建有序序列。\n\n    这两部分都是实操性很强的内容，在理解这两部分内容的同时，请大家务必牢记一个中心**折半**。\n    \n    更多内容请访问：https://lucifer.ren/blog/2021/03/08/binary-search-1`,\n    items: [\n      {\n        title: \"最左/最右二分\",\n        pic: void 0,\n        problems: [\n          {\n            link: \"https://leetcode-cn.com/problems/sqrtx\",\n            text: \"69. x 的平方根\",\n          },\n          {\n            link: \"https://leetcode-cn.com/problems/first-bad-version/\",\n            text: \"278. 第一个错误的版本\",\n            desc:\n              \"最左最右思路一样，大家练习两道，实际情况根据题意使用不同的二分即可。\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: `代码参考：代码模板 - 二分法`,\n        },\n        keys: [\n          `\n      1. 最左二分不断收缩右边界，最终返回左边界\n      2. 最右二分不断收缩左边界，最终返回右边界\n      `,\n        ],\n      },\n      {\n        title: \"能力检测二分\",\n        pic: void 0,\n        problems: [\n          {\n            link: \"https://binarysearch.com/problems/Minimum-Light-Radius\",\n            text: \"最小灯半径\",\n            desc: \"经典能力检测二分，力扣也有一道类似题\",\n          },\n          {\n            link: \"https://leetcode-cn.com/problems/swim-in-rising-water\",\n            text: \"778. 水位上升的泳池中游泳\",\n            desc:\n              \"DFS + 二分，类似的题目有很多，比如第 1439 题。这种题套路都很像，难度其实也不算大。\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: `\ndef ability_test_bs(nums):\n  def possible(mid):\n    pass\n  l, r = 0, len(A) - 1\n  while l <= r:\n      mid = (l + r) // 2\n      # 只有这里和最左二分不一样\n      if possible(mid): l = mid + 1\n      else: r = mid - 1\n  return l\n          `,\n        },\n        keys: [\n          `定义函数 possible 参数是 mid，返回值是布尔值。外层根据返回值调整\"解空间\"。示例代码是以最左二分为例的。\n      `,\n        ],\n      },\n      {\n        title: \"前缀和二分\",\n        pic: void 0,\n        problems: [\n          {\n            link: \"https://leetcode-cn.com/problems/count-of-range-sum/\",\n            text: \"327. 区间和的个数\",\n          },\n        ],\n\n        keys: [\n          `\n      如果数组是非负的，那么前缀和就是一个单调不递减数组，我们有时候可以基于它来做二分。\n      `,\n        ],\n      },\n      {\n        title: \"插入排序二分\",\n        pic: void 0,\n        problems: [\n          {\n            link: \"https://leetcode-cn.com/problems/reverse-pairs\",\n            text: \"493. 翻转对\",\n          },\n          {\n            link:\n              \"https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof\",\n            text: \"剑指 Offer 51. 数组中的逆序对\",\n          },\n          {\n            link: \"https://lucifer.ren/blog/2020/06/20/LIS/\",\n            text: \"最长上升子序列系列\",\n            desc: \"系列经典题目，值得一做\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: `\n  d = []\n  for a in A:\n      i = bisect.bisect_left(d, a)\n      if d and i < len(d):\n          d[i] = a\n      else:\n          d.append(a)`,\n        },\n        keys: [\n          `\n      不断插入并维护序列有序，进而利用有序做一些事情。\n      `,\n        ],\n      },\n      {\n        title: \"计数二分\",\n        pic: void 0,\n        problems: [\n          {\n            link: \"https://binarysearch.com/problems/Kth-Pair-Distance\",\n            text: \"第k小的距离对\",\n            desc:\n              \"典型的计数二分，本质上也是能力检测，只不过题量大，单独拆出来。\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: `\ndef count_bs(nums, k):\n  def count_not_greater(mid):\n    pass\n  l, r = 0, len(A) - 1\n  while l <= r:\n      mid = (l + r) // 2\n      # 只有这里和最左二分不一样\n      if count_not_greater(mid) > k: r = mid - 1\n      else: l = mid + 1\n  return l\n          `,\n        },\n        keys: [\n          `本质也是能力检测，因此和能力检测框架基本一致，大家对比理解一下。\n      `,\n        ],\n      },\n    ],\n  },\n  dp: {\n    desc: `\n  同一类型的不同题目框架基本一致，但细节略有不同，模板代码仅以某一种为例进行讲述，大家根据实际情况微调。\n  \n  动态规划三把斧：状态，枚举，转移方程（选择）。对于每一种题目，我都尽量按照这三点给大家提示。\n  \n  当然这个学习路线是给有一些基础的人看的，如果你还没有基础，可以看下相关文章，之后我也会写一篇硬核套路文。\n  `,\n    items: [\n      {\n        title: \"单字符串型\",\n        pic:\n          \"https://tva1.sinaimg.cn/large/0081Kckwly1glpjptuor0j31n00u0q8y.jpg\",\n        problems: [\n          {\n            link: \"https://leetcode-cn.com/problems/re-space-lcci/\",\n            text: \"面试题 17.13. 恢复空格\",\n            desc:\n              \"细节怎么练？+1？ -1? 怎么初始化？大家可以通过这道题学习一下~\",\n          },\n          {\n            link: \"https://lucifer.ren/blog/2020/06/20/LIS/\",\n            text: \"最长上升子序列系列\",\n            desc: \"系列经典题目，值得一做\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: dpSingleCode,\n        },\n        keys: [\n          `\n状态：1. dp[i] 表示以 s[i] 结尾的 xxxx\n     2. dp[i] 表示到 s[i] 为止的 xxxx\n        `,\n          \"枚举： 通常都是两层循环，一层循环固定左端点，另一层循环固定右端点进行枚举\",\n          \"转移方程：根据题目选择是否和 s[j] 结合，取最大，最小或计数即可\",\n        ],\n      },\n\n      {\n        title: \"双字符串型\",\n        pic:\n          \"https://tva1.sinaimg.cn/large/0081Kckwly1glpnd8ne27j31970u0gss.jpg\",\n        problems: [\n          {\n            link: \"https://lucifer.ren/blog/2020/07/01/LCS/\",\n            text: \"最长公共子序列系列\",\n            desc: \"系列经典题目，值得一做\",\n          },\n          {\n            link: \"https://leetcode-cn.com/problems/edit-distance/\",\n            text: \"72. 编辑距离\",\n          },\n          {\n            link:\n              \"https://leetcode-cn.com/problems/regular-expression-matching/solution/chao-jian-dan-de-ji-yi-hua-di-gui-ji-bai-9010-zhen/\",\n            text: \"10. 正则表达式匹配\",\n          },\n          {\n            link:\n              \"https://leetcode-cn.com/problems/wildcard-matching/solution/chao-ji-xiang-xi-ji-yi-hua-di-gui-tu-jie-dai-ni-yi/\",\n            text: \"44. 通配符匹配\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: dpDoubleCode,\n        },\n        keys: [\n          `\n状态：1. dp[i][j] 表示以 s1[i],s2[j] 结尾的 xxxx\n     2. dp[i][j] 表示到 s1[i],s2[j] 为止的 xxxx\n        `,\n          \"枚举：通常都是两层循环，一层循环固定 s1 的右端点，另一层循环固定 s2 的右端点进行枚举\",\n          \"状态转移：根据题目以及 s[i]， s[j] 的关系，取最大，最小或计数即可\",\n        ],\n      },\n      {\n        title: \"爬楼梯型\",\n        pic:\n          \"https://tva1.sinaimg.cn/large/0081Kckwly1glpom6u30yj30u00v1n61.jpg\",\n        problems: [\n          {\n            text: \"70. 爬楼梯\",\n            link: \"https://leetcode-cn.com/problems/climbing-stairs/\",\n          },\n          {\n            text: \"198. 打家劫舍\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/198.house-robber.md\",\n          },\n          {\n            text: \"337. 打家劫舍 III\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/337.house-robber-iii.md\",\n          },\n          {\n            text: \"62. 不同路径\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/62.unique-paths.md\",\n          },\n          {\n            text: \"63. 不同路径 II\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/63.unique-paths-ii.md\",\n          },\n          {\n            text: \"64. 最小路径和\",\n            link: \"https://leetcode-cn.com/problems/minimum-path-sum/\",\n          },\n          {\n            text: \"174. 地下城游戏\",\n            link: \"https://leetcode-cn.com/problems/dungeon-game/\",\n          },\n          {\n            text: \"576. 出界的路径数(只能选两个方向变成了只能选四个方向而已)\",\n            link: \"https://leetcode-cn.com/problems/out-of-boundary-paths/\",\n          },\n          {\n            text: \"935. 骑士拨号器(只能选两个方向变成了只能选八个方向而已)\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/935.knight-dialer.md\",\n          },\n          {\n            text: \"小兔的棋盘\",\n            link: \"https://github.com/azl397985856/leetcode/issues/429\",\n          },\n          {\n            text: \"Shopee的办公室\",\n            link:\n              \"https://www.nowcoder.com/questionTerminal/a71f3bd890734201986cd1e171807d30?commentTags=Python\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: `\n      # 一维\n      for i in range(2, n):\n        cur, prev = max(prev + nums[i], cur), cur\n      # 二维\n      def uniquePaths(self, m: int, n: int) -> int:\n          dp = [1] * n\n          for _ in range(1, m):\n              for j in range(1, n):\n                  dp[j] += dp[j - 1]\n        `,\n        },\n        keys: [\n          `\n状态： 1. 一维通常是 dp[i] 表示以 nums[i] 结尾的 xxxx\n      2. 二维通常是 dp[i][j] 表示以 grid[i][j] 结尾的 xxxx\n      `,\n          \"枚举：一维就是一层循环枚举所有的 nums，二维就是两层循环枚举所有的 grid\",\n          `\n状态转移：1. 一维通常是当前格子和前面的两个格子的关系，可能是最大最小或计数。 \n        dp[i] = dp[i - 1] + dp[i - 2]，这也叫递推式，因为不涉及决策。\n        2. 二维通常是当前格子和上方以及左方的两个格子的关系，可能是最大最小或计数。\n        dp[i][j] = dp[i - 1][j] + dp[i][j-1]，这也叫递推式，因为不涉及决策。\n        3. 根转移方程不难看出， 这种题目通常都可以滚动数组优化\n        `,\n        ],\n      },\n      {\n        title: \"背包型（仅列举题目）\",\n        pic: \"\",\n        problems: [\n          {\n            text: \"416. 分割等和子集\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/416.partition-equal-subset-sum.md\",\n          },\n          {\n            text: \"322. 零钱兑换\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/322.coin-change.md\",\n          },\n          {\n            text: \"518. 零钱兑换 II\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md\",\n          },\n        ],\n        code: void 0,\n        keys: [],\n      },\n      {\n        title: \"数位型（仅列举题目）\",\n        pic: \"\",\n        problems: [\n          {\n            text: \"233. 数字 1 的个数\",\n            link: \"https://leetcode-cn.com/problems/number-of-digit-one/\",\n          },\n          {\n            text: \"357. 计算各个位数不同的数字个数\",\n            link:\n              \"https://leetcode-cn.com/problems/count-numbers-with-unique-digits/\",\n          },\n          {\n            text: \"902. 最大为 N 的数字组合\",\n            link:\n              \"https://leetcode-cn.com/problems/numbers-at-most-n-given-digit-set/\",\n          },\n          {\n            text: \"1015. 可被 K 整除的最小整数\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/1015.smallest-integer-divisible-by-k.md\",\n          },\n          {\n            text: \"递增的数位\",\n            link: \"https://binarysearch.com/problems/Increasing-Digits\",\n          },\n        ],\n        code: void 0,\n        keys: [\n          \"常见的 dp 定义为 dp[i][j] 其中 i 为数字的长度， j 为最后一位的数。比如 dp[3][2] 表示这个数一共三位，最后一位是 2 的情况\",\n        ],\n      },\n      {\n        title: \"概率型（仅列举题目）\",\n        pic: \"\",\n        problems: [\n          {\n            text: \"808. 分汤\",\n            link: \"https://leetcode-cn.com/problems/soup-servings/\",\n          },\n          {\n            text: \"837. 新21点\",\n            link: \"https://leetcode-cn.com/problems/new-21-game/\",\n          },\n        ],\n        code: void 0,\n        keys: [],\n      },\n      {\n        title: \"博弈型（仅列举题目）\",\n        pic: \"\",\n        problems: [\n          {\n            text: \"292. Nim 游戏\",\n            link: \"https://leetcode-cn.com/problems/nim-game/\",\n          },\n          {\n            text: \"877. 石子游戏\",\n            link:\n              \"https://github.com/azl397985856/leetcode/blob/master/problems/877.stone-game.md\",\n          },\n          {\n            text: \"1140. 石子游戏 II\",\n            link: \"https://leetcode-cn.com/problems/stone-game-ii/\",\n          },\n          {\n            text: \"1406. 石子游戏 III\",\n            link: \"https://leetcode-cn.com/problems/stone-game-iii/\",\n          },\n          {\n            text: \"1510. 石子游戏 IV\",\n            link: \"https://leetcode-cn.com/problems/stone-game-iv/\",\n          },\n          {\n            text: \"1563. 石子游戏 V\",\n            link: \"https://leetcode-cn.com/problems/stone-game-v/\",\n          },\n          {\n            text: \"1686. 石子游戏 VI\",\n            desc: \"除了这个，其他《石子游戏》思路基本都一样\",\n            link: \"https://leetcode-cn.com/problems/stone-game-vi/\",\n          },\n          {\n            text: \"1690. 石子游戏 VII\",\n            link: \"https://leetcode-cn.com/problems/stone-game-vii/\",\n          },\n        ],\n        code: void 0,\n        keys: [],\n      },\n      {\n        title: \"区间 DP\",\n        // pic:\n        //   \"https://tva1.sinaimg.cn/large/0081Kckwly1glpjptuor0j31n00u0q8y.jpg\",\n        problems: [\n          {\n            link:\n              \"https://binarysearch.com/problems/Make-a-Palindrome-by-Inserting-Characters\",\n            text: \"回文插入\",\n            desc:\n              \"区间 dp 需要从序列两头同时进行，而不是从序列的某一端到另一端\",\n          },\n        ],\n        code: {\n          language: \"py\",\n          text: `\n          \n${dpRangeCode}\n# 使用记忆化可能会更好书写，比如上面的 dp 代码改成记忆化递归就是：\n${dpRangeCodeRecur}`,\n        },\n        keys: [\n          `\n右边界倒序遍历，左边界正序遍历\n        `,\n          \"通常都是返回 dp[0][n]，而不是其他常见的 dp[-1][-1]\",\n        ],\n      },\n      {\n        title: \"状态压缩型（仅列举题目）\",\n        pic: \"\",\n        problems: [\n          {\n            text: \"464. 我能赢吗\",\n            link: \"https://leetcode-cn.com/problems/can-i-win/\",\n          },\n          {\n            text: \"698. 划分为k个相等的子集\",\n            link:\n              \"https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/\",\n          },\n          {\n            text: \"1681. 最小不兼容性\",\n            link: \"https://leetcode-cn.com/problems/minimum-incompatibility/\",\n          },\n        ],\n        code: void 0,\n        keys: [],\n      },\n    ],\n  },\n};\n\nexport default function RoadMap() {\n  const [topic, setTopic] = useState(\"dp\");\n  return (\n    <>\n      <Radio.Group\n        onChange={(e) => setTopic(e.target.value)}\n        value={topic}\n        buttonStyle=\"solid\"\n      >\n        <Radio.Button value=\"dp\">动态规划</Radio.Button>\n        <Radio.Button value=\"binary-search\">二分</Radio.Button>\n        <Radio.Button value=\"tree\" disabled>\n          树\n        </Radio.Button>\n        <Radio.Button value=\"linked-list\" disabled>\n          链表\n        </Radio.Button>\n      </Radio.Group>\n      <div>\n        <pre>{roadmaps[topic].desc}</pre>\n        {roadmaps[topic].items.map((item) => {\n          return (\n            <div key={item.title}>\n              <h1>{item.title}</h1>\n              <div>\n                {item.keys.map((key) => (\n                  <pre key={key}>{key}</pre>\n                ))}\n              </div>\n              {item.pic && (\n                <>\n                  <Image src={item.pic} width={400} height={200} />\n                  (单击可放大)\n                </>\n              )}\n              {item.code && <Codes codes={[item.code]}></Codes>}\n              推荐题目：\n              <ul>\n                {item.problems.map(({ link, text, desc }) => {\n                  return (\n                    <li key={text}>\n                      <TagOrLink link={link} text={text} />\n                      {desc}\n                    </li>\n                  );\n                })}\n              </ul>\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n}\n","import halfLogo from \"../imgs/half.svg\";\n\nexport default {\n  title: \"二分法\",\n  logo: halfLogo,\n  list: [\n    {\n      text: \"查找一个数\",\n      problems: [\n        {\n          id: \"single-element-in-a-sorted-array\",\n          title: \"540. 有序数组中的单一元素\",\n        },\n      ],\n      codes: [\n        {\n          language: \"java\",\n          text: `\n        public int binarySearch(int[] nums, int target) {\n            // 左右都闭合的区间 [l, r]\n            int left = 0;\n            int right = nums.length - 1;\n        \n            while(left <= right) {\n                int mid = left + (right - left) / 2;\n                if(nums[mid] == target)\n                    return mid;\n                if (nums[mid] < target)\n                        // 搜索区间变为 [mid+1, right]\n                    left = mid + 1;\n                if (nums[mid] > target)\n                    // 搜索区间变为 [left, mid - 1]\n                    right = mid - 1;\n            }\n            return -1;\n        }`,\n        },\n        {\n          language: \"py\",\n          text: `\n            def binarySearch(nums, target):\n                # 左右都闭合的区间 [l, r]\n                l, r = 0, len(nums) - 1\n                while l <= r:\n                    mid = (left + right) >> 1\n                    if nums[mid] == target: return mid\n                    # 搜索区间变为 [mid+1, right]\n                    if nums[mid] < target: l = mid + 1\n                    # 搜索区间变为 [left, mid - 1]\n                    if nums[mid] > target: r = mid - 1\n                return -1`,\n        },\n        {\n          language: \"js\",\n          text: `\n            function binarySearch(nums, target) {\n                let left = 0;\n                let right = nums.length - 1;\n                while (left <= right) {\n                const mid = Math.floor(left + (right - left) / 2);\n                if (nums[mid] == target) return mid;\n                if (nums[mid] < target)\n                    // 搜索区间变为 [mid+1, right]\n                    left = mid + 1;\n                if (nums[mid] > target)\n                    // 搜索区间变为 [left, mid - 1]\n                    right = mid - 1;\n                }\n                return -1;\n            }`,\n        },\n        {\n          language: \"cpp\",\n          text: `\n          int binarySearch(vector<int>& nums, int target){\n            if(nums.size() == 0)\n              return -1;\n          \n            int left = 0, right = nums.size() - 1;\n            while(left <= right){\n              int mid = left + ((right - left) >> 1);\n              if(nums[mid] == target){ return mid; }\n              // 搜索区间变为 [mid+1, right]\n              else if(nums[mid] < target)\n            left = mid + 1;\n              // 搜索区间变为 [left, mid - 1]\n              else\n            right = mid - 1;\n            }\n            return -1;\n          }\n          `,\n        },\n      ],\n    },\n    {\n      text: \"寻找最左边的满足条件的值\",\n      problems: [\n        {\n          id: \"find-first-and-last-position-of-element-in-sorted-array\",\n          title: \"34. 在排序数组中查找元素的第一个和最后一个位置\",\n        },\n        {\n          id: \"first-bad-version\",\n          title: \"278. 第一个错误的版本\",\n        },\n      ],\n      codes: [\n        {\n          language: \"java\",\n          text: `\n          public int binarySearchLeft(int[] nums, int target) {\n            // 搜索区间为 [left, right]\n            int left = 0;\n            int right = nums.length - 1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (nums[mid] < target) {\n                    // 搜索区间变为 [mid+1, right]\n                    left = mid + 1;\n                }\n                if (nums[mid] >= target) {\n                    // 搜索区间变为 [left, mid-1]\n                    right = mid - 1;\n                }\n            }\n            // 检查是否越界\n            if (left >= nums.length || nums[left] != target)\n                return -1;\n            return left;\n        }`,\n        },\n        {\n          language: \"py\",\n          text: `\n          def binarySearchLeft(nums, target):\n            # 左右都闭合的区间 [l, r]\n            l, r = 0, len(nums) - 1\n            while l <= r:\n                mid = (l + r) >> 1\n                # 搜索区间变为 [mid+1, right]\n                if nums[mid] < target: l = mid + 1\n                # 搜索区间变为 [left, mid - 1]\n                if nums[mid] >= target: r = mid - 1\n            if l >= len(nums) or nums[l] != target: return -1\n            return l`,\n        },\n        {\n          language: \"js\",\n          text: `\n          function binarySearchLeft(nums, target) {\n            let left = 0;\n            let right = nums.length - 1;\n            while (left <= right) {\n              const mid = Math.floor(left + (right - left) / 2);\n              if (nums[mid] < target)\n                // 搜索区间变为 [mid+1, right]\n                left = mid + 1;\n              if (nums[mid] >= target)\n                // 搜索区间变为 [left, mid - 1]\n                right = mid - 1;\n            }\n            // 检查是否越界\n            if (left >= nums.length || nums[left] != target) return -1;\n            return left;\n          }`,\n        },\n        {\n          language: \"cpp\",\n          text: `\n          int binarySearchLeft(vector<int>& nums, int target) {\n            // 搜索区间为 [left, right]\n              int left = 0, right = nums.size() - 1;\n              while (left <= right) {\n                  int mid = left + ((right - left) >> 1);\n                  if (nums[mid] == target) {\n                      // 收缩右边界\n                      right = mid - 1;\n                  }\n                  if (nums[mid] < target) {\n                      // 搜索区间变为 [mid+1, right]\n                      left = mid + 1;\n                  }\n                  if (nums[mid] > target) {\n                      // 搜索区间变为 [left, mid-1]\n                      right = mid - 1;\n                  }\n              }\n              // 检查是否越界\n              if (left >= nums.size() || nums[left] != target)\n                  return -1;\n              return left;\n          }\n          `,\n        },\n      ],\n    },\n    {\n      text: \"寻找最右边的满足条件的值\",\n      problems: [\n        {\n          id: \"find-first-and-last-position-of-element-in-sorted-array\",\n          title: \"34. 在排序数组中查找元素的第一个和最后一个位置\",\n        },\n        {\n          id: \"sqrtx\",\n          title: \"69. x 的平方根\",\n        },\n      ],\n      codes: [\n        {\n          language: \"java\",\n          text: `\n            public int binarySearchRight(int[] nums, int target) {\n                // 搜索区间为 [left, right]\n                int left = 0\n                int right = nums.length - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (nums[mid] <= target) {\n                        // 搜索区间变为 [mid+1, right]\n                        left = mid + 1;\n                    }\n                    if (nums[mid] > target) {\n                        // 搜索区间变为 [left, mid-1]\n                        right = mid - 1;\n                    }\n                }\n                // 检查是否越界\n                if (right < 0 || nums[right] != target)\n                    return -1;\n                return right;\n            }`,\n        },\n        {\n          language: \"py\",\n          text: `\n            def binarySearchRight(nums, target):\n                # 左右都闭合的区间 [l, r]\n                l, r = 0, len(nums) - 1\n                while l <= r:\n                    mid = (l + r) >> 1\n                    # 搜索区间变为 [mid+1, right]\n                    if nums[mid] <= target: l = mid + 1\n                    # 搜索区间变为 [left, mid - 1]\n                    if nums[mid] > target: r = mid - 1\n                if r < 0 or nums[r] != target: return -1\n                return r`,\n        },\n        {\n          language: \"js\",\n          text: `\n          function binarySearchRight(nums, target) {\n            let left = 0;\n            let right = nums.length - 1;\n            while (left <= right) {\n              const mid = Math.floor(left + (right - left) / 2);\n              if (nums[mid] <= target)\n                // 搜索区间变为 [mid+1, right]\n                left = mid + 1;\n              if (nums[mid] > target)\n                // 搜索区间变为 [left, mid - 1]\n                right = mid - 1;\n            }\n            // 检查是否越界\n            if (right < 0 || nums[right] != target) return -1;\n            return right;\n          }`,\n        },\n        {\n          language: \"cpp\",\n          text: `\n          int binarySearchRight(vector<int>& nums, int target) {\n            // 搜索区间为 [left, right]\n              int left = 0, right = nums.size() - 1;\n              while (left <= right) {\n                  int mid = left + ((right - left) >> 1);\n                   if (nums[mid] == target) {\n                      // 收缩左边界\n                      left = mid + 1;\n                  }\n                  if (nums[mid] < target) {\n                // 搜索区间变为 [mid+1, right]\n                      left = mid + 1;\n                  }\n                  if (nums[mid] > target) {\n                // 搜索区间变为 [left, mid-1]\n                      right = mid - 1;\n                  }\n              }\n              // 检查是否越界\n              if (right < 0 || nums[right] != target)\n                  return -1;\n              return right;\n          }\n          \n          `,\n        },\n      ],\n    },\n    {\n      text: \"寻找最左插入位置\",\n      codes: [\n        {\n          language: \"py\",\n          text: `\n        def bisect_left(nums, x):\n          # 内置 api\n          bisect.bisect_left(nums, x)\n          # 手写\n          l, r = 0, len(A) - 1\n          while l <= r:\n              mid = (l + r) // 2\n              if A[mid] >= x: r = mid - 1\n              else: l = mid + 1\n          return l\n        `,\n        },\n        {\n          language: \"JS\",\n          text: `\n/**\n * @author suukii\n * @description 寻找最左插入位置\n * @param {number[]} nums \n * @param {number} x \n * @returns {number}\n */\nfunction searchInsertLeft(nums, x) {\n  // 题意转换一下，其实就是寻找第一个“大于等于” x 的数字，返回它的下标\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor(left + (right - left) / 2);\n\n    if (nums[mid] >= x) right = mid - 1;\n    if (nums[mid] < x) left = mid + 1;\n  }\n\n  return left;\n}\n          `,\n        },\n      ],\n      problems: [\n        {\n          id: \"random-pick-with-weight\",\n          title: \"528. 按权重随机选择\",\n        },\n      ],\n    },\n    {\n      text: \"寻找最右插入位置\",\n      codes: [\n        {\n          language: \"py\",\n          text: `\n        def bisect_right(nums, x):\n          # 内置 api\n          bisect.bisect_right(nums, x)\n          # 手写\n          l, r = 0, len(A) - 1\n          while l <= r:\n              mid = (l + r) // 2\n              if A[mid] <= x: l = mid + 1\n              else: r = mid - 1\n          return l\n        `,\n        },\n        {\n          language: \"JS\",\n          text: `\n/**@author suukii\n * @description 寻找最右插入位置\n * @param {number[]} nums \n * @param {number} x \n * @returns {number}\n */\nfunction searchInsertRight(nums, x) {\n  // 题意转换一下，其实就是寻找第一个“大于” x 的数字，返回它的下标\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = Math.floor(left + (right - left) / 2);\n\n    if (nums[mid] > x) right = mid - 1;\n    if (nums[mid] <= x) left = mid + 1;\n  }\n\n  return left;\n}\n          `,\n        },\n      ],\n      problems: [\n        {\n          id: \"find-first-and-last-position-of-element-in-sorted-array\",\n          title: \"34. 在排序数组中查找元素的第一个和最后一个位置\",\n        },\n      ],\n    },\n  ],\n  link:\n    \"https://github.com/azl397985856/leetcode/blob/master/91/binary-search.md\",\n};\n","import ufLogo from \"../imgs/uf.svg\";\n\nexport default {\n  title: \"并查集\",\n  logo: ufLogo,\n  list: [\n    {\n      text: \"不带权并查集\",\n      problems: [\n        {\n          title: \"547. 朋友圈\",\n          id: \"friend-circles\",\n        },\n        {\n          title: \"721. 账户合并\",\n          id: \"accounts-merge\",\n        },\n        {\n          title: \"990. 等式方程的可满足性\",\n          id: \"satisfiability-of-equality-equations\",\n        },\n        {\n          title: \"1202. 交换字符串中的元素\",\n          id: \"smallest-string-with-swaps\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\nclass UF:\n  def __init__(self, M):\n      self.parent = {}\n      self.cnt = 0\n      # 初始化 parent，size 和 cnt\n      for i in range(M):\n          self.parent[i] = i\n          self.cnt += 1\n\n  def find(self, x):\n      if x != self.parent[x]:\n          self.parent[x] = self.find(self.parent[x])\n          return self.parent[x]\n      return x\n  def union(self, p, q):\n      if self.connected(p, q): return\n      leader_p = self.find(p)\n      leader_q = self.find(q)\n      self.parent[leader_p] = leader_q\n      self.cnt -= 1\n  def connected(self, p, q):\n      return self.find(p) == self.find(q)\n        `,\n        },\n      ],\n    },\n    {\n      text: \"带权并查集\",\n      problems: [\n        {\n          title: \"399. 除法求值\",\n          id: \"evaluate-division\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\nclass UF:\n  def __init__(self, M):\n      # 初始化 parent，weight\n      self.parent = {}\n      self.weight = {}\n      for i in range(M):\n          self.parent[i] = i\n          self.weight[i] = 0\n\n  def find(self, x):\n      if self.parent[x] != x:\n          ancestor, w = self.find(self.parent[x])\n          self.parent[x] = ancestor\n          self.weight[x] += w\n      return self.parent[x], self.weight[x]\n  def union(self, p, q, dist):\n      if self.connected(p, q): return\n      leader_p, w_p = self.find(p)\n      leader_q, w_q = self.find(q)\n      self.parent[leader_p] = leader_q\n      self.weight[leader_p] = dist + w_q - w_p\n  def connected(self, p, q):\n      return self.find(p)[0] == self.find(q)[0]\n        `,\n        },\n      ],\n    },\n  ],\n  link:\n    \"https://github.com/azl397985856/leetcode/blob/master/thinkings/union-find.md\",\n};\n","import bfsLogo from \"../imgs/bfs.svg\";\n\nexport default {\n  title: \"BFS\",\n  logo: bfsLogo,\n  list: [\n    {\n      text: \"带层信息\",\n      problems: [\n        {\n          title: \"513.找树左下角的值\",\n          id: \"find-bottom-left-tree-value\",\n        },\n        {\n          title: \"662. 二叉树最大宽度\",\n          id: \"maximum-width-of-binary-tree\",\n        },\n        {\n          title: \"863. 二叉树中所有距离为 K 的结点\",\n          id: \"all-nodes-distance-k-in-binary-tree\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\n        class Solution:\n          def bfs(k):\n              # 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。\n              queue = collections.deque([root])\n              # 记录层数\n              steps = 0\n              # 需要返回的节点\n              ans = []\n              # 队列不空，生命不止！\n              while queue:\n                  size = len(queue)\n                  # 遍历当前层的所有节点\n                  for _ in range(size):\n                      node = queue.popleft()\n                      if (step == k) ans.append(node)\n                      if node.right:\n                          queue.append(node.right)\n                      if node.left:\n                          queue.append(node.left)\n                  # 遍历完当前层所有的节点后 steps + 1\n                  steps += 1\n              return ans\n              `,\n        },\n      ],\n    },\n    {\n      text: \"不带层信息\",\n      problems: [\n        {\n          title: \"116. 填充每个节点的下一个右侧节点指针\",\n          id: \"populating-next-right-pointers-in-each-node\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\n        class Solution:\n          def bfs(k):\n              # 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。\n              queue = collections.deque([root])\n              # 队列不空，生命不止！\n              while queue:\n                  node = queue.popleft()\n                  # 由于没有记录 steps，因此我们肯定是不需要根据层的信息去判断的。否则就用带层的模板了。\n                  if (node 是我们要找到的) return node\n                  if node.right:\n                      queue.append(node.right)\n                  if node.left:\n                      queue.append(node.left)\n              return -1\n          `,\n        },\n      ],\n    },\n  ],\n  link:\n    \"https://github.com/azl397985856/leetcode/blob/master/thinkings/tree.md\",\n};\n","import treeLogo from \"../imgs/tree.svg\";\n\nconst cppCode = `\nstruct TrieNode {\n  TrieNode *children[26];\n  bool isEnd;\n  TrieNode(bool end=false) {\n      isEnd = end;\n      memset(children, 0, sizeof(children));\n  }\n};\n\nclass Trie {\nprivate:\n  TrieNode *root;\n  \n  TrieNode* findString(string word) {\n      TrieNode *p = root;\n      for (size_t i=0; i<word.size(); i++) {\n          int index = word[i] - 'a';\n          if(p->children[index] == nullptr)\n              return nullptr;\n          p = p->children[index];\n      }\n      return p;\n  }\n  \n  void clear(TrieNode *root) {\n      for (size_t i = 0; i < 26; i ++) \n          if (root->children[i])\n              clear(root->children[i]);\n      delete root;\n  }\npublic:\n  /** Initialize your data structure here. */\n  Trie() {\n      root = new TrieNode();\n  }\n  \n  ~Trie() {\n      clear(root);\n  }\n  \n  /** Inserts a word into the trie. */\n  void insert(string word) {\n      TrieNode *p = root;\n      for(size_t i=0; i<word.size(); i++) {\n          int index = word[i] - 'a';\n          if (!p->children[index])\n              p->children[index] = new TrieNode();\n          p = p->children[index];\n      }\n      p->isEnd = true;\n  }\n  \n  /** Returns if the word is in the trie. */\n  bool search(string word) {\n      TrieNode *p = findString(word);\n      return p != nullptr && p->isEnd;\n  }\n  \n  /** Returns if there is any word in the trie that starts with the given prefix. */\n  bool startsWith(string prefix) {\n      TrieNode *p = findString(prefix);\n      return p != nullptr;\n  }\n};\n\n/**\n* Your Trie object will be instantiated and called as such:\n* Trie* obj = new Trie();\n* obj->insert(word);\n* bool param_2 = obj->search(word);\n* bool param_3 = obj->startsWith(prefix);\n*/\n`;\nconst goCode = `\ntype Node struct {\n\tisWord bool\n\tnext map[byte]*Node\n}\n\nfunc NewNode(isWord bool) *Node {\n\treturn &Node{isWord: isWord, next: make(map[byte]*Node)}\n}\n\ntype Trie struct {\n\troot *Node\n}\n\n//func NewTrie() *Trie {\n//\treturn &Trie{root: NewNode(false)}\n//}\n\n/** Initialize your data structure here. */\nfunc Constructor() Trie {\n\treturn Trie{root: NewNode(false)}\n}\n\n\n/** Inserts a word into the trie. */\nfunc (t *Trie) Insert(word string)  {\n\tcur := t.root\n\tfor i := 0; i < len(word); i++ {\n\t\tc := word[i]\n\t\t_, ok := cur.next[c]\n\t\tif !ok { // \n\t\t\tcur.next[c] = NewNode(false)\n\t\t} \n\t\tcur = cur.next[c]\n\t}\n\tif !cur.isWord { // 标记为单词\n\t\tcur.isWord = true\n\t}\n}\n\n\n/** Returns if the word is in the trie. */\nfunc (t *Trie) Search(word string) bool {\n\tcur := t.root\n\tfor i := 0; i < len(word); i++ {\n\t\tc := word[i]\n\t\tv, ok := cur.next[c]\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\tcur = v\n\t}\n\treturn cur.isWord\n}\n\n\n/** Returns if there is any word in the trie that starts with the given prefix. */\nfunc (t *Trie) StartsWith(prefix string) bool {\n\tcur := t.root\n\tfor i := 0; i < len(prefix); i++ {\n\t\tc := prefix[i]\n\t\tv,ok := cur.next[c]\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\tcur = v\n\t}\n\treturn true\n}\n`;\n\nconst javaCode = `\nclass Trie {\n\n  class TireNode {\n      boolean isEnd = false;\n      TireNode[] next = new TireNode[26];\n      TireNode() {} \n  }\n\n  private TireNode root;\n\n  /** Initialize your data structure here. */\n  public Trie() {\n      root = new TireNode();\n  }\n  \n  /** Inserts a word into the trie. */\n  public void insert(String word) {\n      TireNode node = root;\n      for (char ch : word.toCharArray()) {\n          if (node.next[ch-'a'] == null) {\n              node.next[ch-'a'] = new TireNode();\n          }\n          node = node.next[ch-'a'];\n      }\n      node.isEnd = true;\n  }\n  \n  /** Returns if the word is in the trie. */\n  public boolean search(String word) {\n      TireNode node = root;\n      for (char ch : word.toCharArray()) {\n          if (node.next[ch-'a'] == null) return false;\n          node = node.next[ch-'a'];\n      }\n      return node.isEnd;\n  }\n  \n  /** Returns if there is any word in the trie that starts with the given prefix. */\n  public boolean startsWith(String prefix) {\n      TireNode node = root;\n      for (char ch : prefix.toCharArray()) {\n          if (node.next[ch-'a'] == null) return false;\n          node = node.next[ch-'a'];\n      }\n      return true;\n  }\n}\n\n/**\n* Your Trie object will be instantiated and called as such:\n* Trie obj = new Trie();\n* obj.insert(word);\n* boolean param_2 = obj.search(word);\n* boolean param_3 = obj.startsWith(prefix);\n*/\n`;\nexport default {\n  title: \"前缀树\",\n  logo: treeLogo,\n  list: [\n    {\n      text: \"标准前缀树\",\n      problems: [\n        {\n          title: \"208.实现 Trie (前缀树)\",\n          id: \"implement-trie-prefix-tree\",\n        },\n        {\n          title: \"211.添加与搜索单词 - 数据结构设计\",\n          id: \"add-and-search-word-data-structure-design\",\n        },\n        {\n          id: \"word-search-ii\",\n          title: \"212.单词搜索 II\",\n        },\n        {\n          id: \"concatenated-words\",\n          title: \"472.连接词\",\n        },\n        {\n          title: \"648. 单词替换\",\n          id: \"replace-words\",\n        },\n        {\n          id: \"short-encoding-of-words\",\n          title: \"820.单词的压缩编码\",\n        },\n        {\n          title: \"1032.字符流\",\n          id: \"stream-of-characters\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\nclass Trie:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.Trie = {}\n\n    def insert(self, word):\n        \"\"\"\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: void\n        \"\"\"\n        curr = self.Trie\n        for w in word:\n            if w not in curr:\n                curr[w] = {}\n            curr = curr[w]\n        curr['#'] = 1\n\n    def search(self, word):\n        \"\"\"\n        Returns if the word is in the trie.\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        curr = self.Trie\n        for i, w in enumerate(word):\n            if w == '.':\n                wizards = []\n                for k in curr.keys():\n                    if k == '#':\n                        continue\n                    wizards.append(self.search(word[:i] + k + word[i + 1:]))\n                return any(wizards)\n            if w not in curr:\n                return False\n            curr = curr[w]\n        return \"#\" in curr\n            `,\n        },\n        {\n          language: \"js\",\n          text: `\n          function TrieNode(val) {\n            this.val = val;\n            this.children = [];\n            this.isWord = false;\n          }\n          \n          function computeIndex(c) {\n            return c.charCodeAt(0) - \"a\".charCodeAt(0);\n          }\n          /**\n           * Initialize your data structure here.\n           */\n          var Trie = function() {\n            this.root = new TrieNode(null);\n          };\n          \n          /**\n           * Inserts a word into the trie.\n           * @param {string} word\n           * @return {void}\n           */\n          Trie.prototype.insert = function(word) {\n            let ws = this.root;\n            for (let i = 0; i < word.length; i++) {\n              const c = word[i];\n              const current = computeIndex(c);\n              if (!ws.children[current]) {\n                ws.children[current] = new TrieNode(c);\n              }\n              ws = ws.children[current];\n            }\n            ws.isWord = true;\n          };\n          \n          /**\n           * Returns if the word is in the trie.\n           * @param {string} word\n           * @return {boolean}\n           */\n          Trie.prototype.search = function(word) {\n            let ws = this.root;\n            for (let i = 0; i < word.length; i++) {\n              const c = word[i];\n              const current = computeIndex(c);\n              if (!ws.children[current]) return false;\n              ws = ws.children[current];\n            }\n            return ws.isWord;\n          };\n          \n          /**\n           * Returns if there is any word in the trie that starts with the given prefix.\n           * @param {string} prefix\n           * @return {boolean}\n           */\n          Trie.prototype.startsWith = function(prefix) {\n            let ws = this.root;\n            for (let i = 0; i < prefix.length; i++) {\n              const c = prefix[i];\n              const current = computeIndex(c);\n              if (!ws.children[current]) return false;\n              ws = ws.children[current];\n            }\n            return true;\n          };\n          \n          /**\n           * Your Trie object will be instantiated and called as such:\n           * var obj = new Trie()\n           * obj.insert(word)\n           * var param_2 = obj.search(word)\n           * var param_3 = obj.startsWith(prefix)\n           */\n                  `,\n        },\n        {\n          language: \"cpp\",\n          text: cppCode,\n        },\n        {\n          language: \"go\",\n          text: goCode,\n        },\n        {\n          language: \"java\",\n          text: javaCode,\n        },\n      ],\n    },\n  ],\n  link:\n    \"https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md\",\n};\n","import windowLogo from \"../imgs/window.svg\";\nexport default {\n  title: \"滑动窗口\",\n  logo: windowLogo,\n  list: [\n    {\n      text: \"固定窗口（伪代码）\",\n      problems: [\n        {\n          title: \"438. 找到字符串中所有字母异位词\",\n          id: \"find-all-anagrams-in-a-string\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\n            初始化前后指针 = 0\n            初始化 ans\n\n            for 前指针 in 可迭代集合\n                更新窗口内信息（前指针进窗口，后指针出窗口）\n                后指针移动\n            更新答案\n            返回 ans\n                `,\n        },\n      ],\n    },\n    {\n      text: \"可变窗口（伪代码）\",\n      problems: [\n        {\n          id: \"longest-substring-without-repeating-characters\",\n          title: \"3. 无重复字符的最长子串\",\n        },\n        {\n          title: \"76. 最小覆盖子串\",\n          id: \"minimum-window-substring\",\n        },\n        {\n          title: \"209. 长度最小的子数组\",\n          id: \"minimum-size-subarray-sum\",\n        },\n        {\n          id: \"fruit-into-baskets\",\n          title: \"904. 水果成篮\",\n        },\n        {\n          title: \"930. 和相同的二元子数组\",\n          id: \"binary-subarrays-with-sum\",\n        },\n        {\n          title: \"992. K 个不同整数的子数组\",\n          id: \"subarrays-with-k-different-integers\",\n        },\n\n        {\n          title: \"1004. 最大连续 1 的个数 III\",\n          id: \"max-consecutive-ones-iii\",\n        },\n        {\n          title: \"1234. 替换子串得到平衡字符串\",\n          id: \"replace-the-substring-for-balanced-string\",\n        },\n        {\n          title: \"1248. 统计「优美子数组」\",\n          id: \"count-number-of-nice-subarrays\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\n        初始化慢指针 = 0\n        初始化 ans\n\n        for 快指针 in 可迭代集合\n            更新窗口内信息\n            while 窗口内不符合题意\n                扩展或者收缩窗口\n                慢指针移动\n            更新答案\n        返回 ans\n            `,\n        },\n      ],\n    },\n  ],\n  link:\n    \"https://github.com/azl397985856/leetcode/blob/master/thinkings/slide-window.md\",\n};\n","import segmentLogo from \"../imgs/segment.svg\";\n\nconst pyCode = `\nclass SegmentTree:\n    def __init__(self, data:List[int]): \n        '''\n        data:传入的数组\n        '''\n        self.data = data\n        self.n = len(data)\n        #  申请4倍data长度的空间来存线段树节点\n        self.tree = [None] * (4 * self.n) # 索引i的左孩子索引为2i+1，右孩子为2i+2\n        if self.n:\n            self.build(0, 0, self.n-1)\n    # 本质就是一个自底向上的更新过程\n    # 因此可以使用后序遍历，即在函数返回的时候更新父节点。\n    def update(self, tree_index, l, r, index):\n        '''\n        tree_index:某个根节点索引\n        l, r : 此根节点代表区间的左右边界\n        index : 更新的值的索引\n        '''\n        if l == r==index :\n            self.tree[tree_index] = self.data[index]\n            return\n        mid = (l+r)//2\n        left, right = 2 * tree_index + 1, 2 * tree_index + 2\n        if index > mid:\n            # 要更新的区间在右子树\n            self.update(right, mid+1, r, index)\n        else:\n            # 要更新的区间在左子树index<=mid\n            self.update(left, l, mid, index)\n        # 查询区间一部分在左子树一部分在右子树\n        # 区间和使用加法即可，如果不是区间和要改下面这行代码\n        self.tree[tree_index] = self.tree[left] + self.tree[right]\n        \n    def updateSum(self,index:int,value:int):\n        self.data[index] = value\n        self.update(0, 0, self.n-1, index)\n    def query(self, tree_index:int, l:int, r:int, ql:int, qr:int) -> int:\n        '''\n        递归查询区间[ql,..,qr]的值\n        tree_index : 某个根节点的索引\n        l, r : 该节点表示的区间的左右边界\n        ql, qr: 待查询区间的左右边界\n        '''\n        if l == ql and r == qr:\n            return self.tree[tree_index]\n    \n        # 区间中点,对应左孩子区间结束,右孩子区间开头\n        mid = (l+r) // 2 \n        left, right = tree_index * 2 + 1, tree_index * 2 + 2\n        if qr <= mid:\n            # 查询区间全在左子树\n            return self.query(left, l, mid, ql, qr)\n        elif ql > mid:\n            # 查询区间全在右子树\n            return self.query(right, mid+1, r, ql, qr)\n    \n        # 查询区间一部分在左子树一部分在右子树\n        # 区间和使用加法即可，如果不是区间和要改下面这行代码\n        return self.query(left, l, mid, ql, mid) + self.query(right, mid+1, r, mid+1, qr)\n\n    def querySum(self, ql:int, qr:int) -> int:\n        '''\n        返回区间[ql,..,qr]的和\n        '''\n        return self.query(0, 0, self.n-1, ql, qr)\n\n    def build(self, tree_index:int, l:int, r:int):\n        '''\n        递归创建线段树\n        tree_index : 线段树节点在数组中位置\n        l, r : 该节点表示的区间的左,右边界\n        '''\n        if l == r:\n            self.tree[tree_index] = self.data[l]\n            return\n        mid = (l+r) // 2 # 区间中点,对应左孩子区间结束,右孩子区间开头\n        left, right = 2 * tree_index + 1, 2 * tree_index + 2 # tree_index的左右子树索引\n        self.build(left, l, mid)\n        self.build(right, mid+1, r)\n        # 区间和使用加法即可，如果不是区间和要改下面这行代码\n        self.tree[tree_index] = self.tree[left] + self.tree[right]\n`;\n\nexport default {\n  title: \"线段树\",\n  logo: segmentLogo,\n  link: \"https://oi-wiki.org/ds/seg/\",\n  list: [\n    {\n      text: \"区间和线段树\",\n      problems: [\n        {\n          id: \"range-sum-query-immutable\",\n          title: \"303. 区域和检索 - 数组不可变（使用一维前缀和会更简单）\",\n        },\n        {\n          id: \"range-sum-query-mutable\",\n          title: \"307. 区域和检索 - 数组可修改\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: pyCode,\n        },\n      ],\n    },\n    {\n      text: \"计数线段树\",\n      problems: [\n        {\n          id: \"create-sorted-array-through-instructions\",\n          title: \"1649. 通过指令创建有序数组\",\n        },\n      ],\n      codes: [\n        {\n          language: \"py\",\n          text: `\nclass SegmentTree:\n  def __init__(self, upper, lower):\n      \"\"\"\n      data:传入的数组\n      \"\"\"\n      self.lower = lower\n      self.upper = upper\n      #  申请4倍data长度的空间来存线段树节点\n      self.tree = [0] * (4 * (upper - lower + 1))  # 索引i的左孩子索引为2i+1，右孩子为2i+2\n\n  # 本质就是一个自底向上的更新过程\n  # 因此可以使用后序遍历，即在函数返回的时候更新父节点。\n  def update(self, tree_index, l, r, index):\n      \"\"\"\n      tree_index:某个根节点索引\n      l, r : 此根节点代表区间的左右边界\n      index : 更新的值的索引\n      \"\"\"\n      if l > index or r < index:\n          return\n      self.tree[tree_index] += 1\n      if l == r:\n          return\n      mid = (l + r) // 2\n      left, right = tree_index * 2 + 1, tree_index * 2 + 2\n      self.update(left, l, mid, index)\n      self.update(right, mid + 1, r, index)\n\n  def updateCount(self, index: int):\n      self.update(0, self.lower, self.upper, index)\n\n  def query(self, tree_index: int, l: int, r: int, ql: int, qr: int) -> int:\n      \"\"\"\n      递归查询区间[ql,..,qr]的值\n      tree_index : 某个根节点的索引\n      l, r : 该节点表示的区间的左右边界\n      ql, qr: 待查询区间的左右边界\n      \"\"\"\n      if qr < l or ql > r:\n          return 0\n      # l 和 r 在 [ql, qr] 内\n      if ql <= l and qr >= r:\n          return self.tree[tree_index]\n      mid = (l + r) // 2\n      left, right = tree_index * 2 + 1, tree_index * 2 + 2\n      return self.query(left, l, mid, ql, qr) + self.query(right, mid + 1, r, ql, qr)\n\n  def queryCount(self, ql: int, qr: int) -> int:\n      \"\"\"\n      返回区间[ql,..,qr]的计数信息\n      \"\"\"\n      return self.query(0, self.lower, self.upper, ql, qr)\n          `,\n        },\n      ],\n    },\n  ],\n};\n","import binarySearch from \"./binarySearch\";\nimport backtrack from \"./backtrack\";\nimport uf from \"./uf\";\nimport bfs from \"./bfs\";\nimport trie from \"./trie\";\nimport slidingWindow from \"./sliding-window\";\nimport segmemntTree from \"./segmentTree\";\nimport heap from \"./heap\";\nimport preSum from \"./preSum\";\nimport handWriting from \"./hand-writing\";\nexport default [\n  preSum,\n  binarySearch,\n  bfs,\n  heap,\n  slidingWindow,\n  backtrack,\n  trie,\n  uf,\n  segmemntTree,\n  handWriting,\n];\n","import React from \"react\";\nimport { message } from \"antd\";\nconst chrome = window.chrome;\nif (chrome) {\n  chrome.runtime.onUpdateAvailable &&\n    chrome.runtime.onUpdateAvailable.addListener(function (details) {\n      console.log(\"updating to version \" + details.version);\n\n      chrome.runtime.reload();\n    });\n} else {\n  // 其他浏览器;\n}\n\nexport default function checkUpdate() {\n  return chrome.runtime.requestUpdateCheck(function (status) {\n    if (status === \"update_available\") {\n      message.success({\n        content: (\n          <>\n            检测到有新版本，已为您自动更新。如果更新失败，您可以去\n            <a href=\"chrome://extensions/\">扩展中心</a> 手动更新哦~\n          </>\n        ),\n      });\n    } else if (status === \"no_update\") {\n      message.success({\n        content: \"已经是最新版本了~\",\n      });\n    } else if (status === \"throttled\") {\n      message.success({\n        content: \"操作太频繁，请稍后再试~\",\n      });\n    }\n  });\n}\n","import React from \"react\";\nimport { Button, Collapse, Tabs } from \"antd\";\nimport Codes from \"../components/codes\";\n\nimport {\n  LEETCODE_CN_URL,\n  CONTRIBUTE_PROGRAMMING_LANGUAGE_URL,\n} from \"../constant/index\";\n\nconst { TabPane } = Tabs;\nconst { Panel } = Collapse;\n\nexport default function CodeTemplate({ tempaltes }) {\n  return (\n    <div>\n      <Tabs>\n        {tempaltes.map((tempalte) => (\n          <TabPane\n            tab={\n              <div>\n                {tempalte.title}\n                <img\n                  alt={tempalte.title}\n                  style={\n                    tempalte.logo\n                      ? { margin: \"0 0 0 10px\" }\n                      : { display: \"none\" }\n                  }\n                  src={tempalte.logo}\n                  className=\"problem-icon\"\n                />\n              </div>\n            }\n            key={tempalte.title}\n          >\n            {tempalte.link && (\n              <div>\n                建议先学会之后再用模板。 如果你还不会的话，可以看看这篇\n                <Button type=\"link\" href={tempalte.link} target=\"_blank\">\n                  文章\n                </Button>\n                哦~\n              </div>\n            )}\n            {tempalte.list.map(({ text, problems, codes }) => (\n              <Collapse key={text}>\n                <Panel header={<div>{text}</div>} key={text}>\n                  <div>\n                    推荐题目：\n                    <ul>\n                      {problems.map((problem) => (\n                        <li key={problem.title}>\n                          <Button type=\"text\">{problem.title}</Button>\n                          <Button\n                            onClick={(e) => e.stopPropagation()}\n                            type=\"link\"\n                            href={`${LEETCODE_CN_URL}/problems/${problem.id}`}\n                            target=\"_blank\"\n                            size=\"small\"\n                            style={{ marginLeft: \"10px\" }}\n                          >\n                            去默写\n                          </Button>\n                        </li>\n                      ))}\n                    </ul>\n                  </div>\n                  <Codes codes={codes} />\n                  <Button\n                    type=\"link\"\n                    href={CONTRIBUTE_PROGRAMMING_LANGUAGE_URL}\n                  >\n                    纠错 or 贡献其他语言\n                  </Button>\n                </Panel>\n              </Collapse>\n            ))}\n          </TabPane>\n        ))}\n\n        <TabPane tab=\"更多模板后续陆续更新\" key=\"more\" disabled></TabPane>\n      </Tabs>\n    </div>\n  );\n}\n","import React from \"react\";\nimport { Button, Table } from \"antd\";\n\nimport \"./index.less\";\n\n// | 数据规模 | 算法可接受时间复杂度 |\n// | -------- | -------------------- |\n// | <= 10    | $O(n!)$              |\n// | <=20     | $O(2^n)$             |\n// | <=100    | $O(n^4)$             |\n// | <=500    | $O(n^3)$             |\n// | <=2500   | $O(n^2)$             |\n// | <=10^6   | $O(n * logn)$        |\n// | <=10^7   | $O(n)$               |\n// | <=10^14  | $O(\\sqrt{n})$        |\n// | -        | $O(logn)$            |\n\nconst columns = [\n  {\n    key: \"size\",\n    dataIndex: \"size\",\n    title: \"数据规模\",\n    align: \"center\",\n  },\n  {\n    key: \"complexity\",\n    dataIndex: \"complexity\",\n    title: \"算法可接受时间复杂度\",\n    align: \"center\",\n    render: (t) => {\n      if (t === \"O(sqrt(n))\")\n        return <img alt=\"O(sqrt(n))\" src={require(\"../imgs/sqrt.svg\")} />;\n      return t;\n    },\n  },\n];\n\nconst data = [\n  {\n    size: \"<= 10\",\n    complexity: \"O(n!)\",\n  },\n  {\n    size: \"<= 20\",\n    complexity: \"O(2^n)\",\n  },\n  {\n    size: \"<= 100\",\n    complexity: \"O(n^4)\",\n  },\n  {\n    size: \"<= 500\",\n    complexity: \"O(n^3)\",\n  },\n  {\n    size: \"<= 2500\",\n    complexity: \"O(n^2)\",\n  },\n  {\n    size: \"<= 10^6\",\n    complexity: \"O(nlogn)\",\n  },\n  {\n    size: \"<= 10^7\",\n    complexity: \"n\",\n  },\n  {\n    size: \"<= 10^14\",\n    complexity: \"O(sqrt(n))\",\n  },\n  {\n    size: \"-\",\n    complexity: \"O(logn)\",\n  },\n];\n\nexport default function ComplexityRating() {\n  return (\n    <div>\n      <Button\n        type=\"link\"\n        href=\"https://lucifer.ren/blog/2020/12/21/shuati-silu3/\"\n        target=\"_blank\"\n      >\n        不懂为什么？点这里\n      </Button>\n\n      <Table columns={columns} dataSource={data} />\n    </div>\n  );\n}\n","import React from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport Tex from \"@matejmazur/react-katex\";\nimport RemarkMathPlugin from \"remark-math\";\nimport \"katex/dist/katex.min.css\";\n\nimport CodeBlock from \"../components/CodeBlock\";\nimport debounceRender from \"react-debounce-render\";\n\nconst MarkdownRender = (props) => {\n  const newProps = {\n    ...props,\n    escapeHtml: false,\n    plugins: [RemarkMathPlugin],\n    renderers: {\n      ...props.renderers,\n      inlineMath: ({ value }) => <Tex math={value} />,\n      math: ({ value }) => <Tex block math={value} />,\n      code: (_props) => <CodeBlock {..._props}></CodeBlock>,\n    },\n  };\n  return <ReactMarkdown {...newProps} />;\n};\n\nexport default debounceRender(MarkdownRender, 500);\n","import React, { PureComponent } from \"react\";\nimport {\n  Radio,\n  Row,\n  Col,\n  Input,\n  Select,\n  message,\n  Button,\n  Checkbox,\n  Spin,\n} from \"antd\";\n\nimport {\n  copyToClipboard,\n  isInExtension,\n  getUrlParameter,\n  getStorage,\n  setStorage,\n  debounce,\n  getCloundStorage,\n} from \"../utils.js\";\n\nimport MarkdownRender from \"../components/MarkdownRender\";\n// import AccessToken from \"../components/AccessToken\";\n\nconst { TextArea } = Input;\nconst { Option } = Select;\n\nconst slogan = `\n\n> 此题解由 [力扣刷题插件](https://leetcode-pp.github.io/leetcode-cheat/?tab=solution-template) 自动生成。 \n\n力扣的小伙伴可以[关注我](https://leetcode-cn.com/u/fe-lucifer/)，这样就会第一时间收到我的动态啦~\n\n以上就是本文的全部内容了。大家对此有何看法，欢迎给我留言，我有时间都会一一查看回答。更多算法套路可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 40K star 啦。大家也可以关注我的公众号《力扣加加》带你啃下算法这块硬骨头。\n\n关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。\n\n![](https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg)`;\n\nfunction displayLanguage(language) {\n  const m = {\n    python: \"Python\",\n    python3: \"Python3\",\n    java: \"Java\",\n    cpp: \"CPP\",\n    javascript: \"JavaScript\",\n    go: \"Go\",\n    c: \"C\",\n    \"c#\": \"C#\",\n    ruby: \"Ruby\",\n    swift: \"Swift\",\n    scala: \"Scala\",\n    kotlin: \"Kotlin\",\n    rust: \"Rust\",\n    php: \"PHP\",\n    typescript: \"TypeScript\",\n  };\n  // 如果不在里面，说明给的就是类似 Java 的直接显示的字符串\n  return m[language] || language;\n}\n\nfunction getTemplate({\n  title = \"\",\n  link = \"\",\n  desc = \"\",\n  pre = \"\",\n  company = \"暂无\",\n  language = \"python3\",\n  code = \"\",\n  keyword = \"\",\n  time = \"n\",\n  space = \"n\",\n  isLucifer = false,\n}) {\n  return `\n## 题目地址(${title})\n\n${link}\n\n## 题目描述\n\n\\`\\`\\`\n${desc}\n\\`\\`\\`\n\n## 前置知识\n\n- ${pre}\n\n## 公司\n\n- ${company}\n\n## 思路\n\n## 关键点\n\n- ${keyword} \n\n## 代码\n\n- 语言支持：${displayLanguage(language)}\n\n${displayLanguage(language)} Code:\n\n\\`\\`\\`${\n    language.toLocaleLowerCase() === \"python3\"\n      ? \"python\"\n      : language.toLocaleLowerCase()\n  }\n\n${code}\n\n\\`\\`\\`\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(${time})$\n- 空间复杂度：$O(${space})$\n\n${isLucifer ? slogan : \"\"}\n`;\n}\nfunction Template({ onChange, template }) {\n  return (\n    <TextArea\n      ref={textAreaRef}\n      value={template}\n      autoSize\n      onChange={onChange}\n    ></TextArea>\n  );\n}\n\nfunction Complexities({ value, onChange }) {\n  return (\n    <Radio.Group value={value} onChange={onChange}>\n      <Radio.Button value=\"1\">O(1)</Radio.Button>\n      <Radio.Button value=\"\\\\sqrt n\">O(\\sqrt n)</Radio.Button>\n      <Radio.Button value=\"logn\">O(logn)</Radio.Button>\n      <Radio.Button value=\"n\">O(n)</Radio.Button>\n      <Radio.Button value=\"nlogn\">O(nlogn)</Radio.Button>\n      <Radio.Button value=\"n^2\">O(n^2)</Radio.Button>\n      <Radio.Button value=\"2^n\">O(2^n)</Radio.Button>\n      <Radio.Button value=\"n!\">O(n!)</Radio.Button>\n    </Radio.Group>\n  );\n}\n\nconst formulas = [\n  {\n    formula: \"$sum_{i=1}^{n}{a_i}$\",\n    name: \"求和\",\n    logo: require(\"../imgs/formula/sum.svg\"),\n  },\n  {\n    formula: \"$a\\\\times b$\",\n    name: \"乘法\",\n    logo: require(\"../imgs/formula/times.svg\"),\n  },\n  {\n    formula: \"$a\\\\div b$\",\n    name: \"除法\",\n    logo: require(\"../imgs/formula/div.svg\"),\n  },\n  {\n    formula: \"$\\\\frac{a}{b}$\",\n    name: \"分数\",\n    logo: require(\"../imgs/formula/frac.svg\"),\n  },\n  {\n    formula: \"$a\\\\approx b$\",\n    name: \"约等于\",\n    logo: require(\"../imgs/formula/approx.svg\"),\n  },\n  {\n    formula: \"$\\\\sqrt a$\",\n    name: \"根号\",\n    logo: require(\"../imgs/formula/sqrt.svg\"),\n  },\n  {\n    formula: String.raw`\n$$\n  negative[i]=\\left\\{\n  \\begin{aligned}\n  negative[i-1] + 1 &  & negative[i-1] > 0 \\\\\n  0 & & negative[i-1] = 0 \\\\\n  \\end{aligned}\n  \\right.\n$$\n    `,\n    name: \"动态规划选择方程\",\n    logo: require(\"../imgs/formula/choice.svg\"),\n  },\n];\n\nconst saveDraft = debounce(\n  (v) =>\n    setStorage(\"solution-backup\", {\n      raw: v,\n    }),\n  5000\n);\nconst link = getUrlParameter(\"link\") || \"\";\nconst title = getUrlParameter(\"title\") || \"\";\nconst initialLanguage = getUrlParameter(\"language\")?.toLowerCase() || \"python3\";\nconst textAreaRef = React.createRef();\nexport default class SolutionTemplate extends PureComponent {\n  constructor(props) {\n    super(props);\n    // const [language, setLanguage] = useState(initialLanguage);\n    // const [time, setTime] = useState(\"n\");\n    // const [space, setSpace] = useState(\"n\");\n    // const [isLucifer, setIsLucifer] = useState(false);\n    // // const [modalVisible, setModalVisible] = useState(false);\n    // const [template, setTemplate] = useState(\n    //   getTemplate({\n    //     link,\n    //     title,\n    //     time,\n    //     space,\n    //     language,\n    //   })\n    // );\n    this.state = {\n      language: initialLanguage,\n      time: \"n\",\n      space: \"n\",\n      isLucifer: false,\n      template: \"\",\n      isloading: false,\n    };\n    this.setLanguage = (v) =>\n      this.setState({\n        language: v,\n      });\n    this.setTime = (v) =>\n      this.setState({\n        time: v,\n      });\n    this.setSpace = (v) =>\n      this.setState({\n        space: v,\n      });\n    this.setIsLucifer = (v) =>\n      this.setState({\n        isLucifer: v,\n      });\n    this.setTemplate = (v) => {\n      this.setState({\n        template: v,\n      });\n      // textAreaRef.current.value = v;\n    };\n  }\n\n  componentDidMount() {\n    this.setTemplate(\n      getTemplate({\n        language: initialLanguage,\n        link,\n        title,\n      })\n    );\n\n    getStorage(\"leetcode-cheatsheet-token\")\n      .then((res) => res.result.value)\n      .then((res) => {\n        if (!res.raw) throw new Error(\"whatever\");\n        return res;\n      })\n      .catch(() => ({\n        raw: \"e574bf60b50d8d2d2db2320ee83aba3cd29cecf2\",\n      }))\n      .then((res) => {\n        const t = res.raw;\n        if (getUrlParameter(\"issue_number\")) {\n          this.setState({\n            isloading: true,\n          });\n          getCloundStorage(getUrlParameter(\"issue_number\"), {\n            token: t,\n          })\n            .then((res) => {\n              const { link, title, code, language, desc } = res;\n\n              this.setLanguage(language);\n              this.setTemplate(\n                getTemplate({\n                  desc,\n                  language,\n                  link,\n                  title,\n                  code,\n                })\n              );\n              this.setState({\n                isloading: false,\n              });\n            })\n            .catch(() =>\n              this.setState({\n                isloading: false,\n              })\n            );\n        }\n      });\n  }\n  render() {\n    const {\n      language,\n      time,\n      space,\n      isLucifer,\n      template,\n      isloading,\n    } = this.state;\n    return (\n      <>\n        {/* <AccessToken\n        visible={modalVisible}\n        onOk={() => setModalVisible(false)}\n        onCancel={() => setModalVisible(false)}\n      /> */}\n        <Button\n          type=\"link\"\n          href=\"https://mp.weixin.qq.com/s/mcRFKVWXKmlXaBow6TIwug\"\n        >\n          如何使用？\n        </Button>\n        {!isInExtension() ? (\n          <>\n            <div className=\"line\">\n              编程语言：\n              <Select\n                value={language}\n                style={{ width: 120 }}\n                onChange={(v) => {\n                  this.setLanguage(v);\n                  this.setTemplate(\n                    template\n                      .replace(new RegExp(`\\`\\`\\`.+`, \"mg\"), `\\`\\`\\`${v}`)\n                      .replace(\n                        new RegExp(`语言支持：.+`, \"mg\"),\n                        `语言支持：${displayLanguage(v)}`\n                      )\n                      .replace(\n                        new RegExp(`.+ Code:`, \"mg\"),\n                        `${displayLanguage(v)} Code:`\n                      )\n                  );\n                }}\n              >\n                <Option value=\"Python3\">Python3</Option>\n                <Option value=\"Python\">Python</Option>\n                <Option value=\"JavaScript\">JavaScript</Option>\n                <Option value=\"C++\">CPP</Option>\n                <Option value=\"Java\">Java</Option>\n                <Option value=\"GO\">Go</Option>\n                <Option value=\"C\">C</Option>\n                <Option value=\"C#\">C#</Option>\n                <Option value=\"Ruby\">Ruby</Option>\n                <Option value=\"Swift\">Swift</Option>\n                <Option value=\"Scala\">Scala</Option>\n                <Option value=\"Kotlin\">Kotlin</Option>\n                <Option value=\"Rust\">Rust</Option>\n                <Option value=\"PHP\">PHP</Option>\n                <Option value=\"TypeScript\">TypeScript</Option>\n              </Select>\n            </div>\n            <div className=\"line\">\n              常用公式（点击可复制）：\n              {formulas.map(({ formula, name, logo }) => {\n                return (\n                  <img\n                    onClick={() => {\n                      copyToClipboard(formula);\n                      message.success({\n                        content: \"复制成功~\",\n                      });\n                    }}\n                    alt={name}\n                    style={{ margin: \"0 0 0 20px\" }}\n                    src={logo}\n                    className=\"problem-icon\"\n                  />\n                );\n              })}\n            </div>\n            <div className=\"line\">\n              时间复杂度：\n              <Complexities\n                value={time}\n                onChange={(e) => {\n                  const v = e.target.value;\n                  this.setTime(v);\n                  this.setTemplate(\n                    template.replace(\n                      new RegExp(`时间复杂度：.+`, \"mg\"),\n                      `时间复杂度：$O(${v})$`\n                    )\n                  );\n                }}\n              />\n            </div>\n            <div className=\"line\">\n              空间复杂度：\n              <Complexities\n                value={space}\n                onChange={(e) => {\n                  const v = e.target.value;\n                  this.setSpace(v);\n                  this.setTemplate(\n                    template.replace(\n                      new RegExp(`空间复杂度：.+`, \"mg\"),\n                      `空间复杂度：$O(${v})$`\n                    )\n                  );\n                }}\n              />\n            </div>\n            <div className=\"line\">\n              lucifer 专属：\n              <Checkbox\n                checked={isLucifer}\n                onChange={(e) => {\n                  const v = e.target.checked;\n                  this.setIsLucifer(v);\n                  if (v) {\n                    if (template.includes(slogan)) return;\n                    this.setTemplate(template + slogan);\n                  } else {\n                    if (!template.includes(slogan)) return;\n                    this.setTemplate(template.replace(slogan, \"\"));\n                  }\n                }}\n              >\n                是否是 lucifer\n              </Checkbox>\n            </div>\n\n            <Spin spinning={isloading} delay={300}>\n              <Row>\n                <Col span=\"12\">\n                  <div>\n                    Markdown:\n                    <Button\n                      style={{ margin: \"10px\" }}\n                      type=\"primary\"\n                      onClick={() => {\n                        copyToClipboard(template);\n                        message.success({\n                          content: \"复制成功~\",\n                        });\n                      }}\n                    >\n                      点击复制 MarkDown 原文\n                    </Button>\n                    <Button\n                      style={{ margin: \"10px\" }}\n                      onClick={() => {\n                        getStorage(\"solution-backup\")\n                          .then((res) => res.result.value)\n                          .then((res) => {\n                            const raw = res.raw;\n                            this.setTemplate(raw);\n                          })\n                          .catch(() =>\n                            message.error({\n                              content: \"没有找到任何备份文件\",\n                            })\n                          );\n                      }}\n                    >\n                      恢复上次编辑内容\n                    </Button>\n                  </div>\n                  <Template\n                    template={template}\n                    onChange={(e) => {\n                      saveDraft(e.target.value);\n                      this.setTemplate(e.target.value);\n                    }}\n                  />\n                </Col>\n                <Col span=\"1\"></Col>\n                <Col span=\"11\" style={{ marginTop: \"20px\" }}>\n                  <div>预览:</div>\n                  <MarkdownRender source={template}></MarkdownRender>\n                </Col>\n              </Row>{\" \"}\n            </Spin>\n          </>\n        ) : (\n          <Button\n            type=\"link\"\n            target=\"_blank\"\n            href=\"https://leetcode-pp.github.io/leetcode-cheat/\"\n          >\n            去网站使用\n          </Button>\n        )}\n        <ul>\n          <li>\n            题解每五秒备份一次，如果你不小心刷新了浏览器可以点击下方的恢复按钮还原。由于是覆盖式备份，因此仅会保存最后一次编辑的内容。\n          </li>\n          {/* <li>\n          自动带入功能使用了 Github API，如果题目信息没有自动带入可能是 Github\n          API 调用次数限制，大家可以通过\n          <Button type=\"link\" onClick={() => setModalVisible(true)}>\n            填写 Access Token\n          </Button>\n          解决(注意此网站和力扣数据是隔离，因此填写 token\n          也是独立，互不影响的)。后期考虑搞个服务器给大家存放。\n        </li> */}\n          <li>目前公式无法预览，原因暂时不明，不过后期会支持。</li>\n          <li>后续考虑提供更多题解模板。</li>\n          <li>后续考虑支持更多主题，以及用户自定义主题。</li>\n        </ul>\n      </>\n    );\n  }\n}\n","import React, { useState, Suspense } from \"react\";\nimport { Button, Table, Empty, Tabs, Image } from \"antd\";\n\nimport \"highlight.js/styles/github.css\";\n\nimport db from \"./db/db\";\nimport collectionLogo from \"./imgs/collection.svg\";\nimport viewLogo from \"./imgs/view.svg\";\n\nimport { LEETCODE_CN_URL } from \"./constant/index\";\n// import TestCase from \"./testCase\";\nimport ProblemDetail from \"./Detail\";\nimport Roadmap from \"./roadmap/roadmap.jsx\";\nimport TagOrLink from \"./components/TagOrLink\";\nimport tempaltes from \"./codeTemplates/index\";\nimport checkUpdate from \"./checkUpdates\";\n\nimport { isInExtension, getUrlParameter } from \"./utils\";\n// import drawTree from \"canvas-binary-tree\";\nimport \"antd/dist/antd.css\";\nimport \"./App.css\";\nimport CodeTemplates from \"./codeTemplates/codeTemplate\";\nimport ComplexityRating from \"./complexityRating/index\";\nimport SolutionTemplate from \"./solutionTemplate/index\";\n// import { data as a } from \"./db/binary-tree\";\n\nconst DataStrutureVis = isInExtension()\n  ? null\n  : React.lazy(() => import(\"./dataStructureVis\"));\n\nconst { problems, selected } = db;\n\nconst { TabPane } = Tabs;\n\nconst dataSource = Object.values(problems);\nconst chrome = window.chrome;\n// function inLeetCodeWebsite(url) {\n//   return [LEETCODE_CN_URL, LEETCODE_URL].some((u) => url.includes(u));\n// }\n\nconst columns = [\n  {\n    title: \"题目\",\n    dataIndex: \"name\",\n    width: \"300\",\n    align: \"center\",\n    render: (name, row) => (\n      <Button\n        type=\"link\"\n        href={`${LEETCODE_CN_URL}/problems/${name}/`}\n        target=\"_blank\"\n      >\n        {row.id}.{name}\n      </Button>\n    ),\n  },\n  {\n    title: \"标签\",\n    dataIndex: \"pre\",\n    align: \"center\",\n    render: (tags) => (\n      <div>\n        {(tags || []).map((tag) => {\n          return (\n            <TagOrLink\n              style={{\n                width: \"100px\",\n                display: \"inline-block\",\n                margin: \"4px 0\",\n              }}\n              key={tag.text}\n              text={tag.text}\n              link={tag.link}\n              color={tag.color}\n            />\n          );\n        })}\n      </div>\n    ),\n  },\n];\nconst initialTab = getUrlParameter(\"tab\") || \"code-template\";\nfunction App() {\n  // eslint-disable-next-line\n  chrome &&\n    chrome.tabs &&\n    // eslint-disable-next-line\n    chrome.tabs.query({ active: true, lastFocusedWindow: true }, (tabs) => {\n      const currentUrl = tabs[0].url;\n      const match = currentUrl.match(/problems\\/(.+?)\\//);\n      const problemId = match && match[1];\n      setProblemId(problemId);\n      setHasSolution(!!problems[problemId]);\n      setInSelected(!!selected[problemId]);\n      // setInLeetCode(inLeetCodeWebsite(currentUrl));\n    });\n\n  // setTimeout(() => {\n  //   // setProblemId(\"uncrossed-lines\");\n  //   setProblemId(\"two-sum\");\n  //   // setInSelected(!!selected[problemId]);\n  //   setHasSolution(!!problems[problemId]);\n  // }, 1000);\n\n  const [problemId, setProblemId] = useState(\"\");\n\n  const [hasSolution, setHasSolution] = useState(false);\n  const [inSelected, setInSelected] = useState(false); // 是否被精选题解（其实就是合集）收录\n  const [page, setPage] = useState(\"\");\n  const [tab, setTab] = useState(initialTab);\n\n  // const [inLeetCode, setInLeetCode] = useState(true);\n\n  // if (!inLeetCode) return window.open(LEETCODE_CN_URL + \"/problemset/all/\");\n\n  // setTimeout(() => {\n  //   const canvas = document.querySelector(\"#canvas\");\n\n  //   drawTree(canvas, bfs([1, 2, 2, 3, 1, 2, 2, 323213213232329]));\n  // }, 1000);\n  // console.log(a);\n\n  return (\n    <div className=\"container\">\n      <div\n        className=\"tree-vis\"\n        style={{\n          display: \"none\",\n          position: \"fixed\",\n          zIndex: 99,\n          top: 0,\n          bottom: 0,\n          left: 0,\n          right: 0,\n          backgroundColor: \"rgba(0,0,0,.4)\",\n        }}\n      >\n        <div>{/* <pre>{a}</pre> */}</div>\n        <canvas width=\"1000\" height=\"1000\" id=\"canvas\"></canvas>\n      </div>\n      {isInExtension() && (\n        <>\n          <div className=\"guide-wrapper\">\n            <div className=\"guide\">\n              {page !== \"\" ? (\n                <Button type=\"link\" onClick={() => setPage(\"\")}>\n                  回到首页\n                </Button>\n              ) : (\n                \"\"\n              )}\n              {hasSolution && page === \"\" ? (\n                <Button type=\"link\" onClick={() => setPage(\"detail\")}>\n                  查看本题题解\n                  <img\n                    src={viewLogo}\n                    alt=\"view-solution\"\n                    className=\"problem-icon\"\n                    style={{ margin: \"0 0 0 10px\" }}\n                  />\n                </Button>\n              ) : (\n                \"\"\n              )}\n\n              {!hasSolution &&\n                page !== \"allSolutions\" &&\n                (inSelected ? (\n                  <Button\n                    type=\"link\"\n                    target=\"_blank\"\n                    href={selected[problemId].url}\n                  >\n                    该题已被收录到精选合集《{selected[problemId].title}\n                    》点击查看\n                    <img\n                      alt=\"view-solutions\"\n                      src={collectionLogo}\n                      className=\"problem-icon\"\n                      style={{ margin: \"0 0 0 10px\" }}\n                    />\n                  </Button>\n                ) : (\n                  <Button type=\"link\" onClick={() => setPage(\"allSolutions\")}>\n                    本题暂未被力扣加加收录，点击查看所有已收录题目~\n                  </Button>\n                ))}\n            </div>\n            {page === \"detail\" && <ProblemDetail problemId={problemId} />}\n          </div>\n\n          <div style={page === \"allSolutions\" ? {} : { display: \"none\" }}>\n            <Empty description=\"正在撰写题解...\">\n              <div className=\"row\" style={{ marginTop: \"20px\" }}>\n                所有已收录的题目\n              </div>\n              <Table\n                pagination={{ hideOnSinglePage: true }}\n                dataSource={dataSource}\n                rowKey=\"id\"\n                columns={columns}\n              />\n            </Empty>\n          </div>\n        </>\n      )}\n      {page === \"\" && (\n        <Tabs type=\"card\" activeKey={tab} onChange={setTab}>\n          <TabPane key=\"code-template\" tab=\"代码模板\">\n            <CodeTemplates tempaltes={tempaltes}></CodeTemplates>\n          </TabPane>\n          <TabPane key=\"data-structure-vis\" tab=\"数据结构可视化\">\n            {isInExtension() ? (\n              <Button\n                type=\"link\"\n                target=\"_blank\"\n                href=\"https://leetcode-pp.github.io/leetcode-cheat/?tab=data-structure-vis\"\n              >\n                去网站使用\n              </Button>\n            ) : (\n              <Suspense fallback={<div>Loading...</div>}>\n                <DataStrutureVis></DataStrutureVis>\n              </Suspense>\n            )}\n          </TabPane>\n          {!isInExtension() && (\n            <TabPane key=\"solution-template\" tab=\"题解模板\">\n              <SolutionTemplate></SolutionTemplate>\n            </TabPane>\n          )}\n\n          <TabPane key=\"complexityRating\" tab=\"复杂度速查\">\n            <ComplexityRating />\n          </TabPane>\n          <TabPane key=\"roadmap\" tab=\"学习路线\">\n            <Roadmap />\n          </TabPane>\n          {isInExtension() && (\n            <TabPane key=\"checkUpdate\" tab=\"检查更新\">\n              <div>\n                一般只要你开启了自动更新，那么当插件更新之后\n                chrome会在五个小时以内自动更新。\n                如果你想第一时间更新，或者您禁用了自动更新，都可以在这里检测最新版。\n              </div>\n              <Button\n                style={{ margin: \"20px 0 0 20px\" }}\n                type=\"primary\"\n                onClick={checkUpdate}\n              >\n                检查更新\n              </Button>\n            </TabPane>\n          )}\n\n          <TabPane key=\"about\" tab=\"关于我\">\n            <div>\n              作者是一个 Github 40K star 的前端架构师，leetcode 刷题插件\n              leetcode-cheatsheet\n              作者，掌握各种算法套路，写了十几万字的算法刷题套路电子书，公众号回复\n              <b>电子书</b>获取。\n              <Image src=\"https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg\"></Image>\n            </div>\n          </TabPane>\n        </Tabs>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\n// import App from \"./visualDebug/index\";\nimport App from \"./App\";\nimport \"./checkUpdates\";\n\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}