{
  "question": "295.find-median-from-data-stream",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "js",
      "code": "\nfunction findMedian(a) {\n  return a.length % 2 === 0\n    ? (a[a.length >> 1] + a[a.length >> (1 + 1)]) / 2\n    : a[a.length >> 1];\n}\n"
    },
    {
      "lang": "js",
      "code": "\n/**\n * initialize your data structure here.\n */\nvar MedianFinder = function() {\n  this.maxHeap = [];\n  this.minHeap = [];\n};\n\nfunction minHeapify() {\n  this.minHeap.unshift(null);\n  const a = this.minHeap;\n\n  // 为了方便大家理解，这里选用了粗暴的实现\n  // 时间复杂度为O(n)\n  // 其实可以降到O(logn)， 具体细节我不想在这里讲解和实现\n  for (let i = a.length - 1; i >> 1 > 0; i--) {\n    // 自下往上堆化\n    if (a[i] < a[i >> 1]) { // 如果子元素更小，则交换位置\n      const temp = a[i];\n      this.minHeap[i] = a[i >> 1];\n      this.minHeap[i >> 1] = temp;\n    }\n  }\n  this.minHeap.shift(null);\n}\n\nfunction maxHeapify() {\n  this.maxHeap.unshift(null);\n  const a = this.maxHeap;\n\n  // 为了方便大家理解，这里选用了粗暴的实现\n  // 时间复杂度为O(n)\n  // 其实可以降到O(logn)， 具体细节我不想在这里讲解和实现\n  for (let i = a.length - 1; i >> 1 > 0; i--) {\n    // 自下往上堆化\n    if (a[i] > a[i >> 1]) { // 如果子元素更大，则交换位置\n      const temp = a[i];\n      this.maxHeap[i] = a[i >> 1];\n      this.maxHeap[i >> 1] = temp;\n    }\n  }\n  this.maxHeap.shift(null);\n}\n\n/**\n * @param {number} num\n * @return {void}\n */\nMedianFinder.prototype.addNum = function(num) {\n  // 为了大家容易理解，这部分代码写的比较冗余\n\n  // 插入\n  if (num >= (this.minHeap[0] || Number.MIN_VALUE)) {\n    this.minHeap.push(num);\n  } else {\n    this.maxHeap.push(num);\n  }\n  // 调整两个堆的节点数量平衡\n  // 使得大顶堆的数量最多大于小顶堆一个， 且一定不小于小顶堆数量\n  if (this.maxHeap.length > this.minHeap.length + 1) {\n    // 大顶堆的堆顶元素移动到小顶堆\n    this.minHeap.push(this.maxHeap.shift());\n  }\n\n  if (this.minHeap.length > this.maxHeap.length) {\n    // 小顶堆的堆顶元素移动到大顶堆\n    this.maxHeap.push(this.minHeap.shift());\n  }\n\n  // 调整堆顶元素\n  if (this.maxHeap[0] > this.minHeap[0]) {\n    const temp = this.maxHeap[0];\n    this.maxHeap[0] = this.minHeap[0];\n    this.minHeap[0] = temp;\n  }\n\n  // 堆化\n  maxHeapify.call(this);\n  minHeapify.call(this);\n};\n\n/**\n * @return {number}\n */\nMedianFinder.prototype.findMedian = function() {\n  if ((this.maxHeap.length + this.minHeap.length) % 2 === 0) {\n    return (this.minHeap[0] + this.maxHeap[0]) / 2;\n  } else {\n    return this.maxHeap[0];\n  }\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * var obj = new MedianFinder()\n * obj.addNum(num)\n * var param_2 = obj.findMedian()\n */\n"
    },
    {
      "lang": "js",
      "code": "\n\nthis.heap.unshift(null);\n// ....\nthis.heap.shift(null);\n\n"
    },
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=295 lang=javascript\n *\n * [295] Find Median from Data Stream\n *\n * https://leetcode.com/problems/find-median-from-data-stream/description/\n *\n * algorithms\n * Hard (35.08%)\n * Total Accepted:    101.2K\n * Total Submissions: 282.4K\n * Testcase Example:  '[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]\\n[[],[1],[2],[],[3],[]]'\n *\n * Median is the middle value in an ordered integer list. If the size of the\n * list is even, there is no middle value. So the median is the mean of the two\n * middle value.\n * For example,\n *\n * [2,3,4], the median is 3\n *\n * [2,3], the median is (2 + 3) / 2 = 2.5\n *\n * Design a data structure that supports the following two operations:\n *\n *\n * void addNum(int num) - Add a integer number from the data stream to the data\n * structure.\n * double findMedian() - Return the median of all elements so far.\n *\n *\n *\n *\n * Example:\n *\n *\n * addNum(1)\n * addNum(2)\n * findMedian() -> 1.5\n * addNum(3)\n * findMedian() -> 2\n *\n *\n *\n *\n * Follow up:\n *\n *\n * If all integer numbers from the stream are between 0 and 100, how would you\n * optimize it?\n * If 99% of all integer numbers from the stream are between 0 and 100, how\n * would you optimize it?\n *\n *\n */\n/**\n * initialize your data structure here.\n */\nvar MedianFinder = function() {\n  this.maxHeap = new PriorityQueue((a, b) => a - b);\n  this.minHeap = new PriorityQueue((a, b) => b - a);\n};\n\n/**\n * @param {number} num\n * @return {void}\n */\nMedianFinder.prototype.addNum = function(num) {\n    // 我们的目标就是建立两个堆，一个大顶堆，一个小顶堆\n    // 结合中位数的特点\n    // 这两个堆需要满足:\n    // 1. 大顶堆元素都比小顶堆小（由于堆的特点其实只要比较堆顶即可）\n    // 2. 大顶堆元素不小于小顶堆，且最多比小顶堆多一个元素\n\n    // 满足上面两个条件的话，如果想要找到中位数，就比较简单了\n    // 如果两个堆数量相等（本质是总数为偶数）, 就两个堆顶元素的平均数\n    // 如果两个堆数量不相等（本质是总数为奇数）， 就取大顶堆的堆顶元素\n\n    // 问题如果保证满足上述两个特点\n\n    // 1. 保证第一点\n    this.maxHeap.enq(num);\n    // 由于小顶堆的所有数都来自大顶堆的堆顶元素（最大值）\n    // 因此可以保证第一点\n    this.minHeap.enq(this.maxHeap.deq());\n\n    // 2. 保证第二点\n    if (this.maxHeap.size() < this.minHeap.size()){\n        this.maxHeap.enq(this.minHeap.deq());\n    }\n};\n\n/**\n * @return {number}\n */\nMedianFinder.prototype.findMedian = function() {\n    if (this.maxHeap.size() == this.minHeap.size()) return (this.maxHeap.peek() + this.minHeap.peek()) /  2.0;\n    else return this.maxHeap.peek();\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * var obj = new MedianFinder()\n * obj.addNum(num)\n * var param_2 = obj.findMedian()\n */\n\n"
    }
  ]
}