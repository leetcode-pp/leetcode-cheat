{
  "question": "190.reverse-bits",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "python",
      "code": "\nclass Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        result = 0\n        for i in range(32):\n            result = (result << 1) + (n & 1)\n            n >>= 1\n        return result\n"
    },
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=190 lang=javascript\n *\n * [190] Reverse Bits\n *\n * https://leetcode.com/problems/reverse-bits/description/\n *\n * algorithms\n * Easy (30.30%)\n * Total Accepted:    173.7K\n * Total Submissions: 568.2K\n * Testcase Example:  '00000010100101000001111010011100'\n *\n * Reverse bits of a given 32 bits unsigned integer.\n *\n *\n *\n * Example 1:\n *\n *\n * Input: 00000010100101000001111010011100\n * Output: 00111001011110000010100101000000\n * Explanation: The input binary string 00000010100101000001111010011100\n * represents the unsigned integer 43261596, so return 964176192 which its\n * binary representation is 00111001011110000010100101000000.\n *\n *\n * Example 2:\n *\n *\n * Input: 11111111111111111111111111111101\n * Output: 10111111111111111111111111111111\n * Explanation: The input binary string 11111111111111111111111111111101\n * represents the unsigned integer 4294967293, so return 3221225471 which its\n * binary representation is 10101111110010110010011101101001.\n *\n *\n *\n * Note:\n *\n *\n * Note that in some languages such as Java, there is no unsigned integer type.\n * In this case, both input and output will be given as signed integer type and\n * should not affect your implementation, as the internal binary representation\n * of the integer is the same whether it is signed or unsigned.\n * In Java, the compiler represents the signed integers using 2's complement\n * notation. Therefore, in Example 2 above the input represents the signed\n * integer -3 and the output represents the signed integer -1073741825.\n *\n *\n *\n *\n * Follow up:\n *\n * If this function is called many times, how would you optimize it?\n *\n */\n/**\n * @param {number} n - a positive integer\n * @return {number} - a positive integer\n */\nvar reverseBits = function(n) {\n  let res = 0;\n  for (let i = 0; i < 32; i++) {\n    res = (res << 1) + (n & 1);\n    n = n >>> 1;\n  }\n\n  return res >>> 0;\n};\n"
    }
  ]
}