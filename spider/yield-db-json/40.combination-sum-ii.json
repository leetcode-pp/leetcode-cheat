{
  "question": "40.combination-sum-ii",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "python",
      "code": "\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        与39题的区别是不能重用元素，而元素可能有重复；\n        不能重用好解决，回溯的index往下一个就行；\n        元素可能有重复，就让结果的去重麻烦一些；\n        \"\"\"\n        size = len(candidates)\n        if size == 0:\n            return []\n        \n        # 还是先排序，主要是方便去重\n        candidates.sort()\n        \n        path = []\n        res = []\n        self._find_path(candidates, path, res, target, 0, size)\n        \n        return res\n    \n    def _find_path(self, candidates, path, res, target, begin, size):\n        if target == 0:\n            res.append(path.copy())\n        else:\n            for i in range(begin, size):\n                left_num = target - candidates[i]\n                if left_num < 0:\n                    break\n                # 如果存在重复的元素，前一个元素已经遍历了后一个元素与之后元素组合的所有可能\n                if i > begin and candidates[i] == candidates[i-1]:\n                    continue\n                path.append(candidates[i])\n                # 开始的 index 往后移了一格\n                self._find_path(candidates, path, res, left_num, i+1, size)\n                path.pop()\n"
    },
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=40 lang=javascript\n *\n * [40] Combination Sum II\n *\n * https://leetcode.com/problems/combination-sum-ii/description/\n *\n * algorithms\n * Medium (40.31%)\n * Total Accepted:    212.8K\n * Total Submissions: 519K\n * Testcase Example:  '[10,1,2,7,6,1,5]\\n8'\n *\n * Given a collection of candidate numbers (candidates) and a target number\n * (target), find all unique combinations in candidates where the candidate\n * numbers sums to target.\n * \n * Each number in candidates may only be used once in the combination.\n * \n * Note:\n * \n * \n * All numbers (including target) will be positive integers.\n * The solution set must not contain duplicate combinations.\n * \n * \n * Example 1:\n * \n * \n * Input: candidates = [10,1,2,7,6,1,5], target = 8,\n * A solution set is:\n * [\n * ⁠ [1, 7],\n * ⁠ [1, 2, 5],\n * ⁠ [2, 6],\n * ⁠ [1, 1, 6]\n * ]\n * \n * \n * Example 2:\n * \n * \n * Input: candidates = [2,5,2,1,2], target = 5,\n * A solution set is:\n * [\n * [1,2,2],\n * [5]\n * ]\n * \n * \n */\nfunction backtrack(list, tempList, nums, remain, start) {\n    if (remain < 0) return;\n    else if (remain === 0) return list.push([...tempList]);\n    for (let i = start; i < nums.length; i++) {\n      // 和39.combination-sum 的其中一个区别就是这道题candidates可能有重复\n      // 代码表示就是下面这一行\n      if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\n      tempList.push(nums[i]);\n      backtrack(list, tempList, nums, remain - nums[i], i + 1); // i + 1代表不可以重复利用， i 代表数字可以重复使用 \n      tempList.pop();\n    }\n  }\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    const list = [];\n    backtrack(list, [], candidates.sort((a, b) => a - b), target, 0);\n    return list;\n};\n"
    }
  ]
}