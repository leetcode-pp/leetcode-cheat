{
  "question": "226.invert-binary-tree",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "python",
      "code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [root]\n        while stack:\n            node = stack.pop(0)\n            node.left, node.right = node.right, node.left\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return root\n"
    },
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=226 lang=javascript\n *\n * [226] Invert Binary Tree\n *\n * https://leetcode.com/problems/invert-binary-tree/description/\n *\n * algorithms\n * Easy (57.14%)\n * Total Accepted:    311K\n * Total Submissions: 540.6K\n * Testcase Example:  '[4,2,7,1,3,6,9]'\n *\n * Invert a binary tree.\n *\n * Example:\n *\n * Input:\n *\n *\n * ⁠    4\n * ⁠  /   \\\n * ⁠ 2     7\n * ⁠/ \\   / \\\n * 1   3 6   9\n *\n * Output:\n *\n *\n * ⁠    4\n * ⁠  /   \\\n * ⁠ 7     2\n * ⁠/ \\   / \\\n * 9   6 3   1\n *\n * Trivia:\n * This problem was inspired by this original tweet by Max Howell:\n *\n * Google: 90% of our engineers use the software you wrote (Homebrew), but you\n * can’t invert a binary tree on a whiteboard so f*** off.\n *\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n  if (!root) return root;\n  // 递归\n  //   const left = root.left;\n  //   const right = root.right;\n  //   root.right = invertTree(left);\n  //   root.left = invertTree(right);\n  // 我们用stack来模拟递归\n  // 本质上递归是利用了执行栈，执行栈也是一种栈\n  // 其实这里使用队列也是一样的，因为这里顺序不重要\n\n  const stack = [root];\n  let current = null;\n  while ((current = stack.shift())) {\n    const left = current.left;\n    const right = current.right;\n    current.right = left;\n    current.left = right;\n    if (left) {\n      stack.push(left);\n    }\n    if (right) {\n      stack.push(right);\n    }\n  }\n  return root;\n};\n"
    }
  ]
}