{
  "question": "94.binary-tree-inorder-traversal",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "java",
      "code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<Integer> res = new LinkedList<>();\n    public List<Integer> inorderTraversal(TreeNode root) {\n        inorder(root);\n        return res;\n    }\n    \n    public void inorder (TreeNode root) {\n        if (root == null) return;\n        \n        inorder(root.left);\n        \n        res.add(root.val);\n        \n        inorder(root.right);\n    }\n}\n"
    },
    {
      "lang": "java",
      "code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<> ();\n        Stack<TreeNode> stack = new Stack<> ();\n\n        while (root != null || !stack.isEmpty()) {\n            while (root != null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            res.add(root.val);\n            root = root.right;\n        }\n        return res;\n    }\n}\n"
    },
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=94 lang=javascript\n *\n * [94] Binary Tree Inorder Traversal\n *\n * https://leetcode.com/problems/binary-tree-inorder-traversal/description/\n *\n * algorithms\n * Medium (55.22%)\n * Total Accepted:    422.4K\n * Total Submissions: 762.1K\n * Testcase Example:  '[1,null,2,3]'\n *\n * Given a binary tree, return the inorder traversal of its nodes' values.\n * \n * Example:\n * \n * \n * Input: [1,null,2,3]\n * ⁠  1\n * ⁠   \\\n * ⁠    2\n * ⁠   /\n * ⁠  3\n * \n * Output: [1,3,2]\n * \n * Follow up: Recursive solution is trivial, could you do it iteratively?\n * \n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    // 1. Recursive solution\n    // if (!root) return [];\n    // const left = root.left ? inorderTraversal(root.left) : [];\n    // const right = root.right ? inorderTraversal(root.right) : [];\n    // return left.concat([root.val]).concat(right);\n\n    // 2. iterative solutuon\n    if (!root) return [];\n    const stack = [root];\n    const ret = [];\n    let left = root.left;\n\n    let item = null; // stack 中弹出的当前项\n\n    while(left) {\n        stack.push(left);\n        left = left.left;\n    }\n    \n    while(item = stack.pop()) {\n        ret.push(item.val);\n        let t = item.right;\n\n        while(t) {\n            stack.push(t);\n            t = t.left;     \n        }\n    }\n\n    return ret;\n\n};\n\n"
    }
  ]
}