{
  "question": "474.ones-and-zeros-en",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "java",
      "code": "\nclass OnesAndZerosBFRecursive {\n public int findMaxForm2(String[] strs, int m, int n) {\n    return helper(strs, 0, m, n);\n }\n private int helper(String[] strs, int idx, int j, int k) {\n    if (idx == strs.length) return 0;\n    // count current idx string number of zeros and ones\n    int[] counts = countZeroOnes(strs[idx]);\n    // if j >= count0 && k >= count1, take current index string\n    int takeCurrStr = j - counts[0] >= 0 && k - counts[1] >= 0\n        ? 1 + helper(strs, idx + 1, j - counts[0], k - counts[1])\n        : -1;\n    // don't take current index string strs[idx], continue next string\n    int notTakeCurrStr = helper(strs, idx + 1, j, k);\n    return Math.max(takeCurrStr, notTakeCurrStr);\n }\n private int[] countZeroOnes(String s) {\n    int[] res = new int[2];\n    for (char ch : s.toCharArray()) {\n      res[ch - '0']++;\n    }\n    return res;\n }\n}\n"
    },
    {
      "lang": "java",
      "code": "\nclass OnesAndZerosMemoRecur {\n  public int findMaxForm4(String[] strs, int m, int n) {\n      return helper(strs, 0, m, n, new int[strs.length][m + 1][n + 1]);\n  }\n  private int helper(String[] strs, int idx, int j, int k, int[][][] memo) {\n      if (idx == strs.length) return 0;\n      // check if already calculated, return value\n      if (memo[idx][j][k] != 0) {\n        return memo[idx][j][k];\n      }\n      int[] counts = countZeroOnes(strs[idx]);\n      // if satisfy condition, take current string, strs[idx], update count0 and count1\n      int takeCurrStr = j - counts[0] >= 0 && k - counts[1] >= 0\n          ? 1 + helper(strs, idx + 1, j - counts[0], k - counts[1], memo)\n          : -1;\n      // not take current string\n      int notTakeCurrStr = helper(strs, idx + 1, j, k, memo);\n      // always keep track the max value into memory\n      memo[idx][j][k] = Math.max(takeCurrStr, notTakeCurrStr);\n      return memo[idx][j][k];\n  }\n  private int[] countZeroOnes(String s) {\n       int[] res = new int[2];\n       for (char ch : s.toCharArray()) {\n         res[ch - '0']++;\n       }\n       return res;\n  }\n}\n"
    },
    {
      "lang": "java",
      "code": "\nclass OnesAndZeros3DDP {\n  public int findMaxForm(String[] strs, int m, int n) {\n      int l = strs.length;\n      int [][][] d = new int[l + 1][m + 1][n + 1];\n      for (int i = 0; i <= l; i ++){\n        int [] nums = new int[]{0,0};\n        if (i > 0){\n          nums = countZeroOnes(strs[i - 1]);\n        }\n        for (int j = 0; j <= m; j ++){\n          for (int k = 0; k <= n; k ++){\n            if (i == 0) {\n              d[i][j][k] = 0;\n            } else if (j >= nums[0] && k >= nums[1]){\n              d[i][j][k] = Math.max(d[i - 1][j][k], d[i - 1][j - nums[0]][k - nums[1]] + 1);\n            } else {\n              d[i][j][k] = d[i - 1][j][k];\n            }\n          }\n        }\n      }\n      return d[l][m][n];\n  }\n}\n"
    },
    {
      "lang": "java",
      "code": "\nclass OnesAndZeros2DDP {\n  public int findMaxForm(String[] strs, int m, int n) {\n      int[][] dp = new int[m + 1][n + 1];\n      for (String s : strs) {\n        int[] counts = countZeroOnes(s);\n        for (int i = m; i >= counts[0]; i--) {\n          for (int j = n; j >= counts[1]; j--) {\n            dp[i][j] = Math.max(1 + dp[i - counts[0]][j - counts[1]], dp[i][j]);\n          }\n        }\n      }\n      return dp[m][n];\n  }\n  private int[] countZeroOnes(String s) {\n       int[] res = new int[2];\n       for (char ch : s.toCharArray()) {\n         res[ch - '0']++;\n       }\n       return res;\n  }\n}\n\n"
    },
    {
      "lang": "python",
      "code": "\nclass Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        return self.helper(strs, m, n, 0)\n    \n    def helper(self, strs, m, n, idx):\n        if idx == len(strs):\n            return 0\n        take_curr_str = -1\n        count0, count1 = strs[idx].count('0'), strs[idx].count('1')\n        if m >= count0 and n >= count1:\n            take_curr_str = max(take_curr_str, self.helper(strs, m - count0, n - count1, idx + 1) + 1)\n        not_take_curr_str = self.helper(strs, m, n, idx + 1)\n        return max(take_curr_str, not_take_curr_str)\n        \n"
    },
    {
      "lang": "python",
      "code": "\nclass Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        memo = {k:[[0]*(n+1) for _ in range(m+1)] for k in range(len(strs)+1)}\n        return self.helper(strs, 0, m, n, memo)\n    \n    def helper(self, strs, idx, m, n, memo):\n        if idx == len(strs):\n            return 0\n        if memo[idx][m][n] != 0:\n            return memo[idx][m][n]\n        take_curr_str = -1\n        count0, count1 = strs[idx].count('0'), strs[idx].count('1')\n        if m >= count0 and n >= count1:\n            take_curr_str = max(take_curr_str, self.helper(strs, idx + 1, m - count0, n - count1, memo) + 1)\n        not_take_curr_str = self.helper(strs, idx + 1, m, n, memo)\n        memo[idx][m][n] = max(take_curr_str, not_take_curr_str)\n        return memo[idx][m][n]\n"
    },
    {
      "lang": "python",
      "code": "\nclass Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        l = len(strs)\n        dp = [[0]*(n+1) for _ in range(m+1)]\n        for i in range(1, l + 1):\n              count0, count1 = strs[i - 1].count('0'), strs[i - 1].count('1')\n              for i in reversed(range(count0, m + 1)):\n                for j in reversed(range(count1, n + 1)):\n                    dp[i][j] = max(dp[i][j], 1 + dp[i - count0][j - count1])\n        return dp[m][n]\n"
    }
  ]
}