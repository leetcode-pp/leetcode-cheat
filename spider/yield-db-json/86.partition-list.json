{
  "question": "86.partition-list",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "python",
      "code": "\nclass Solution:\n    def partition(self, head: ListNode, x: int) -> ListNode:\n        \"\"\"在原链表操作，思路基本一致，只是通过指针进行区分而已\"\"\"\n        # 在链表最前面设定一个初始node作为锚点，方便返回最后的结果\n        first_node = ListNode(0)\n        first_node.next = head\n        # 设计三个指针，一个指向小于x的最后一个节点，即前后分离点\n        # 一个指向当前遍历节点的前一个节点\n        # 一个指向当前遍历的节点\n        sep_node = first_node\n        pre_node = first_node\n        current_node = head\n        \n        while current_node is not None:\n            if current_node.val < x:\n                # 注意有可能出现前一个节点就是分离节点的情况\n                if pre_node is sep_node:\n                    pre_node = current_node\n                    sep_node = current_node\n                    current_node = current_node.next\n                else:\n                    # 这段次序比较烧脑\n                    pre_node.next = current_node.next\n                    current_node.next = sep_node.next\n                    sep_node.next = current_node\n                    sep_node = current_node\n                    current_node = pre_node.next\n            else:\n                pre_node = current_node\n                current_node = pre_node.next\n        \n        return first_node.next\n"
    },
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=86 lang=javascript\n *\n * [86] Partition List\n *\n * https://leetcode.com/problems/partition-list/description/\n *\n * algorithms\n * Medium (36.41%)\n * Total Accepted:    155.1K\n * Total Submissions: 425.1K\n * Testcase Example:  '[1,4,3,2,5,2]\\n3'\n *\n * Given a linked list and a value x, partition it such that all nodes less\n * than x come before nodes greater than or equal to x.\n * \n * You should preserve the original relative order of the nodes in each of the\n * two partitions.\n * \n * Example:\n * \n * \n * Input: head = 1->4->3->2->5->2, x = 3\n * Output: 1->2->2->4->3->5\n * \n * \n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} x\n * @return {ListNode}\n */\nvar partition = function(head, x) {\n    const dummyHead1 = {\n        next: null\n    }\n    const dummyHead2 = {\n        next: null\n    }\n    \n    let current = {\n        next: head\n    };\n    let currentL1 = dummyHead1;\n    let currentL2 = dummyHead2;\n    while(current.next) {\n        current = current.next;\n        if (current.val < x) {\n            currentL1.next = current;\n            currentL1 = current;\n        } else {\n            currentL2.next = current;\n            currentL2 = current;\n        }\n    }\n    \n    currentL2.next = null;\n \n    currentL1.next = dummyHead2.next;\n\n    return dummyHead1.next;\n};\n"
    }
  ]
}