{
  "question": "145.binary-tree-postorder-traversal",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=145 lang=javascript\n *\n * [145] Binary Tree Postorder Traversal\n *\n * https://leetcode.com/problems/binary-tree-postorder-traversal/description/\n *\n * algorithms\n * Hard (47.06%)\n * Total Accepted:    242.6K\n * Total Submissions: 512.8K\n * Testcase Example:  '[1,null,2,3]'\n *\n * Given a binary tree, return the postorder traversal of its nodes' values.\n *\n * Example:\n *\n *\n * Input: [1,null,2,3]\n * ⁠  1\n * ⁠   \\\n * ⁠    2\n * ⁠   /\n * ⁠  3\n *\n * Output: [3,2,1]\n *\n *\n * Follow up: Recursive solution is trivial, could you do it iteratively?\n *\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n  // 1. Recursive solution\n\n  // if (!root) return [];\n\n  // return postorderTraversal(root.left).concat(postorderTraversal(root.right)).concat(root.val);\n\n  // 2. iterative solutuon\n\n  if (!root) return [];\n  const ret = [];\n  const stack = [root];\n  let p = root; // 标识元素，用来判断节点是否应该出栈\n\n  while (stack.length > 0) {\n    const top = stack[stack.length - 1];\n    if (\n      top.left === p ||\n      top.right === p || // 子节点已经遍历过了\n      (top.left === null && top.right === null) // 叶子元素\n    ) {\n      p = stack.pop();\n      ret.push(p.val);\n    } else {\n      if (top.right) {\n        stack.push(top.right);\n      }\n      if (top.left) {\n        stack.push(top.left);\n      }\n    }\n  }\n\n  return ret;\n};\n\n"
    }
  ]
}