{
  "question": "887.super-egg-drop",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "js",
      "code": "\n const dp = Array(K + 1);\n    dp[0] = Array(N + 1).fill(0);\n    for (let i = 1; i < K + 1; i++) {\n      dp[i] = [0];\n      for (let j = 1; j < N + 1; j++) {\n        // 只有一个鸡蛋\n        if (i === 1) {\n          dp[i][j] = j;\n          continue;\n        }\n        // 只有一层楼\n        if (j === 1) {\n          dp[i][j] = 1;\n          continue;\n        }\n\n        // 每一层我们都模拟一遍\n        const all = [];\n        for (let k = 1; k < j + 1; k++) {\n          const brokenCount = dp[i - 1][k - 1]; // 如果碎了\n          const notBrokenCount = dp[i][j - k]; // 如果没碎\n          all.push(Math.max(brokenCount, notBrokenCount)); // 最坏的可能\n        }\n        dp[i][j] = Math.min(...all) + 1; // 最坏的集合中我们取最好的情况\n      }\n    }\n\n    return dp[K][N];\n"
    },
    {
      "lang": "js",
      "code": "\n/**\n * @param {number} K\n * @param {number} N\n * @return {number}\n */\nvar superEggDrop = function(K, N) {\n  // 不选择dp[K][M]的原因是dp[M][K]可以简化操作\n  const dp = Array(N + 1).fill(0).map(_ => Array(K + 1).fill(0))\n  \n  let m = 0;\n  while (dp[m][K] < N) {\n      m++;\n      for (let k = 1; k <= K; ++k)\n          dp[m][k] = dp[m - 1][k - 1] + 1 + dp[m - 1][k];\n  }\n  return m;\n};\n"
    }
  ]
}