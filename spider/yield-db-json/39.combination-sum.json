{
  "question": "39.combination-sum",
  "companys": [
    "TODO"
  ],
  "tags": [
    "TODO"
  ],
  "reslove": [
    {
      "lang": "python",
      "code": "\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        \"\"\"\n        回溯法，层层递减，得到符合条件的路径就加入结果集中，超出则剪枝；\n        主要是要注意一些细节，避免重复等；\n        \"\"\"\n        size = len(candidates)\n        if size <= 0:\n            return []\n        \n        # 先排序，便于后面剪枝\n        candidates.sort()\n        \n        path = []\n        res = []\n        self._find_path(target, path, res, candidates, 0, size)\n        \n        return res\n        \n    def _find_path(self, target, path, res, candidates, begin, size):\n        \"\"\"沿着路径往下走\"\"\"\n        if target == 0:\n            res.append(path.copy())\n        else:\n            for i in range(begin, size):\n                left_num = target - candidates[i]\n                # 如果剩余值为负数，说明超过了，剪枝\n                if left_num < 0:\n                    break\n                # 否则把当前值加入路径\n                path.append(candidates[i])\n                # 为避免重复解，我们把比当前值小的参数也从下一次寻找中剔除，\n                # 因为根据他们得出的解一定在之前就找到过了\n                self._find_path(left_num, path, res, candidates, i, size)\n                # 记得把当前值移出路径，才能进入下一个值的路径\n                path.pop()\n"
    },
    {
      "lang": "js",
      "code": "\n/*\n * @lc app=leetcode id=39 lang=javascript\n *\n * [39] Combination Sum\n *\n * https://leetcode.com/problems/combination-sum/description/\n *\n * algorithms\n * Medium (46.89%)\n * Total Accepted:    326.7K\n * Total Submissions: 684.2K\n * Testcase Example:  '[2,3,6,7]\\n7'\n *\n * Given a set of candidate numbers (candidates) (without duplicates) and a\n * target number (target), find all unique combinations in candidates where the\n * candidate numbers sums to target.\n *\n * The same repeated number may be chosen from candidates unlimited number of\n * times.\n *\n * Note:\n *\n *\n * All numbers (including target) will be positive integers.\n * The solution set must not contain duplicate combinations.\n *\n *\n * Example 1:\n *\n *\n * Input: candidates = [2,3,6,7], target = 7,\n * A solution set is:\n * [\n * ⁠ [7],\n * ⁠ [2,2,3]\n * ]\n *\n *\n * Example 2:\n *\n *\n * Input: candidates = [2,3,5], target = 8,\n * A solution set is:\n * [\n * [2,2,2,2],\n * [2,3,3],\n * [3,5]\n * ]\n *\n */\n\nfunction backtrack(list, tempList, nums, remain, start) {\n  if (remain < 0) return;\n  else if (remain === 0) return list.push([...tempList]);\n  for (let i = start; i < nums.length; i++) {\n    tempList.push(nums[i]);\n    backtrack(list, tempList, nums, remain - nums[i], i); // 数字可以重复使用， i + 1代表不可以重复利用\n    tempList.pop();\n  }\n}\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n  const list = [];\n  backtrack(list, [], candidates.sort((a, b) => a - b), target, 0);\n  return list;\n};\n"
    }
  ]
}